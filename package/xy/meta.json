{
  "src::error": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::error(<string> exception , <object> options)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(exception , options){\n\n        /**\n * \n * 抛出一个异常\n * \n * @param {string} exception 异常名称\n * \n * @param {object} [options = {}] 异常参数\n * \n */\n\n return {\n    exception,\n    ...options\n } ;\n\n    }\n    \n                    return function(exception , options = {}){\n    \n                        \n    \n                        return main.call(this , exception , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "error"
  },
  "src::array.add.sort": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::array.add.sort(<array> data , <mixed> item , <function> sortFn)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    \n/**\n * \n * 以排序的形式添加数组项\n * \n * @param {array} data 数组\n * \n * @param {mixed} item 添加项\n * \n * @param {function} sortFn 排序函数\n * \n */\n\n function main(data , item , sortFn){\n\n    let {\n        length\n    } = data ;\n\n    if(length === 0){\n\n        data.push(item) ;\n    \n    }else{\n\n        data.splice(getInsertIndex(data , item , sortFn , 0 , data.length - 1) , 0 , item) ;\n    }\n }\n\n function getInsertIndex(data , item , sortFn , start , end){\n\n    let index ;\n\n    if(start === end){\n\n        index = start ;\n    \n    }else{\n\n        index = start + Math.round((end - start) / 2) ;\n    }\n\n    let currentItem = data[index],\n        value = sortFn(currentItem , item);\n\n    if(value <= 0){\n\n        start = index + 1;\n\n        if(start > end || sortFn(data[start] , item) > 0){\n\n            return index + 1;\n        \n        }\n    \n    }else if(value > 0){\n\n        end = index - 1 ;\n\n        if(start > end){\n\n            return index === 0 ? index : index - 1;\n        }\n    }\n\n    return getInsertIndex(data , item , sortFn , start , end) ;\n }\n    \n                    return function(data , item , sortFn){\n    \n                        \n    \n                        return main.call(this , data , item , sortFn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.add.sort"
  },
  "src::array.clear": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::array.clear(<array> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 清除数组\n * \n * @param {array} data 数组\n * \n * \n */\n\ndata.splice(0 , data.length) ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.clear"
  },
  "src::array.clone": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::array.clone(<array> data)",
    "standard": true,
    "importNames": [
      "src::data.clone"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let clone;\n    \n                    let var_init_locked_1608956297266;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 对于数组进行拷贝\n * \n * @import clone from data.clone\n * \n * @param {array} data 数组\n * \n * \n */\n\n let result = [] ;\n\n for(let item of data){\n\n    result.push(clone(item)) ;\n }\n\n return result ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297266){\n\n            clone = include('src::data.clone');\n\n            var_init_locked_1608956297266 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.clone"
  },
  "src::is.object.simple": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.object.simple(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为简单对象类型\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为简单对象类型则返回 true , 否则返回 false \n * \n */\n\nreturn data instanceof Object && data.constructor === Object;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.object.simple"
  },
  "src::object.assign": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::object.assign(<object> dest , <object> ...sources)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::data.clone"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,clone;\n    \n                    let var_init_locked_1608956297284;\n    \n                    \n\n                    \n/**\n * \n * 积极深度合并\n * \n * @import isObject from is.object.simple\n * \n * @import clone from data.clone\n * \n * @param {object} dest 目标数据\n * \n * @param {object} [...sources] 来源数据\n * \n * @return {object} 合并后数据\n * \n * @scoped\n * \n */\n\nfunction assign(dest , source){\n\n    if(isObject(dest) && isObject(source)){\n\n        let names = Object.keys(source) ;\n\n        for(let name of names){\n\n            dest[name] = clone(source[name]) ;\n        }\n\n    }\n}\n\nfunction main(dest , ...sources){\n\n    for(let source of sources){\n\n        assign(dest , source) ;\n    }\n\n    return dest ;\n\n}\n    \n                    return function(dest , ...sources){\n    \n                        \n        if(!var_init_locked_1608956297284){\n\n            isObject = include('src::is.object.simple');\nclone = include('src::data.clone');\n\n            var_init_locked_1608956297284 = true ;\n        }\n        \n    \n                        return main.call(this , dest , ...sources) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.assign"
  },
  "src::date.clone": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::date.clone(<Date> date)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(date){\n\n        /**\n * \n * 复制日期\n * \n * @param {Date} date 日期\n * \n * @return {Date} 复制了与指定日期\n * \n */\n\nreturn new Date(date.valueOf()) ;\n\n    }\n    \n                    return function(date){\n    \n                        \n    \n                        return main.call(this , date) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.clone"
  },
  "src::is.type": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.type(<mixed> data , <string> type)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , type){\n\n        /**\n * \n * 对于 typeof 的简单封装\n * \n * @param {mixed} data 检验数据\n * \n * @param {string} type 检验数据类型\n * \n * @return {boolean} 如果检验数据的数据类型与检验数据类型一致，则返回 true，否则返回 false \n * \n */\n\n return typeof data === type ;\n\n    }\n    \n                    return function(data , type){\n    \n                        \n    \n                        return main.call(this , data , type) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.type"
  },
  "src::is.array": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.array(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isType;\n    \n                    let var_init_locked_1608956297291;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为数组类型\n * \n * @import is.type\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为数组类型则返回 true , 否则返回 false \n * \n */\n\n return Array.isArray(data) ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297291){\n\n            isType = include('src::is.type');\n\n            var_init_locked_1608956297291 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.array"
  },
  "src::is.date": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.date(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为日期类型\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为日期类型则返回 true , 否则返回 false \n * \n */\n\n\n return Object.prototype.toString.call(data) === '[object Date]' ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.date"
  },
  "src::data.clone": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::data.clone(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::object.assign",
      "src::array.clone",
      "src::date.clone",
      "src::is.array",
      "src::is.date",
      "src::data.clone"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,assign,arrayClone,dateClone,isArray,isDate,clone;\n    \n                    let var_init_locked_1608956297274;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 数据拷贝\n * \n * @import isObject from is.object.simple\n * \n * @import assign from object.assign\n * \n * @import array.clone\n * \n * @import date.clone\n * \n * @import is.array\n * \n * @import is.date\n * \n * @import clone from .clone\n * \n * @param {mixed} data 数据\n * \n * @return {mixed} 拷贝后的数据 \n * \n */\n\n if(isObject(data)){\n\n    return assign({} , data) ;\n\n }else if(isArray(data)){\n\n    return arrayClone(data) ;\n\n }else if(isDate(data)){\n\n    return dateClone(data) ;\n }\n\n return data ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297274){\n\n            isObject = include('src::is.object.simple');\nassign = include('src::object.assign');\narrayClone = include('src::array.clone');\ndateClone = include('src::date.clone');\nisArray = include('src::is.array');\nisDate = include('src::is.date');\nclone = include('src::data.clone');\n\n            var_init_locked_1608956297274 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.clone"
  },
  "src::array.dates.includes": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::array.dates.includes(<Date[]> dates , <Date> date , <array> fields)",
    "standard": true,
    "importNames": [
      "src::date.get.properties"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956297303;\n    \n                    \n\n                    function main(dates , date , fields){\n\n        \n/**\n * \n * 基于日历数组进行包含性检测\n * \n * @import get from date.get.properties\n * \n * @param {Date[]} dates 日历数组\n * \n * @param {Date} date 校验匹配数据项\n * \n * @param {array} [fields = ['year' , 'month' , 'day']] 校验字段项\n * \n * @return {boolean} 如果日历数组中包含校验项则返回 true , 否则返回 false \n * \n */\n\n let {\n    year,\n    month,\n    day\n } = get(date , fields) ;\n\n for(let date of dates){\n\n    let {\n        year:itemYear,\n        month:itemMonth,\n        day:itemDay\n    } = get(date , fields) ;\n\n    if(itemYear === year && itemMonth === month && itemDay === day){\n\n        return true ;\n    }\n }\n\n return false ;\n \n\n\n\n \n\n    }\n    \n                    return function(dates , date , fields = ['year' , 'month' , 'day']){\n    \n                        \n        if(!var_init_locked_1608956297303){\n\n            get = include('src::date.get.properties');\n\n            var_init_locked_1608956297303 = true ;\n        }\n        \n    \n                        return main.call(this , dates , date , fields) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.dates.includes"
  },
  "src::is.empty": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::is.empty(<mixed> data , <boolean> allowEmptyString)",
    "standard": true,
    "importNames": [
      "src::is.array"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isArray;\n    \n                    let var_init_locked_1608956297321;\n    \n                    \n\n                    function main(data , allowEmptyString){\n\n        /**\n * \n * 判定数据是否为空\n * \n * @import is.array\n * \n * @param {mixed} data 检验数据\n * \n * @param {boolean} [allowEmptyString = false] 是否视空符串不为空，默认空符串为空\n * \n * @return {mixed} 如果给定值为空则返回 true , 否则返回 false  \n * \n */\n\nreturn (data == null) || (!allowEmptyString ? data === '' : false) || (isArray(data) && data.length === 0);\n\n    }\n    \n                    return function(data , allowEmptyString = false){\n    \n                        \n        if(!var_init_locked_1608956297321){\n\n            isArray = include('src::is.array');\n\n            var_init_locked_1608956297321 = true ;\n        }\n        \n    \n                        return main.call(this , data , allowEmptyString) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.empty"
  },
  "src::is.string": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.string(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isType;\n    \n                    let var_init_locked_1608956297325;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为字符串类型\n * \n * @import is.type\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为字符串类型则返回 true , 否则返回 false \n * \n */\n\nreturn isType(data , 'string') ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297325){\n\n            isType = include('src::is.type');\n\n            var_init_locked_1608956297325 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.string"
  },
  "src::array.from": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::array.from(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.empty",
      "src::is.string"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isEmpty,isString;\n    \n                    let var_init_locked_1608956297317;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 将非数组数据打包成数组数据\n * \n * @import is.empty\n * \n * @import is.string\n * \n * @param {mixed} data 数据\n * \n * @return {array} 数组数据\n * \n */\n\nif(isEmpty(data)){\n\n    return [];\n}\n\nif (data && data.length !== undefined && !isString(data)) {\n\n    return Array.from(data);\n\n}\n\nreturn [\n    data\n];\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297317){\n\n            isEmpty = include('src::is.empty');\nisString = include('src::is.string');\n\n            var_init_locked_1608956297317 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.from"
  },
  "src::date.get.properties": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::date.get.properties(<Date> date , <string[]> names)",
    "standard": true,
    "importNames": [
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from;\n    \n                    let var_init_locked_1608956297310;\n    \n                    \n\n                    function main(date , names){\n\n        \n/**\n * \n * 获得指定日期的属性值\n * \n * @import from from array.from\n * \n * @param {Date} date 日期对象\n * \n * @param {string[]} [names] 属性名称集合\n * \n * @return {object} 日期描述\n * \n */\n\n names = from(names) ;\n\n let result = {} ;\n\n for(name of names){\n\n    let value ;\n\n    switch(name){\n\n        case 'year':\n\n            value = date.getFullYear() ;\n\n            break ;\n\n        case 'month':\n\n            value = date.getMonth() + 1 ;\n\n            break ;\n\n        case 'day':\n\n            value = date.getDate() ;\n    }\n\n    result[name] = value ;\n }\n\n return result ;\n\n    }\n    \n                    return function(date , names){\n    \n                        \n        if(!var_init_locked_1608956297310){\n\n            from = include('src::array.from');\n\n            var_init_locked_1608956297310 = true ;\n        }\n        \n    \n                        return main.call(this , date , names) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.get.properties"
  },
  "src::array.includes": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::array.includes(<mixed> data , <mixed> checkItem)",
    "standard": true,
    "importNames": [
      "src::array.indexOf"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let indexOf;\n    \n                    let var_init_locked_1608956297328;\n    \n                    \n\n                    function main(data , checkItem){\n\n        \n/**\n * \n * 函数实现说明\n * \n * @import indexOf from array.indexOf\n * \n * @param {mixed} data 数组\n * \n * @param {mixed} checkItem 检测项\n * \n * @return {boolean} 如果检测项存在数组中则返回 true , 否则返回 false\n * \n */\n\n return indexOf(data , checkItem) !== -1 ;\n\n    }\n    \n                    return function(data , checkItem){\n    \n                        \n        if(!var_init_locked_1608956297328){\n\n            indexOf = include('src::array.indexOf');\n\n            var_init_locked_1608956297328 = true ;\n        }\n        \n    \n                        return main.call(this , data , checkItem) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.includes"
  },
  "src::is.number": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.number(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isType;\n    \n                    let var_init_locked_1608956297350;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为数值类型\n * \n * @import is.type\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为数值类型则返回 true , 否则返回 false \n * \n */\n\nreturn isType(data , 'number') && isFinite(data);\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297350){\n\n            isType = include('src::is.type');\n\n            var_init_locked_1608956297350 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.number"
  },
  "src::is.boolean": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.boolean(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isType;\n    \n                    let var_init_locked_1608956297353;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为布尔类型\n * \n * @import is.type\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为布尔类型则返回 true , 否则返回 false \n * \n */\n\nreturn isType(data , 'boolean') ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297353){\n\n            isType = include('src::is.type');\n\n            var_init_locked_1608956297353 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.boolean"
  },
  "src::is.function": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::is.function(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isType;\n    \n                    let var_init_locked_1608956297356;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为函数类型\n * \n * @import is.type\n * \n * @param {mixed} data 检验数据\n * \n * @return {mixed} 如果给定值为函数类型则返回 true , 否则返回 false\n * \n */\n\nreturn isType(data , 'function') && !data.__ZBEE_IS_CLASS__;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297356){\n\n            isType = include('src::is.type');\n\n            var_init_locked_1608956297356 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.function"
  },
  "src::data.type": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::data.type(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::is.array",
      "src::is.string",
      "src::is.number",
      "src::is.boolean",
      "src::is.date",
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,isArray,isString,isNumber,isBoolean,isDate,isFunction;\n    \n                    let var_init_locked_1608956297346;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 返回数据类型描述\n * \n * @import isObject from is.object.simple\n * \n * @import is.array\n * \n * @import is.string\n * \n * @import is.number\n * \n * @import is.boolean\n * \n * @import is.date\n * \n * @import is.string\n * \n * @import is.function\n * \n * @param {mixed} data 数据\n * \n * @return {string} 数据类型描述 \n * \n */\n\n if(isObject(data)){\n\n    return 'object' ;\n }\n\n if(isArray(data)){\n\n    return 'array' ;\n }\n\n if(isString(data)){\n\n    return 'string' ;\n }\n\n if(isNumber(data)){\n\n   return 'number' ;\n }\n\n if(isBoolean(data)){\n\n   return 'boolean' ;\n }\n\n if(isDate(data)){\n\n  return 'date' ;\n  \n }\n\n if(isFunction(data)){\n\n   return 'function' ;\n }\n\n return 'other' ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297346){\n\n            isObject = include('src::is.object.simple');\nisArray = include('src::is.array');\nisString = include('src::is.string');\nisNumber = include('src::is.number');\nisBoolean = include('src::is.boolean');\nisDate = include('src::is.date');\nisString = include('src::is.string');\nisFunction = include('src::is.function');\n\n            var_init_locked_1608956297346 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.type"
  },
  "src::data.equals": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::data.equals(<mixed> value1 , <mixeds> value2)",
    "standard": true,
    "importNames": [
      "src::data.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getType;\n    \n                    let var_init_locked_1608956297338;\n    \n                    \n\n                    /**\n * \n * 匹配两个对象数据是否匹配\n * \n * @import getType from data.type\n * \n * @param {mixed} value1 第一个对象数据\n * \n * @param {mixeds} value2 第二个对象数据\n * \n * @return {boolean} 如果对象数据匹配则返回 true ， 否则返回 false\n * \n */\n\n function main(value1 , value2){\n\n    if(value1 === value2){\n\n        return true ;\n    }\n\n    let type1 = getType(value1),\n        type2 = getType(value2) ;\n\n    if(type1 === type2){\n\n        if(value1 === value2){\n\n            return true ;\n        }\n\n        switch(type1){\n\n            case 'object':\n\n                return object_equals(value1 , value2) ;\n\n            case 'array':\n\n                return array_equals(value1 , value2) ;\n\n            case 'date':\n\n                return date_equals(value1 , value2) ;\n        }\n    }\n\n    return false ;\n }\n\n const {\n    keys\n } = Object ;\n\n function object_equals(value1 , value2){\n\n    let names1 = keys(value1),\n        names2 = keys(value2);\n\n    if(names1.length !== names2.length){\n\n        return false ;\n    }\n\n    for(let name of names1){\n\n        if(!names2.includes(name)){\n\n            return false ;\n        }\n\n        if(!main(value1[name] , value2[name])){\n\n            return false ;\n        }\n    }\n\n    return true ;\n }\n\n function array_equals(value1 , value2){\n\n    if(value1.length !== value2.length){\n\n        return false ;\n\n    }\n\n    let len = value1.length ;\n\n    for(let i = 0 ; i < len ; i ++){\n\n        if(!main(value1[i] , value2[i])){\n\n            return false ;\n        }\n    }\n\n    return true ;\n }\n\n function date_equals(value1 , value2){\n\n    return value1.getTime() === value2.getTime() ;\n }\n    \n                    return function(value1 , value2){\n    \n                        \n        if(!var_init_locked_1608956297338){\n\n            getType = include('src::data.type');\n\n            var_init_locked_1608956297338 = true ;\n        }\n        \n    \n                        return main.call(this , value1 , value2) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.equals"
  },
  "src::array.indexOf": {
    "meta": "code.meta.script.function",
    "signature": "<Number> src::array.indexOf(<mixed> data , <mixed> checkItem)",
    "standard": true,
    "importNames": [
      "src::data.equals"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let equals;\n    \n                    let var_init_locked_1608956297332;\n    \n                    \n\n                    function main(data , checkItem){\n\n        \n/**\n * \n * 返回指定项目对应的下标\n * \n * @import equals from data.equals\n * \n * @param {mixed} data 数组\n * \n * @param {mixed} checkItem 检测项\n * \n * @return {Number} 数组下标\n * \n */\n\n let {\n     length\n } = data ;\n\nfor(let i = 0 ; i < length ; i ++){\n\n    if(equals(data[i] , checkItem)){\n\n        return i ;\n    }\n }\n\n return -1 ;\n\n    }\n    \n                    return function(data , checkItem){\n    \n                        \n        if(!var_init_locked_1608956297332){\n\n            equals = include('src::data.equals');\n\n            var_init_locked_1608956297332 = true ;\n        }\n        \n    \n                        return main.call(this , data , checkItem) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.indexOf"
  },
  "src::array.insert.after": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::array.insert.after(<array> data , <mixed> insertItem , <mixed> existItem)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , insertItem , existItem){\n\n        \n/**\n * \n * 在数组中指定项之后添加\n * \n * @param {array} data 目标数组\n * \n * @param {mixed} insertItem 需要添加的项\n * \n * @param {mixed} existItem 指定项\n * \n */\n\n let index = data.indexOf(existItem) ;\n\n if(index !== -1){\n\n    data.splice(index + 1 , 0 , insertItem) ;\n }\n\n    }\n    \n                    return function(data , insertItem , existItem){\n    \n                        \n    \n                        return main.call(this , data , insertItem , existItem) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.insert.after"
  },
  "src::array.insert.before": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::array.insert.before(<array> data , <mixed> insertItem , <mixed> existItem)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , insertItem , existItem){\n\n        \n/**\n * \n * 在数组中指定项之前添加\n * \n * @param {array} data 目标数组\n * \n * @param {mixed} insertItem 需要添加的项\n * \n * @param {mixed} existItem 指定项\n * \n */\n\n let index = data.indexOf(existItem) ;\n\n if(index !== -1){\n\n    data.splice(index , 0 , insertItem) ;\n }\n\n    }\n    \n                    return function(data , insertItem , existItem){\n    \n                        \n    \n                        return main.call(this , data , insertItem , existItem) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.insert.before"
  },
  "src::array.insert": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::array.insert(<array> data , <number> index , <mixed> ...items)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , index , ...items){\n\n        \n/**\n * \n * 在指定下标处插入项\n * \n * @param {array} data 数组\n * \n * @param {number} index 数组下标\n * \n * @param {mixed} [...items] 项\n * \n */\n\n data.splice(index , 0 , ...items) ;\n\n    }\n    \n                    return function(data , index , ...items){\n    \n                        \n    \n                        return main.call(this , data , index , ...items) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.insert"
  },
  "src::array.object.property": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::array.object.property(<array> data , <string> name)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , name){\n\n        \n/**\n * \n * 获取数组项对象中的属性形成新的数组\n * \n * @param {array} data 数组\n * \n * @param {string} name 属性名称\n * \n * @return {array} 数组\n * \n */\n\n let result = [] ;\n\n for(let item of data){\n\n    result.push(item[name]) ;\n }\n\n return result ;\n\n    }\n    \n                    return function(data , name){\n    \n                        \n    \n                        return main.call(this , data , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.object.property"
  },
  "src::array.proxy": {
    "meta": "code.meta.script.function",
    "signature": "<array.Proxy> src::array.proxy(<mixed> target)",
    "standard": true,
    "importNames": [
      "src::object.proxy",
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let createProxy,from;\n    \n                    let var_init_locked_1608956297380;\n    \n                    \n\n                    \n/**\n * \n * 数组代理\n * \n * @import createProxy from object.proxy\n * \n * @import from from array.from\n * \n * @param {mixed} target 需要代理的对象\n * \n * @return {array.Proxy} 代理对象引用 \n * \n */\n\n function main(target){\n\n    return new Proxy(target) ;\n }\n\n class Proxy extends Array{\n\n    constructor(target){\n\n        super() ;\n\n        this.push(...from(target)) ;\n    }\n\n    includes(target){\n\n        let proxies = this ;\n\n        for(let proxy of proxies){\n\n            if(proxy.target === target){\n\n                return true ;\n            }\n        }\n\n        return false ;\n    }\n\n    push(...items){\n\n        let proxies = [] ;\n\n        for(let item of items){\n\n            proxies.push(createProxy(item)) ;\n        }\n\n        super.push(...proxies) ;\n    }\n\n    call(...args){\n\n        return doExecute(this , 'call' , ...args) ;\n    }\n }\n\n function doExecute(proxies , method , ...args){\n\n    let result = [] ;\n\n    for(let proxy of proxies){\n\n        result.push(proxy[method](...args)) ;\n    }\n\n    return result ;\n }\n    \n                    return function(target){\n    \n                        \n        if(!var_init_locked_1608956297380){\n\n            createProxy = include('src::object.proxy');\nfrom = include('src::array.from');\n\n            var_init_locked_1608956297380 = true ;\n        }\n        \n    \n                        return main.call(this , target) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.proxy"
  },
  "src::class.empty": {
    "meta": "code.meta.script.function",
    "signature": "<function> src::class.empty()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956297450;\n\n                    function main(){\n\n        \n/**\n * \n * 返回一个空类\n * \n * @once\n * \n * @return {function} 类引用 \n * \n */\n\n return class {\n\n } ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956297450){\n\n            return var_once_value_1608956297450 ;\n\n        }\n        return var_once_value_1608956297450 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "class.empty"
  },
  "src::map.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::map.constructor()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 初始化 Map 对象\n * \n */\n\nthis.map = new Map() ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.constructor"
  },
  "src::map.size": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::map.size()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 获得当前 Map 的键值对数量\n * \n * @return {number} 数量 \n * \n */\n\nreturn this.map.size ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.size"
  },
  "src::map.find": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::map.find(<array> keys)",
    "standard": true,
    "importNames": [
      "src::data.equals"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let equals;\n    \n                    let var_init_locked_1608956297473;\n    \n                    \n\n                    function main(keys){\n\n        \n/**\n * \n * 判断指定组合键是否存在\n * \n * @import equals from data.equals\n * \n * @param {array} keys 组合键\n * \n * @return {object} 返回查询结果 \n * \n */\n\nlet me = this,\n{\n    map\n} = me,\ncurrentKeys = map.keys(),\n{\n    length\n} = keys;\n\nfor(let groupKeys  of currentKeys){\n\n   if(length === groupKeys.length){\n\n       let isMatch = true ;\n\n       for(let i = 0 ; i < length ; i ++){\n\n           if(!equals(groupKeys[i] ,  keys[i])){\n\n               isMatch = false ;\n\n               break ;\n           }\n       }\n\n       if(isMatch){\n\n           return {\n               match:true,\n               key:groupKeys\n           } ;\n       }\n   }\n}\n\nreturn {\n    match:false\n} ;\n\n    }\n    \n                    return function(keys){\n    \n                        \n        if(!var_init_locked_1608956297473){\n\n            equals = include('src::data.equals');\n\n            var_init_locked_1608956297473 = true ;\n        }\n        \n    \n                        return main.call(this , keys) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.find"
  },
  "src::map.set": {
    "meta": "code.meta.script.function",
    "signature": "<Map> src::map.set(<array> ...values)",
    "standard": true,
    "importNames": [
      "src::map.find"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956297464 = new Map();\n    \n                    return function(...values){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956297464.has(this)){\n\n            var_current_scope_1608956297464.set(this , (() => {\n                const find = include('src::map.find').bind(this);\n\n                function main(...values){\n\n        \n/**\n * \n * 设置一个值\n * \n * @import find from .find scoped\n * \n * @param {array} [...values] 包含多维键，以及相应值\n * \n * @return {Map} 返回当前对象 \n * \n */\n\n let me = this,\n {\n    map\n } = me,\n {\n     length\n } = values;\n\n if(length >= 2){\n\n    let keys = values.slice(0 , length - 1),\n        value = values[length - 1],\n        {\n            match,\n            key\n        } = find(keys);\n\n    if(match){\n\n        map.set(key ,value) ;\n    \n    }else{\n\n        map.set(keys , value) ;\n    }\n }\n\n return me ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297464.get(this) ;\n\n        \n    \n                        return main.call(this , ...values) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.set"
  },
  "src::map.get": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::map.get(<array> ...keys)",
    "standard": true,
    "importNames": [
      "src::map.find"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956297479 = new Map();\n    \n                    return function(...keys){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956297479.has(this)){\n\n            var_current_scope_1608956297479.set(this , (() => {\n                const find = include('src::map.find').bind(this);\n\n                function main(...keys){\n\n        \n/**\n * \n * 判断指定组合键是否存在\n * \n * @import find from .find scoped\n * \n * @param {array} [...keys] 组合键\n * \n * @return {boolean} 如果组合键存在，则返回 true , 否则返回 false \n * \n */\n\nlet me = this,\n{\n    map\n} = me ;\n\nlet {\n    match,\n    key\n} = find(keys) ;\n\nif(match){\n\n    return map.get(key) ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297479.get(this) ;\n\n        \n    \n                        return main.call(this , ...keys) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.get"
  },
  "src::map.has": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::map.has(<array> ...keys)",
    "standard": true,
    "importNames": [
      "src::map.find"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956297483 = new Map();\n    \n                    return function(...keys){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956297483.has(this)){\n\n            var_current_scope_1608956297483.set(this , (() => {\n                const find = include('src::map.find').bind(this);\n\n                function main(...keys){\n\n        \n/**\n * \n * 判断指定组合键是否存在\n * \n * @import find from .find scoped\n * \n * @param {array} [...keys] 组合键\n * \n * @return {boolean} 如果组合键存在，则返回 true , 否则返回 false \n * \n */\n\n let {\n    match\n } = find(keys) ;\n\n return match ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297483.get(this) ;\n\n        \n    \n                        return main.call(this , ...keys) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.has"
  },
  "src::map.delete": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::map.delete(<array> ...keys)",
    "standard": true,
    "importNames": [
      "src::map.find"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956297487 = new Map();\n    \n                    return function(...keys){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956297487.has(this)){\n\n            var_current_scope_1608956297487.set(this , (() => {\n                const find = include('src::map.find').bind(this);\n\n                function main(...keys){\n\n        \n\n/**\n * \n * 删除指定组合键\n * \n * @import find from .find scoped\n * \n * @param {array} [...keys] 组合键\n * \n * @return {boolean} 如果组合键存在，则返回 true , 否则返回 false \n * \n */\n\nlet me = this,\n{\n    map\n} = me ;\n\nlet {\n    match,\n    key\n} = find(keys) ;\n\nif(match){\n\n    return map.delete(key) ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297487.get(this) ;\n\n        \n    \n                        return main.call(this , ...keys) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.delete"
  },
  "src::map.for": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::map.for(<function> fn)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(fn){\n\n        \n/**\n * \n * 循环\n * \n * @param {function} fn \n * \n */\n\n let {\n    map\n } = this ;\n\n map.forEach(fn) ;\n\n    }\n    \n                    return function(fn){\n    \n                        \n    \n                        return main.call(this , fn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.for"
  },
  "src::map.clear": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::map.clear()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 清空\n * \n */\n\n this.map.clear() ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.clear"
  },
  "src::is.defined": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.defined(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判断给定数据是否定义\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果数据定义则返回 true , 否则返回 false\n * \n */\n\nreturn data !== undefined ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.defined"
  },
  "src::map.find.fuzzy": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::map.find.fuzzy(<array> ...keys)",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956297498;\n    \n                    \n\n                    function main(...keys){\n\n        \n/**\n * \n * 以模糊寻找方式匹配键值\n * \n * @import is.defined\n * \n * @param {array} [...keys] 匹配键值\n * \n * @return {array} 搜索结果 \n * \n */\n\nlet me = this,\n{\n    map\n} = me,\ncurrentKeys = map.keys(),\n{\n    length\n} = keys,\nresult = [];\n\nfor(let groupKeys  of currentKeys){\n\n    let isMatch = true ;\n\n    for(let i = 0 ; i < length ; i ++){\n\n        let key = keys[i] ;\n\n        if(!isDefined(key)){\n\n            continue ;\n        }\n\n        if(groupKeys[i] !== key){\n\n            isMatch = false ;\n\n            break ;\n        }\n    }\n\n    if(isMatch){\n\n        result.push({\n            key:groupKeys,\n            value:map.get(groupKeys)\n        }) ;\n    }\n}\n\nreturn result ;\n\n    }\n    \n                    return function(...keys){\n    \n                        \n        if(!var_init_locked_1608956297498){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956297498 = true ;\n        }\n        \n    \n                        return main.call(this , ...keys) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map.find.fuzzy"
  },
  "src::map": {
    "meta": "code.meta.class",
    "signature": "<void> src::map()",
    "standard": true,
    "importNames": [
      "src::class.empty",
      "src::map.constructor",
      "src::map.size",
      "src::map.set",
      "src::map.get",
      "src::map.has",
      "src::map.delete",
      "src::map.for",
      "src::map.clear",
      "src::map.find.fuzzy",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let extend,constructor,get_size,method_set,method_get,method_has,method_delete,method_forEach,method_clear,method_find,isObject;\n    \n                    let var_init_locked_1608956297446;\n    \n                    let var_class_1608956297446;\n    \n                    \n\n                    let var_global_main_1608956297446 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297446){\n\n            extend = include('src::class.empty')();\nconstructor = include('src::map.constructor');\nget_size = include('src::map.size');\nmethod_set = include('src::map.set');\nmethod_get = include('src::map.get');\nmethod_has = include('src::map.has');\nmethod_delete = include('src::map.delete');\nmethod_forEach = include('src::map.for');\nmethod_clear = include('src::map.clear');\nmethod_find = include('src::map.find.fuzzy');\nisObject = include('src::is.object.simple');\n\n            class main {\n\n            \n\n            \n\n            constructor(...args){\n\n            \n\n            constructor.apply(this , args) ;\n\n        }\n\n            set(...args){\n\n            return method_set.apply(this , args) ;\n\n        }\nget(...args){\n\n            return method_get.apply(this , args) ;\n\n        }\nhas(...args){\n\n            return method_has.apply(this , args) ;\n\n        }\ndelete(...args){\n\n            return method_delete.apply(this , args) ;\n\n        }\nforEach(...args){\n\n            return method_forEach.apply(this , args) ;\n\n        }\nclear(...args){\n\n            return method_clear.apply(this , args) ;\n\n        }\nfind(...args){\n\n            return method_find.apply(this , args) ;\n\n        }\n\n            get size(){\n\n                return get_size.call(this) ;\n    \n            }\n\n        }\n\n            var_class_1608956297446 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297446 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::map' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297446 ;\n        \nvar_global_main_1608956297446 = main;\n\n            var_init_locked_1608956297446 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956297446() ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "map"
  },
  "src::event.listeners": {
    "meta": "code.meta.script.function",
    "signature": "<Map> src::event.listeners()",
    "standard": true,
    "importNames": [
      "src::map"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let map;\n    \n                    let var_init_locked_1608956297430;\n    \n                    let var_once_value_1608956297430;\n\n                    function main(){\n\n        \n/**\n * \n * 维护全局事件监听对象\n * \n * @import map value\n * \n * @return {Map} 集合对象 \n * \n * @once\n * \n */\n\nreturn map ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297430){\n\n            map = include('src::map')();\n\n            var_init_locked_1608956297430 = true ;\n        }\n        \n    \n                        \n        if(var_once_value_1608956297430){\n\n            return var_once_value_1608956297430 ;\n\n        }\n        return var_once_value_1608956297430 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "event.listeners"
  },
  "src::event.listener.native.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::event.listener.native.remove(<mixed> target , <string> name , <function> fn , <object> options)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(target , name , fn , options){\n\n        \n/**\n * \n * 适配事件主体对象的移除事件的方法\n * \n * @param {mixed} target 事件主体\n * \n * @param {string} name 事件名称\n * \n * @param {function} fn 事件监听函数\n * \n * @param {object} [options] 事件监听函数配置\n * \n */\n\n if(target.removeEventListener){\n\n    target.removeEventListener(name , fn , options) ;\n \n }else{\n\n    const remove = target.off || target.un;\n\n    remove.call(target , name , fn) ;\n }\n\n\n\n    }\n    \n                    return function(target , name , fn , options){\n    \n                        \n    \n                        return main.call(this , target , name , fn , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "event.listener.native.remove"
  },
  "src::event.listener.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::event.listener.remove(<mixed> target , <string|object|array> name , <mixed> fn , <mixed> scope)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.object.simple",
      "src::is.array",
      "src::event.listener.remove",
      "src::event.listeners",
      "src::event.listener.native.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isObject,isArray,remove,listeners,native;\n    \n                    let var_init_locked_1608956297426;\n    \n                    \n\n                    function main(target , name , fn , scope){\n\n        /**\n * \n * 移除事件监听\n * \n * @import is.string\n * \n * @import isObject from is.object.simple\n * \n * @import is.array\n * \n * @import remove from .remove\n * \n * @import listeners from ..listeners value\n * \n * @import native from .native.remove\n * \n * @param {mixed} target 事件主体\n * \n * @param {string|object|array} name 事件名称\n * \n * @param {mixed} fn 事件回调\n * \n * @param {mixed} [scope] 事件作用域\n * \n */\n\n scope = scope || target ;\n\n if(isString(name)){\n\n    if(fn){\n\n        let listener = listeners.get(target , name , fn , scope) ;\n\n        if(listener){\n\n            let {\n                fn:listenersFn,\n                options\n            } = listener ;\n\n            native(target , name , listenersFn , options) ;\n\n            listeners.delete(target , name , fn , scope) ;\n        }\n    \n    }else{\n\n        let result = listeners.find(target , name) ;\n\n        for(let {\n            key\n        } of result){\n\n            remove(target , name , key[2] , key[3]) ;\n        }\n    }\n \n }else if(isObject(name)){\n\n    let {\n        scope,\n        ...listeners\n    } = name,\n    names = Object.keys(listeners);\n\n    for(let name of names){\n\n        remove(target , name , listeners[name] , scope) ;\n    }\n\n }else if(isArray(name)){\n\n    let names = name ;\n\n    for(let name of names){\n\n        remove(target , name) ;\n    }\n }\n\n    }\n    \n                    return function(target , name , fn , scope){\n    \n                        \n        if(!var_init_locked_1608956297426){\n\n            isString = include('src::is.string');\nisObject = include('src::is.object.simple');\nisArray = include('src::is.array');\nremove = include('src::event.listener.remove');\nlisteners = include('src::event.listeners')();\nnative = include('src::event.listener.native.remove');\n\n            var_init_locked_1608956297426 = true ;\n        }\n        \n    \n                        return main.call(this , target , name , fn , scope) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "event.listener.remove"
  },
  "src::function.empty": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::function.empty()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    /**\n * \n * 返回一个空函数\n * \n * @scoped\n * \n */\n\nconst emptyFn = () =>{\n} ;\n\nfunction main(){\n\n    return emptyFn ;\n}\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "function.empty"
  },
  "src::function.get": {
    "meta": "code.meta.script.function",
    "signature": "<function> src::function.get(<string|function> fn , <mixed> scope)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.function",
      "src::function.empty"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isFunction,empty;\n    \n                    let var_init_locked_1608956297512;\n    \n                    \n\n                    function main(fn , scope){\n\n        /**\n * \n * 获得一个函数引用\n * \n * @import is.string\n * \n * @import is.function\n * \n * @import empty from function.empty\n * \n * @param {string | function} fn 函数描述\n * \n * @param {mixed} [scope] 函数作用域\n * \n * @return {function} 函数引用本身 \n * \n */\n\nif(isString(fn)){\n\n    if(scope && fn in scope){\n\n        fn = scope[fn] ;\n\n    }else{\n\n        try{\n\n            fn = include(fn) ;\n        \n        }catch(err){\n\n\n        }\n\n        \n    }\n}\n\nif(isFunction(fn)){\n\n    if(scope){\n\n        return fn.bind(scope) ;\n    }\n\n    return fn ;\n}\n\nreturn empty() ;\n\n    }\n    \n                    return function(fn , scope){\n    \n                        \n        if(!var_init_locked_1608956297512){\n\n            isString = include('src::is.string');\nisFunction = include('src::is.function');\nempty = include('src::function.empty');\n\n            var_init_locked_1608956297512 = true ;\n        }\n        \n    \n                        return main.call(this , fn , scope) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "function.get"
  },
  "src::event.listener.native.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::event.listener.native.add(<mixed> target , <string> name , <function> fn , <object> options)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(target , name , fn , options){\n\n        \n/**\n * \n * 适配事件主体对象的添加事件的方法\n * \n * @param {mixed} target 事件主体\n * \n * @param {string} name 事件名称\n * \n * @param {function} fn 事件监听函数\n * \n * @param {object} [options] 事件参数\n * \n */\n\n if(target.addEventListener){\n\n    target.addEventListener(name , fn , options) ;\n \n }else{\n\n    target.on(name , fn) ;\n }\n\n    }\n    \n                    return function(target , name , fn , options){\n    \n                        \n    \n                        return main.call(this , target , name , fn , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "event.listener.native.add"
  },
  "src::event.listener.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::event.listener.add(<mixed> target , <string|object> name , <mixed> fn , {<boolean> once , <object> options , <mixed> scope})",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.object.simple",
      "src::event.listener.add",
      "src::event.listener.remove",
      "src::function.get",
      "src::event.listeners",
      "src::event.listener.native.add",
      "src::is.array"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isObject,add,remove,get,listeners,native,isArray;\n    \n                    let var_init_locked_1608956297408;\n    \n                    \n\n                    function main(target , name , fn , {once , options , scope}){\n\n        /**\n * \n * 添加事件监听\n * \n * @import is.string\n * \n * @import isObject from is.object.simple\n * \n * @import add from .add\n * \n * @import remove from .remove\n * \n * @import get from function.get\n * \n * @import listeners from ..listeners value\n * \n * @import native from .native.add\n * \n * @import is.array\n * \n * @param {mixed} target 事件主体\n * \n * @param {string|object} name 事件名称\n * \n * @param {mixed} fn 事件回调\n * \n * @param {object} [options = {}] 事件配置\n * \n * @param {boolean} [options.once = false] 只监听一次\n * \n * @param {object} [options.options] 浏览器事件监听所需要参数\n * \n * @param {mixed} [options.scope] 事件作用域\n * \n */\n\n scope = scope || target ;\n\n if(isString(name)){\n\n    if(listeners.has(target , name , fn , scope)){\n\n        return ;\n    }\n\n    let listener,\n        listenerFn = get(fn , scope) ;\n\n    if(listenerFn){\n\n        if(once){\n\n            listener = function(...args){\n\n                listenerFn(...args) ;\n\n                remove(target , name , fn , {\n                    scope\n                }) ;\n            } ;\n        \n        }else{\n\n            listener = listenerFn ;\n        }\n\n        native(target , name , listener , options) ;\n\n        listeners.set(target , name , fn , scope , {\n            fn:listener,\n            options\n        }) ;\n    }\n\n }else if(isObject(name)){\n\n    let {\n        scope,\n        ...listeners\n    } = name,\n    names = Object.keys(listeners) ;\n\n    for(let name of names){\n\n        let listener = listeners[name];\n\n        if(isObject(listener)){\n\n            let {\n                fn,\n                ...options\n            } = listener ;\n\n            options.scope = options.scope || scope ;\n\n            add(target , name , fn , options) ;\n        \n        }else{\n\n            add(target , name , listeners[name] , {\n                scope\n            }) ;\n        }        \n    }\n\n }else if(isArray(name)){\n\n    for(let config of name){\n\n        add(target , config) ;\n    }\n }\n\n    }\n    \n                    return function(target , name , fn , {once = false , options , scope} = {}){\n    \n                        \n        if(!var_init_locked_1608956297408){\n\n            isString = include('src::is.string');\nisObject = include('src::is.object.simple');\nadd = include('src::event.listener.add');\nremove = include('src::event.listener.remove');\nget = include('src::function.get');\nlisteners = include('src::event.listeners')();\nnative = include('src::event.listener.native.add');\nisArray = include('src::is.array');\n\n            var_init_locked_1608956297408 = true ;\n        }\n        \n    \n                        return main.call(this , target , name , fn , {once , options , scope}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "event.listener.add"
  },
  "src::object.proxy": {
    "meta": "code.meta.script.function",
    "signature": "<object.Proxy> src::object.proxy(<mixed> target , <mixed> interceptor)",
    "standard": true,
    "importNames": [
      "src::event.listener.add",
      "src::event.listener.remove",
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let add,remove,isFunction;\n    \n                    let var_init_locked_1608956297391;\n    \n                    \n\n                    \n/**\n * \n * 对象代理，如果对象没有需要的方法或者属性时，则会抛出异常\n * \n * @import add from event.listener.add\n * \n * @import remove from event.listener.remove\n * \n * @import is.function\n * \n * @param {mixed} target 需要代理的对象\n * \n * @param {mixed} [interceptor = {}] 需要代理的对象\n * \n * @return {object.Proxy} 代理对象引用 \n * \n */\n\n function main(target , interceptor){\n\n    return new Proxy(target , interceptor) ;\n }\n\n class Proxy{\n\n    constructor(target , interceptor){\n\n        let me = this ;\n\n        me.target = target ;\n\n        me.interceptor = interceptor ;\n    }\n\n    call(method , ...args){\n\n        return call.call(this , true , method , ...args) ;\n    }\n\n    callIf(method , ...args){\n\n        return call.call(this , false , method , ...args) ;\n    }\n\n    set(name , value){\n\n        set.call(this , true , name , value) ;\n    }\n\n    setIf(name , value){\n\n        set.call(this , false , name , value) ;\n    }\n\n    get(name){\n\n        return get.call(this , true , name) ;\n    }\n\n    getIf(name){\n\n        return get.call(this , false , name) ;\n    }\n\n    fireEvent(name , ...args){\n\n        this.callIf('fireEvent' , name , ...args) ;\n    }\n\n    on(...args){\n\n        add(this.target , ...args) ;\n    }\n\n    off(...args){\n\n        remove(this.target , ...args) ;\n    }\n }\n\n function call(isThrowError , method , ...args){\n\n    let me = this,\n        {\n            target\n        } = me ;\n\n    if(method in target){\n\n        if(doIntercept.call(me , method , ...args)){\n\n            return ;\n        }\n\n        return target[method](...args) ;\n    \n    }else if(isThrowError){\n\n        throw new ProxyMethodNotFoundError(target , method) ;\n    }\n }\n\n function set(isThrowError , name , value){\n\n    let {\n        target\n    } = this ;\n\n    if(name in target){\n\n        if(doIntercept.call(me , name , value)){\n\n            return ;\n        }\n\n        target[name] = value ;\n    \n    }else if(isThrowError){\n\n        throw new ProxyPropertyNotFoundError(target , name , 'set') ;\n    }\n }\n\n function get(isThrowError , name){\n\n    let {\n        target\n    } = this ;\n\n    if(name in target){\n\n        return target[name] ;\n    \n    }else if(isThrowError){\n\n        throw new ProxyPropertyNotFoundError(target , name , 'get') ;\n    }\n }\n\n function doIntercept(method , ...args){\n\n    let {\n        target,\n        interceptor\n    } = this ;\n\n    if(isFunction(interceptor)){\n\n        return interceptor(target , method , ...args) === false;\n    }\n\n    if(method in interceptor){\n\n        return interceptor[method](target , ...args) === false ;\n    }\n\n    return false ;\n }\n\n class ProxyMethodNotFoundError extends Error{\n\n    constructor(target , method){\n\n        super(`无法访问名称为 ${method} 的方法`) ;\n\n        let me = this ;\n\n        me.proxyTarget = target ;\n\n        me.proxyMethod = method ;\n\n    }\n }\n\n class ProxyPropertyNotFoundError extends Error{\n\n    constructor(target , property , mode){\n\n        let modeMessage ;\n\n        switch(mode){\n\n            case 'set':\n\n                modeMessage = '设置' ;\n\n                break ;\n\n            case 'get':\n\n                modeMessage = '获取' ;\n        }\n\n        super(`无法${modeMessage}名称为 ${property} 的属性`) ;\n\n        let me = this ;\n\n        me.proxyTarget = target ;\n\n        me.proxyProperty = property ;\n\n    }\n }\n    \n                    return function(target , interceptor = {}){\n    \n                        \n        if(!var_init_locked_1608956297391){\n\n            add = include('src::event.listener.add');\nremove = include('src::event.listener.remove');\nisFunction = include('src::is.function');\n\n            var_init_locked_1608956297391 = true ;\n        }\n        \n    \n                        return main.call(this , target , interceptor) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.proxy"
  },
  "src::array.remove.all": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::array.remove.all(<array> data , <mixed> item)",
    "standard": true,
    "importNames": [
      "src::array.remove.index",
      "src::array.indexOf"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let remove,indexOf;\n    \n                    let var_init_locked_1608956297523;\n    \n                    \n\n                    function main(data , item){\n\n        \n/**\n * \n * 在数组中去除所有指定项目\n * \n * @import remove from .index\n * \n * @import indexOf from ..indexOf\n * \n * @param {array} data 数组\n * \n * @param {mixed} item 项目\n * \n */\n\nwhile(true){\n\n    let index = indexOf(data , item) ;\n\n    if(index !== -1){\n\n        remove(data , index) ;\n    \n    }else{\n\n        break ;\n    }\n}\n\n    }\n    \n                    return function(data , item){\n    \n                        \n        if(!var_init_locked_1608956297523){\n\n            remove = include('src::array.remove.index');\nindexOf = include('src::array.indexOf');\n\n            var_init_locked_1608956297523 = true ;\n        }\n        \n    \n                        return main.call(this , data , item) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.remove.all"
  },
  "src::array.remove.index": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::array.remove.index(<array> data , <number> index)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , index){\n\n        \n/**\n * \n * 根据数组下标删除对应项\n * \n * @param {array} data 作用数组\n * \n * @param {number} index 数组项的下标\n * \n * @return {boolean} 如果删除成功则返回 true , 否则返回　false \n * \n */\n\nif(index >= 0 && index < data.length){\n\n    data.splice(index , 1) ;\n\n    return true ;\n}\n\nreturn false ;\n\n    }\n    \n                    return function(data , index){\n    \n                        \n    \n                        return main.call(this , data , index) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.remove.index"
  },
  "src::array.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::array.remove(<array> data , <mixed> ...items)",
    "standard": true,
    "importNames": [
      "src::array.remove.index",
      "src::array.indexOf"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let remove,indexOf;\n    \n                    let var_init_locked_1608956297535;\n    \n                    \n\n                    function main(data , ...items){\n\n        \n/**\n * \n * 在数组中去除项目\n * \n * @import remove from array.remove.index\n * \n * @import indexOf from array.indexOf\n * \n * @param {array} data 数组\n * \n * @param {mixed} [...items] 项目\n * \n */\n\n for(let item of items){\n\n    remove(data , indexOf(data , item)) ;\n }\n\n    }\n    \n                    return function(data , ...items){\n    \n                        \n        if(!var_init_locked_1608956297535){\n\n            remove = include('src::array.remove.index');\nindexOf = include('src::array.indexOf');\n\n            var_init_locked_1608956297535 = true ;\n        }\n        \n    \n                        return main.call(this , data , ...items) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "array.remove"
  },
  "src::data.channel.axios": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.channel.axios()",
    "standard": true,
    "importNames": [
      "src::data.channel",
      "src::event.listener.add",
      "src::event.listener.remove",
      "src::axios"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Channel,on,off,axios;\n    \n                    let var_init_locked_1613308339852;\n    \n                    let var_class_1613308339852;\n    \n                    \n\n                    let var_global_main_1613308339852 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1613308339852){\n\n            Channel = include('src::data.channel')();\non = include('src::event.listener.add');\noff = include('src::event.listener.remove');\naxios = include('src::axios');\n\n            \n/**\n * \n * 基于 axios 通用客户端单向数据通道\n * \n * @import Channel from data.channel value\n * \n * @import on from event.listener.add\n * \n * @import off from event.listener.remove\n * \n * @import axios\n * \n * @class\n * \n */\n\nclass main extends Channel{\n\n    constructor(receivers){\n\n        super(receivers) ;\n\n        let me = this ;\n\n        me.receiveConnected() ;\n\n        me.cancelTokens = {} ;\n    }\n\n    send(params){\n\n        return super.send(null , params) ;\n    }\n\n    processSendParams(params){\n\n        return params ;\n    }\n\n    processReceiveData(data){\n\n        return data ;\n    }\n\n    doSend({\n        type,\n        id,\n        params\n    }){\n\n        let me = this,\n        {\n            cancelTokens\n        } = me;\n\n        switch(type){\n\n            case 'send':\n\n                cancelTokens[id] = axios(me.processSendParams(params) , (isSuccess , data , response) => {\n\n                    if(isSuccess){\n\n                        me.receiveReplyValue({\n                            id,\n                            value:me.processReceiveData(data , response)\n                        }) ;\n                    \n                    }else{\n\n                        me.receiveError({\n                            id,\n                            error:data\n                        }) ;\n                    }\n\n                }) ;\n\n            break ;\n\n            case 'cancel-send':\n\n                if(cancelTokens.hasOwnProperty(id)){\n\n                    cancelTokens[id]() ;\n\n                    delete cancelTokens[id] ;\n                }\n        }\n    }\n\n\n}\n\n            var_class_1613308339852 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1613308339852 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.channel.axios' ;\n                }\n\n            } ;\n\n            main = var_class_1613308339852 ;\n        \nvar_global_main_1613308339852 = main;\n\n            var_init_locked_1613308339852 = true ;\n        }\n        \n    \n                        return var_global_main_1613308339852 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.channel.axios"
  },
  "src::id.zbee": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::id.zbee()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956297588;\n\n                    function main(){\n\n        \n/**\n * \n * ZBEE 标识\n * \n * @return {string} 标识 \n * \n * @once\n * \n */\n\n return `ZBEE${Date.now()}` ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956297588){\n\n            return var_once_value_1608956297588 ;\n\n        }\n        return var_once_value_1608956297588 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "id.zbee"
  },
  "src::object.property.inner.name": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::object.property.inner.name(<string> name)",
    "standard": true,
    "importNames": [
      "src::id.zbee"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let id;\n    \n                    let var_init_locked_1608956297586;\n    \n                    \n\n                    function main(name){\n\n        \n/**\n * \n * 返回属性内部名称\n * \n * @import id from id.zbee value\n * \n * @param {string} name 属性名称\n * \n * @return {string} 属性内部名称\n * \n */\n\n return `__${id}_OBJECT_INNER_PROPERTY_${name}__` ;\n\n    }\n    \n                    return function(name){\n    \n                        \n        if(!var_init_locked_1608956297586){\n\n            id = include('src::id.zbee')();\n\n            var_init_locked_1608956297586 = true ;\n        }\n        \n    \n                        return main.call(this , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.inner.name"
  },
  "src::object.property.inner.define": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.property.inner.define(<object> target , <string|object> name , <mixed> value)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.name",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let innerName,isObject;\n    \n                    let var_init_locked_1608956297582;\n    \n                    \n\n                    function main(target , name , value){\n\n        \n/**\n * \n * 定义内部属性\n * \n * @import innerName from .name\n * \n * @import isObject from is.object.simple\n * \n * @param {object} target  定义内部属性的宿主\n * \n * @param {string|object} name 内部属性名称\n * \n * @param {mixed} value 内部属性值\n * \n */\n\n if(isObject(name)){\n\n    let properties = name,\n        names = Object.keys(properties),\n        innerProperties = {};\n\n    for(let name of names){\n\n        innerProperties[innerName(name)] = {\n            value:properties[name],\n            configurable:true,\n            writable:true\n        }\n    }\n\n    Object.defineProperties(target , innerProperties) ;\n \n }else{\n\n    Object.defineProperty(target , innerName(name) , {\n        value,\n        configurable:true,\n        writable:true\n    }) ;\n }\n\n    }\n    \n                    return function(target , name , value){\n    \n                        \n        if(!var_init_locked_1608956297582){\n\n            innerName = include('src::object.property.inner.name');\nisObject = include('src::is.object.simple');\n\n            var_init_locked_1608956297582 = true ;\n        }\n        \n    \n                        return main.call(this , target , name , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.inner.define"
  },
  "src::mixin.observable.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mixin.observable.constructor(<object> options)",
    "standard": true,
    "importNames": [
      "src::event.listener.add",
      "src::is.object.simple",
      "src::is.array",
      "src::object.property.inner.define"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let add,isObject,isArray,define;\n    \n                    let var_init_locked_1608956297578;\n    \n                    \n\n                    \n/**\n * \n * 初始化观察者\n * \n * @import add from event.listener.add\n * \n * @import isObject from is.object.simple\n * \n * @import is.array\n * \n * @import define from object.property.inner.define\n * \n * @param {object} options 配置\n * \n */\n\nconst EventEmitter = require('events') ;\n\nfunction main({\n    listeners\n}){\n    \n    let me = this,\n        emitter = new EventEmitter() ;\n\n    emitter.setMaxListeners(Infinity) ;\n\n    define(me , {\n        emitter,\n        suspendEvents:false\n    }) ;\n\n    if(isObject(listeners) || isArray(listeners)){\n\n        add(me , listeners) ;\n\n    }\n\n    \n}\n\n\n    \n                    return function(options){\n    \n                        \n        if(!var_init_locked_1608956297578){\n\n            add = include('src::event.listener.add');\nisObject = include('src::is.object.simple');\nisArray = include('src::is.array');\ndefine = include('src::object.property.inner.define');\n\n            var_init_locked_1608956297578 = true ;\n        }\n        \n    \n                        return main.call(this , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable.constructor"
  },
  "src::object.property.inner.get": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::object.property.inner.get(<object> target , <string> name)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let innerName;\n    \n                    let var_init_locked_1608956297593;\n    \n                    \n\n                    function main(target , name){\n\n        \n/**\n * \n * 获取内部属性的值\n * \n * @import innerName from .name\n * \n * @param {object} target  定义内部属性的宿主\n * \n * @param {string} name 内部属性名称\n * \n * @return {mixed} 内部属性值\n * \n * \n */\n\n return target[innerName(name)] ;\n\n \n\n    }\n    \n                    return function(target , name){\n    \n                        \n        if(!var_init_locked_1608956297593){\n\n            innerName = include('src::object.property.inner.name');\n\n            var_init_locked_1608956297593 = true ;\n        }\n        \n    \n                        return main.call(this , target , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.inner.get"
  },
  "src::mixin.observable.listener.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mixin.observable.listener.add(<string> event , <mixed> fn)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956297591;\n    \n                    \n\n                    function main(event , fn){\n\n        \n/**\n * \n * 添加事件监听\n * \n * @import get from object.property.inner.get\n * \n * @param {string} event 事件名称\n * \n * @param {mixed} fn 事件回调函数\n * \n */\n\nget(this , 'emitter').addListener(event , fn) ;\n\n    }\n    \n                    return function(event , fn){\n    \n                        \n        if(!var_init_locked_1608956297591){\n\n            get = include('src::object.property.inner.get');\n\n            var_init_locked_1608956297591 = true ;\n        }\n        \n    \n                        return main.call(this , event , fn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable.listener.add"
  },
  "src::mixin.observable.listener.has": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mixin.observable.listener.has(<string> event)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956297596;\n    \n                    \n\n                    function main(event){\n\n        \n/**\n * \n * 判断是否拥有事件监听\n * \n * @import get from object.property.inner.get\n * \n * @param {string} event 事件\n * \n * @return {boolean} 如果拥有事件监则返回 true , 否则返回 false\n * \n */\n\nreturn get(this , 'emitter').listenerCount(event) !== 0;\n\n    }\n    \n                    return function(event){\n    \n                        \n        if(!var_init_locked_1608956297596){\n\n            get = include('src::object.property.inner.get');\n\n            var_init_locked_1608956297596 = true ;\n        }\n        \n    \n                        return main.call(this , event) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable.listener.has"
  },
  "src::mixin.observable.listener.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mixin.observable.listener.remove(<string> event , <function> fn)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956297598;\n    \n                    \n\n                    function main(event , fn){\n\n        \n/**\n * \n * 移除事件监听\n * \n * @import get from object.property.inner.get\n * \n * @param {string} event 事件名称\n * \n * @param {function} fn 事件回调函数\n * \n * \n */\n\nget(this , 'emitter').removeListener(event , fn) ;\n\n\n    }\n    \n                    return function(event , fn){\n    \n                        \n        if(!var_init_locked_1608956297598){\n\n            get = include('src::object.property.inner.get');\n\n            var_init_locked_1608956297598 = true ;\n        }\n        \n    \n                        return main.call(this , event , fn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable.listener.remove"
  },
  "src::mixin.observable.event.fire": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mixin.observable.event.fire(<string> event , <mixed> ...args)",
    "standard": true,
    "importNames": [
      "src::is.array",
      "src::object.property.inner.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isArray,get;\n    \n                    let var_init_locked_1608956297602;\n    \n                    \n\n                    \n/**\n *\n * 触发事件\n * \n * @import is.array\n * \n * @import get from object.property.inner.get\n *\n * @param {string} event 事件名称\n *\n * @param {mixed} [...args] 事件参数\n *\n */\n\n function main(event , ...args){\n\n    let me = this,\n        isSuspendEvents = get(me , 'suspendEvents');\n\n    if(isSuspendEvents === true || isArray(isSuspendEvents) && isSuspendEvents.includes(event)){\n\n        return ;\n    }\n\n    doFireBubbleEvent.call(me , event , me , ...args) ;\n }\n\n function doFireBubbleEvent(event , target , ...args){\n\n    let me = this;\n\n    get(me , 'emitter').emit(event , target ,  ...args) ;\n\n    let bubbleTarget = get(me , 'bubbleTarget') ;\n\n    if(bubbleTarget){\n\n        doFireBubbleEvent.call(bubbleTarget , event , target , ...args) ;\n    }\n }\n    \n                    return function(event , ...args){\n    \n                        \n        if(!var_init_locked_1608956297602){\n\n            isArray = include('src::is.array');\nget = include('src::object.property.inner.get');\n\n            var_init_locked_1608956297602 = true ;\n        }\n        \n    \n                        return main.call(this , event , ...args) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable.event.fire"
  },
  "src::object.property.inner.set": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.property.inner.set(<object> target , <string> name , <mixed> value)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let innerName;\n    \n                    let var_init_locked_1608956297608;\n    \n                    \n\n                    function main(target , name , value){\n\n        \n/**\n * \n * 设置内部属性的值\n * \n * @import innerName from .name\n * \n * @param {object} target  定义内部属性的宿主\n * \n * @param {string} name 内部属性名称\n * \n * @param {mixed} value 内部属性值\n * \n */\n\nreturn target[innerName(name)] = value;\n\n \n\n    }\n    \n                    return function(target , name , value){\n    \n                        \n        if(!var_init_locked_1608956297608){\n\n            innerName = include('src::object.property.inner.name');\n\n            var_init_locked_1608956297608 = true ;\n        }\n        \n    \n                        return main.call(this , target , name , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.inner.set"
  },
  "src::mixin.observable.events.suspend": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mixin.observable.events.suspend(<mixed> events)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.set"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let set;\n    \n                    let var_init_locked_1608956297605;\n    \n                    \n\n                    function main(events){\n\n        \n/**\n * \n * @import set from object.property.inner.set\n * \n * @param {mixed} [events = true] 需要暂停的事件名称\n * \n * 暂停事件监听\n * \n */\n\nset(this , 'suspendEvents' , events) ;\n\n    }\n    \n                    return function(events = true){\n    \n                        \n        if(!var_init_locked_1608956297605){\n\n            set = include('src::object.property.inner.set');\n\n            var_init_locked_1608956297605 = true ;\n        }\n        \n    \n                        return main.call(this , events) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable.events.suspend"
  },
  "src::mixin.observable.events.resume": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mixin.observable.events.resume()",
    "standard": true,
    "importNames": [
      "src::object.property.inner.set"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let set;\n    \n                    let var_init_locked_1608956297612;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * @import set from object.property.inner.set\n * \n * 恢复事件监听\n * \n */\n\n set(this , 'suspendEvents' , false) ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297612){\n\n            set = include('src::object.property.inner.set');\n\n            var_init_locked_1608956297612 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable.events.resume"
  },
  "src::mixin.observable.listeners.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mixin.observable.listeners.remove()",
    "standard": true,
    "importNames": [
      "src::object.property.inner.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956297614;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 清除所有事件监听\n * \n * @import get from object.property.inner.get\n * \n */\n\nget(this , 'emitter').removeAllListeners() ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297614){\n\n            get = include('src::object.property.inner.get');\n\n            var_init_locked_1608956297614 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable.listeners.remove"
  },
  "src::mixin.observable": {
    "meta": "code.meta.class",
    "signature": "<void> src::mixin.observable(<mixed> extend)",
    "standard": true,
    "importNames": [
      "src::mixin.observable.constructor",
      "src::mixin.observable.listener.add",
      "src::mixin.observable.listener.has",
      "src::mixin.observable.listener.remove",
      "src::mixin.observable.event.fire",
      "src::mixin.observable.events.suspend",
      "src::mixin.observable.events.resume",
      "src::mixin.observable.listeners.remove",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let constructor,method_addListener,method_hasListener,method_removeListener,method_fireEvent,method_suspendEvents,method_resumeEvents,method_removeAllListeners,isObject;\n    \n                    let var_init_locked_1608956297572;\n    \n                    \n\n                    function main(extend){\n\n                        return class extends extend{\n\n                            \n                \n                            \n                \n                            constructor(options){\n\n            super(options) ;\n\n            if(isObject(options)){\n\n                constructor.call(this , options) ;\n            \n            }else{\n\n                constructor.call(this , {}) ;\n            }\n\n        }\n                \n                            addListener(...args){\n\n            return method_addListener.apply(this , args) ;\n\n        }\non(...args){\n\n                return this.addListener(...args) ;\n    \n            }\nhasListener(...args){\n\n            return method_hasListener.apply(this , args) ;\n\n        }\nremoveListener(...args){\n\n            return method_removeListener.apply(this , args) ;\n\n        }\nun(...args){\n\n                return this.removeListener(...args) ;\n    \n            }\nfireEvent(...args){\n\n            return method_fireEvent.apply(this , args) ;\n\n        }\nsuspendEvents(...args){\n\n            return method_suspendEvents.apply(this , args) ;\n\n        }\nresumeEvents(...args){\n\n            return method_resumeEvents.apply(this , args) ;\n\n        }\nremoveAllListeners(...args){\n\n            return method_removeAllListeners.apply(this , args) ;\n\n        }\n                \n                            \n                \n                        }\n\n                }\n    \n                    return function(extend){\n    \n                        \n        if(!var_init_locked_1608956297572){\n\n            constructor = include('src::mixin.observable.constructor');\nmethod_addListener = include('src::mixin.observable.listener.add');\nmethod_hasListener = include('src::mixin.observable.listener.has');\nmethod_removeListener = include('src::mixin.observable.listener.remove');\nmethod_fireEvent = include('src::mixin.observable.event.fire');\nmethod_suspendEvents = include('src::mixin.observable.events.suspend');\nmethod_resumeEvents = include('src::mixin.observable.events.resume');\nmethod_removeAllListeners = include('src::mixin.observable.listeners.remove');\nisObject = include('src::is.object.simple');\n\n            var_init_locked_1608956297572 = true ;\n        }\n        \n    \n                        return main.call(this , extend) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mixin.observable"
  },
  "src::environment.name": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::environment.name()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956297622;\n\n                    function main(){\n\n        \n/**\n * \n * 检测当前环境，返回值有 browser、zbee、node\n * \n * @return {string} 环境名称 \n * \n * @once\n * \n */\n\nconst {\n    toString\n} = Object.prototype,\nBROWSER_NAMES = {\n    micromessenger: 'weixin-browser',\n    ue4:'ue4-browser',\n    unity: 'unity-browser',\n    electron:'electron-browser',\n    browser:'browser'\n};\n\nif(typeof window === 'object' && toString.call(window) === '[object Window]' && typeof document === 'object' && toString.call(document) === '[object HTMLDocument]'){\n    \n    return BROWSER_NAMES[(navigator.userAgent.toLowerCase().match(/micromessenger|ue4|unity|electron/) || ['browser'])[0]];\n\n}else if(typeof process === 'object' && typeof global === 'object' && typeof require === 'function'){\n\n    try{\n\n        let [\n            path\n        ] = process.argv ;\n\n        return /electron\\.exe$/.test(path) ;\n\n    }catch(err){\n\n    }\n\n    return 'node' ;\n}\n\nreturn 'other' ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956297622){\n\n            return var_once_value_1608956297622 ;\n\n        }\n        return var_once_value_1608956297622 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "environment.name"
  },
  "src::id.generate": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::id.generate(<string> prefix)",
    "standard": true,
    "importNames": [
      "src::environment.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956297617;\n    \n                    \n\n                    \n/**\n * \n * 生成唯一的编号\n * \n * @import getName from environment.name\n * \n * @param {string} prefix 编号前缀\n * \n * @return {string} 生成后的唯一编号\n * \n * @require uuid\n * \n */\n\n let count = 1 ; \n\n function main(prefix = 'zb-'){\n\n    return `${prefix}${count ++}` ;\n\n }\n    \n                    return function(prefix){\n    \n                        \n        if(!var_init_locked_1608956297617){\n\n            getName = include('src::environment.name');\n\n            var_init_locked_1608956297617 = true ;\n        }\n        \n    \n                        return main.call(this , prefix) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "id.generate"
  },
  "src::is.object": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.object(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isType;\n    \n                    let var_init_locked_1608956297625;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为对象类型\n * \n * @import is.type\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为对象类型则返回 true , 否则返回 false \n * \n */\n\nreturn typeof data === 'object' ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297625){\n\n            isType = include('src::is.type');\n\n            var_init_locked_1608956297625 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.object"
  },
  "src::data.channel": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.channel()",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::id.generate",
      "src::event.listener.add",
      "src::event.listener.remove",
      "src::is.object",
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Observable,generate,on,off,isObject,isFunction;\n    \n                    let var_init_locked_1613308339869;\n    \n                    let var_class_1613308339869;\n    \n                    \n\n                    let var_global_main_1613308339869 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1613308339869){\n\n            Observable = include('src::mixin.observable');\ngenerate = include('src::id.generate');\non = include('src::event.listener.add');\noff = include('src::event.listener.remove');\nisObject = include('src::is.object');\nisFunction = include('src::is.function');\n\n            \n/**\n * \n * 数据通信 \n * \n * @import Observable from mixin.observable\n * \n * @import generate from id.generate\n * \n * @import on from event.listener.add\n * \n * @import off from event.listener.remove\n * \n * @import is.object\n * \n * @import is.function\n * \n * @class\n * \n */\n\nclass main extends mixins({\n    mixins:[\n        Observable\n    ]\n}){\n\n    constructor(receivers = {}){\n\n        super() ;\n\n        let me = this ;\n\n        me.connected = false ;\n\n        me.receivers = receivers ;\n\n        me.connectState = 3 ;\n\n        me.cancelSendFunctions = {} ;\n    }\n\n    connect(){\n\n        let me = this,\n        {\n            connectState\n        } = me;\n\n        switch(connectState){\n\n            case 2:\n\n                on(me , 'disconnect' , () => me.connect() , {\n                    once:true\n                }) ;\n\n                break ;\n\n            case 3:\n\n                me.connectState = 0 ;\n\n                me.doConnect() ;\n        }\n    }\n\n    disconnect(){\n\n        let me = this,\n        {\n            connectState\n        } = me;\n\n        switch(connectState){\n\n            case 0:\n\n                on(me , 'connect' , () => me.disconnect() , {\n                    once:true\n                }) ;\n\n                break ;\n\n            case 1:\n\n                me.connectState = 2 ;\n\n                me.doDisconnect() ;\n        }\n    }\n\n    generateCallID(){\n\n        return generate(Date.now()) ;\n    }\n\n    receiveConnected(){\n\n        this.receiveConnectState(2) ;\n    }\n\n    receiveDisconnected(){\n\n        this.receiveConnectState(3) ;\n    }\n\n    receiveConnectState(state){\n\n        let me = this ;\n\n        me.connectState = state ;\n\n        switch(state){\n\n            case 2:\n\n                me.connected = true ;\n\n                me.fireEvent('connect') ;\n\n                break ;\n\n            case 3:\n\n                me.fireEvent('disconnect') ;\n        }\n\n    }\n\n    receiveData(data){\n\n        if(isObject(data)){\n\n            let {\n                type,\n                ...options\n            } = data,\n            me = this ;\n    \n            switch(type){\n    \n                case 'send':\n    \n                    me.receiveSendInstruction(options) ;\n    \n                    break ;\n    \n                case 'reply':\n    \n                    me.receiveReplyValue(options) ;\n\n                case 'cancel-send':\n\n                    me.receiveCancelSendData(options) ;\n            }\n        }\n    }\n\n    receiveCancelSendData({\n        id\n    }){\n\n        let {\n            cancelSendFunctions\n        } = this ;\n\n        if(cancelSendFunctions.hasOwnProperty(id)){\n\n            cancelSendFunctions[id]() ;\n\n            delete cancelSendFunctions[id] ;\n        }\n    }\n\n    async receiveSendInstruction({\n        id,\n        name,\n        params\n    }){\n\n        let me = this,\n        {\n            receivers,\n            cancelSendFunctions\n        } = me;\n\n        if(receivers.hasOwnProperty(name)){\n\n            let reply = value => me.reply(id , value),\n                result = receivers[name].call(me , params , reply) ;\n\n            if(isFunction(result)){\n\n                cancelSendFunctions[id] = result ;\n                \n            }else{\n\n                reply(await result) ;\n            }\n        }\n    }\n\n    receiveReplyValue({\n        id,\n        value\n    }){\n\n        this.fireEvent(id , value) ;\n    }\n\n    receiveError({\n        id,\n        error\n    }){\n\n        this.fireEvent(`${id}-error` , error) ;\n    }\n\n    reply(id , value){\n\n        this.doReply({\n            type:'reply',\n            id,\n            value\n        }) ;\n    }\n\n    cancelSend(id){\n\n        let me = this ;\n\n        me.doSend({\n            type:'cancel-send',\n            id\n        }) ;\n\n        off(me , id) ;\n    }\n\n    async send(name , params , callback){\n\n        let me = this,\n        {\n            connected\n        } = me ;\n\n        if(connected){\n\n            let id = me.generateCallID() ;\n\n            me.doSend({\n                type:'send',\n                id,\n                name,\n                params\n            }) ;\n\n            if(isFunction(callback)){\n\n                on(me , id , (channel , data) => callback.call(channel , data)) ;\n\n                return id ;\n            }\n\n            return await new Promise((resolve , reject) => {\n\n                let\n                onResolve = (channel , data) => {\n\n                    channel.cancelSend(id) ;\n                    \n                    off(me , `${id}-error` , onReject) ;\n    \n                    resolve(data) ;\n    \n                },\n                onReject = (channel , error) => {\n\n                    channel.cancelSend(id) ;\n\n                    off(me , id , onResolve) ;\n\n                    reject(error) ;\n\n                };\n\n                on(me , id , onResolve , {\n                    once:true\n                }) ;\n\n                on(me , `${id}-error` , onReject , {\n                    once:true\n                }) ;\n\n            }) ;\n\n        }\n\n        return await new Promise(resolve => on(me , 'connect' , async () => resolve(await me.send(name , params , callback)) , {\n            once:true\n        })) ;\n    }\n\n    doSend(data){\n\n\n    }\n\n    doReply(data){\n\n\n    }\n\n    doConnect(){\n\n\n    }\n\n    doDisconnect(){\n\n    }\n}\n\n            var_class_1613308339869 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1613308339869 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.channel' ;\n                }\n\n            } ;\n\n            main = var_class_1613308339869 ;\n        \nvar_global_main_1613308339869 = main;\n\n            var_init_locked_1613308339869 = true ;\n        }\n        \n    \n                        return var_global_main_1613308339869 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.channel"
  },
  "src::axios": {
    "meta": "code.meta.script.function",
    "signature": "<function> src::axios(<object> params , <function> callback)",
    "standard": true,
    "importNames": [
      "src::array.from",
      "src::id.generate",
      "src::is.function",
      "src::is.string"
    ],
    "dependentModules": {
      "axios": "^0.18.0"
    },
    "data": "(() =>{\n\n                    let from,generate,isFunction,isString;\n    \n                    let var_init_locked_1608956297630;\n    \n                    \n\n                    \n/**\n * \n * 基于 axios 的再封装\n * \n * @import from from array.from\n * \n * @import generate from id.generate\n * \n * @import is.function\n * \n * @import is.string\n * \n * @param {object} params 请求参数\n * \n * @param {function} [callback] 请求回调\n * \n * @return {function} 取消请求函数  \n * \n * @require axios\n * \n * @require fs\n * \n */\n\n const \n axios = require('axios'),\n {\n    stringify\n } = require('qs'),\n CancelToken = axios.CancelToken;\n\n function main(params , callback){\n\n    if(isFunction(callback)){\n\n        let source = CancelToken.source() ;\n\n        axios({\n            ...processParams(params),\n            cancelToken: source.token\n        })\n            .then(response => callback(true , response.data , response))\n            .catch(error => {\n\n                if(!axios.isCancel(error)){\n\n                    callback(false , error.message , error) ;\n                }\n\n            });\n\n        return () => source.cancel() ;\n    }\n\n    return new Promise((resolve , reject) => axios(processParams(params))\n                .then(({\n                    data\n                }) => resolve(data))\n                .catch(error => reject(error))) ;\n }\n\n function processMethod(method){\n\n    if(isString(method)){\n\n        return method.toUpperCase() ;\n    }\n\n    return 'GET' ;\n }\n\n function processParams({\n     form = false,\n     params,\n     files,\n     ...options\n }){\n\n    options.method = processMethod(options.method) ;\n\n    if(form && options.method !== 'GET'){\n\n       return processForm(options , params) ;\n    }\n\n    if(files){\n\n        return processUpload(options , from(files)) ;\n    }\n\n    return {\n        params,\n        ...options\n    } ;\n }\n\n function processForm(options , params){\n\n    return {\n        ...options,\n        data:stringify(params)\n    } ;\n }\n\n function processUpload(options , files){\n\n    let data = new FormData() ;\n\n    for(let file of files){\n\n        data.append(generate('file-') , file) ;\n    }\n\n    options.method = 'POST' ;\n\n    return {\n        ...options,\n        data\n    } ;\n }\n    \n                    return function(params , callback){\n    \n                        \n        if(!var_init_locked_1608956297630){\n\n            from = include('src::array.from');\ngenerate = include('src::id.generate');\nisFunction = include('src::is.function');\nisString = include('src::is.string');\n\n            var_init_locked_1608956297630 = true ;\n        }\n        \n    \n                        return main.call(this , params , callback) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "axios"
  },
  "src::data.channel.client.axios": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.channel.client.axios()",
    "standard": true,
    "importNames": [
      "src::data.channel.client"
    ],
    "dependentModules": {
      "axios": "^0.18.0"
    },
    "data": "(() =>{\n\n                    let Channel;\n    \n                    let var_init_locked_1608956297634;\n    \n                    let var_class_1608956297634;\n    \n                    \n\n                    let var_global_main_1608956297634 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297634){\n\n            Channel = include('src::data.channel.client')();\n\n            \n/**\n * \n * 基于 Axios 数据通道客户端实现\n * \n * @import Channel from ..client value\n * \n * @require axios\n * \n * @class\n * \n */\n\nconst axios = require('axios');\n\nclass main extends Channel{\n\n    doSend(params , fireDataEvent , fireErrorEvent){\n        \n        axios(params)\n            .then(({\n                data\n            }) => fireDataEvent(data))\n            .catch(({\n                status,\n                data\n            }) => fireErrorEvent({\n                status,\n                data\n            }));\n    }\n\n    processSendParams(params){\n\n        return params ;\n    }\n\n    processReceiveData(data){\n\n        return data ;\n    }\n}\n\n            var_class_1608956297634 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297634 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.channel.client.axios' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297634 ;\n        \nvar_global_main_1608956297634 = main;\n\n            var_init_locked_1608956297634 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297634 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.channel.client.axios"
  },
  "src::data.channel.client": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.channel.client()",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::is.defined",
      "src::event.listener.add",
      "src::event.listener.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Observable,isDefined,on,off;\n    \n                    let var_init_locked_1608956297640;\n    \n                    let var_class_1608956297640;\n    \n                    \n\n                    let var_global_main_1608956297640 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297640){\n\n            Observable = include('src::mixin.observable');\nisDefined = include('src::is.defined');\non = include('src::event.listener.add');\noff = include('src::event.listener.remove');\n\n            \n/**\n * \n * 数据通道客户端基本实现\n * \n * @import Observable from mixin.observable\n * \n * @import is.defined\n * \n * @import on from event.listener.add\n * \n * @import off from event.listener.remove\n * \n * @class\n * \n */\n\n class main extends mixins({\n    mixins:[\n        Observable\n    ]\n}){\n\n    getEventNameBySendParams(params){\n\n        return JSON.stringify(params) ;\n    }\n\n    getEventNameByReceiveParams(){\n        \n    }\n\n    processSendParams(params){\n\n        return params ;\n    }\n\n    processReceiveData(){\n\n        return {} ;\n    }\n\n    send(params , isReturnData = false){\n\n        let me = this,\n            eventName = me.getEventNameBySendParams(params),\n            dataEvent = eventName,\n            errorEvent = `${eventName}-error`,\n            fireDataEvent = (...params) => {\n\n                let receiveData = me.processReceiveData(...params) ;\n\n                let receiveDataEvent = me.getEventNameByReceiveParams(receiveData) ;\n\n                if(isDefined(receiveDataEvent) && receiveDataEvent !== dataEvent){\n\n                    return ;\n                }\n\n                me.fireEvent(dataEvent , receiveData) ;\n\n            },\n            fireErrorEvent = data => me.fireEvent(errorEvent , data);\n\n        params = me.processSendParams(params) ;\n\n        if(isReturnData){\n\n            return new Promise((resolve , reject) => {\n\n                let listeners = {\n                    [dataEvent](client , data){\n\n                        off(me , listeners) ;\n                    \n                        resolve(data) ;\n                    },\n                    [errorEvent](client , data){\n\n                        off(me , listeners) ;\n\n                        reject(data) ;\n                    }\n                } ;\n\n                on(me , listeners) ;\n\n                me.doSend(params , fireDataEvent , fireErrorEvent) ;\n\n            }) ;\n        }\n\n        me.doSend(params , fireDataEvent , fireErrorEvent) ;\n    }\n\n    doSend(){\n\n\n    }\n\n }\n\n            var_class_1608956297640 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297640 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.channel.client' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297640 ;\n        \nvar_global_main_1608956297640 = main;\n\n            var_init_locked_1608956297640 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297640 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.channel.client"
  },
  "src::data.channel.client.socket.io": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.channel.client.socket.io()",
    "standard": true,
    "importNames": [
      "src::data.channel.client",
      "src::mixin.observable",
      "src::socket.io",
      "src::event.listener.add",
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Channel,Observable,createSocket,add,from;\n    \n                    let var_init_locked_1608956297645;\n    \n                    let var_class_1608956297645;\n    \n                    \n\n                    let var_global_main_1608956297645 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297645){\n\n            Channel = include('src::data.channel.client')();\nObservable = include('src::mixin.observable');\ncreateSocket = include('src::socket.io');\nadd = include('src::event.listener.add');\nfrom = include('src::array.from');\n\n            \n/**\n * \n * 基于 Socket.io 数据通道客户端实现\n * \n * @import Channel from ....client value\n * \n * @import Observable from mixin.observable\n * \n * @import createSocket from socket.io\n * \n * @import add from event.listener.add\n * \n * @import from from array.from\n * \n * @class\n * \n */\n\n\nclass main extends Channel{\n\n    doSend({\n        event,\n        params,\n        ...options\n    } , fireDataEvent , fireErrorEvent){\n\n        getSocket.call(this , {\n            ...options,\n            fireDataEvent,\n            fireErrorEvent\n        }).emit(event , ...from(params)) ;\n    }\n}\n\nconst sockets = new Map() ;\n\nfunction getSocket({\n    url,\n    path = '/socket.io',\n    fireDataEvent,\n    fireErrorEvent,\n    ...options\n}){\n\n    let key = `${url}:${path}` ;\n\n    if(!sockets.has(key)){\n\n        let socket = createSocket({\n            url,\n            path,\n            ...options\n        });\n\n        add(socket , {\n            data(client , ...params){\n\n                fireDataEvent(...params) ;\n\n            },\n            connect_error:fireErrorEvent\n        });\n\n        sockets.set(key , socket) ;\n    }\n\n    return sockets.get(key) ;\n}\n\n            var_class_1608956297645 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297645 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.channel.client.socket.io' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297645 ;\n        \nvar_global_main_1608956297645 = main;\n\n            var_init_locked_1608956297645 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297645 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.channel.client.socket.io"
  },
  "src::socket.parser": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::socket.parser()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956297672;\n\n                    function main(){\n\n        /**\n * \n * 修复 socket.io 解析器无法连接的问题\n * \n * @once\n * \n */\n\nconst {\n    Encoder,\n    BINARY_EVENT,\n    BINARY_ACK,\n    ERROR\n} = require('socket.io-parser') ;\n\nfunction stringify(data){\n\n    try{\n\n    return JSON.stringify(data);\n    \n    }catch(e){\n    \n    }\n\n    return false;\n}\n\nconst {\n    encode\n} = Encoder.prototype ;\n\nEncoder.prototype.encode = function(obj, callback){\n\n    let {\n        type\n    } = obj ;\n\n    switch(type){\n\n        case BINARY_EVENT:\n        case BINARY_ACK:\n\n        encode.call(this , obj , callback) ;\n\n        break ;\n\n        default:\n\n            callback([\n            encodeAsString(obj)\n            ]);\n    }\n};\n  \nfunction encodeAsString(obj) {\n\n    let {\n        type,\n        nsp,\n        id,\n        data,\n        attachments\n        } = obj ;\n\n    let str = `${type}`;\n\n    switch(type){\n\n        case BINARY_EVENT:\n        case BINARY_ACK:\n\n        str += attachments + '-';\n    }\n\n    if (nsp && '/' !== nsp) {\n\n        str += `${nsp}`;\n\n    }\n\n    if(id || data){\n\n        str += ',' ;\n    }\n\n    if (null != id) {\n        \n        str += id;\n\n    }\n\n    if (null != data) {\n\n        let payload = stringify(data);\n        \n        if (payload !== false) {\n\n        str += payload;\n        \n        }else{\n        \n        return `${ERROR}\"encode error\"`;\n        }\n    }\n\n    return str;\n}\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956297672){\n\n            return var_once_value_1608956297672 ;\n\n        }\n        return var_once_value_1608956297672 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "socket.parser"
  },
  "src::socket.io": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::socket.io(<object> options)",
    "standard": true,
    "importNames": [
      "src::event.listener.add",
      "src::event.listener.remove",
      "src::environment.name",
      "src::mixin.observable",
      "src::socket.parser",
      "src::is.defined",
      "src::is.number",
      "src::is.object.simple"
    ],
    "dependentModules": {
      "socket.io-client": "2.3.0"
    },
    "data": "(() =>{\n\n                    let add,remove,environment,Observable,socketParser,isDefined,isNumber,isObject;\n    \n                    let var_init_locked_1608956297660;\n    \n                    let var_class_1608956297660;\n    \n                    \n\n                    let var_global_main_1608956297660 ;\n    \n                    return function(options){\n    \n                        \n        if(!var_init_locked_1608956297660){\n\n            add = include('src::event.listener.add');\nremove = include('src::event.listener.remove');\nenvironment = include('src::environment.name')();\nObservable = include('src::mixin.observable');\nsocketParser = include('src::socket.parser')();\nisDefined = include('src::is.defined');\nisNumber = include('src::is.number');\nisObject = include('src::is.object.simple');\n\n            \n/**\n * \n * 针对 Socket.io 再封装\n * \n * @import add from event.listener.add\n * \n * @import remove from event.listener.remove\n * \n * @import environment from environment.name value\n * \n * @import Observable from mixin.observable\n * \n * @import .parser value\n * \n * @import is.defined\n * \n * @import is.number\n * \n * @import isObject from is.object.simple\n * \n * @param {object} options Socket.io 配置\n * \n * @require socket.io-client\n * \n */\n\n const IO = require('socket.io-client') ;\n\n const browserRe = /browser$/ ;\n\n class main extends mixins({\n     mixins:[\n        Observable\n     ]\n }){\n\n    constructor({\n        url,\n        path,\n        dataEventName = 'data',\n        reconnection = true\n    }){\n\n        super() ;\n\n        let me = this ;\n\n        me.dataEventName = dataEventName ;\n        \n        me.reconnectionMax = Number.MAX_VALUE ;\n\n        if(isDefined(reconnection)){\n\n            if(reconnection === true){\n\n                me.reconnectionDelay = 1000 ;\n            \n            }else if(isNumber(reconnection)){\n\n                me.reconnectionDelay = reconnection ;\n            \n            }else if(isObject(reconnection)){\n\n                let {\n                    delay = 1000,\n                    max = 5000 \n                } = reconnection ;\n\n                me.reconnectionDelay = delay ;\n\n                me.reconnectionMax = max ;\n            }\n        }\n\n        me.url = url ;\n\n        me.path = path ;\n\n        me.state = 3 ;\n\n        me.connect() ;\n\n        if(browserRe.test(environment)){\n\n            add(window , {\n                offline:'onOffline',\n                online:'onOnline',\n                visibilitychange:'onVisibilityChange',\n                scope:me\n            }) ;\n        }\n    }\n\n    onOnline(){\n\n        this.connect() ;\n    }\n\n    onOffline(){\n\n        this.disconnect() ;\n    }\n\n    onVisibilityChange(){\n\n        let me = this ;\n\n        if(document.visibilityState){\n\n            me.connect() ;\n        \n        }else{\n\n            me.disconnect() ;\n        }\n    }\n\n    isDisconnected(){\n\n        return this.state === 3 ;\n    }\n\n    isConnected(){\n\n        return this.state === 1 ;\n    }\n\n    isConnecting(){\n\n        return this.state = 0 ;\n    }\n\n    isDisconnecting(){\n\n        return this.state === 2 ;\n    }\n\n    async connect(){\n\n        let me = this ;\n\n        if(me.isConnected()){\n\n            return ;\n        }\n\n        if(me.isDisconnected()){\n\n            me.state = 0 ;\n\n            createSocket.call(me) ;\n\n            return await (me.transitionState = new Promise(callback => add(me , 'connect' , () => callback() , {\n                once:true\n            }))) ;\n\n        }\n\n        await me.transitionState ;\n\n        if(me.isDisconnected()){\n\n            await me.connect() ;\n        }\n    }\n\n    async disconnect(){\n\n        let me = this ;\n\n        if(me.isDisconnected()){\n\n            return ;\n        }\n\n        if(me.isConnected()){\n\n            me.state = 2 ;\n\n            me.socket.disconnect() ;\n\n            return await (me.transitionState =  new Promise(callback => add(me , 'disconnect' , () => callback() , {\n                once:true\n            }))) ;\n        }\n\n        await me.transitionState ;\n\n        if(me.isConnected()){\n\n            await me.disconnect() ;\n        }\n    }\n\n    onConnect(){\n\n        let me = this ;\n\n        me.state = 1 ;\n        \n        delete me.transitionState ;\n\n        me.fireEvent('connect') ;\n    }\n\n    onDisconnect(){\n\n        let me = this,\n        {\n            state:oldState\n        } = me;\n\n        me.state = 3 ;\n\n        delete me.transitionState ;\n\n        if(oldState === 2){\n\n            me.fireEvent('disconnect') ;\n        \n        }else{\n\n            me.autoReconnect() ;\n        }\n    }\n\n    autoReconnect(){\n\n        let me = this,\n        {\n            reconnectionCount = 0,\n            reconnectionMax,\n            reconnectionDelay\n        } = me;\n\n        if(!isDefined(reconnectionDelay)){\n\n            me.fireEvent('connect_error') ;\n\n            return ;\n        }\n\n        reconnectionCount ++ ;\n\n        if(reconnectionCount > reconnectionMax){\n\n            delete me.reconnectionCount ;\n\n            me.fireEvent('connect_error') ;\n\n        }else{\n\n            me.reconnectionCount = reconnectionCount ;\n\n            setTimeout(() => {\n\n                me.connect() ;\n\n                me.fireEvent('reconnecting' , reconnectionCount) ;\n\n            } , reconnectionDelay) ;\n        }\n    }\n\n    onData(...params){\n\n        this.fireEvent('data' , ...params) ;\n    }\n\n    onError(){\n\n        let me = this,\n        {\n            state\n        } = me ;\n\n        if(state === 0){\n\n            me.onDisconnect() ;\n        }\n    }\n\n    async emit(event , ...params){\n\n        let me = this,\n        {\n            socket\n        } = me;\n\n        if(me.isConnected()){\n    \n            socket.emit(event , ...params) ;\n        \n        }else{\n\n            await me.connect() ;\n\n            me.emit(event , ...params) ;\n        }\n    }\n }\n\n function createSocket(){\n\n    let me = this,\n    {\n        url,\n        path,\n        socket,\n        dataEventName\n    } = me ;\n\n    if(socket){\n\n        remove(socket , {\n            connect:'onConnect',\n            disconnect:'onDisconnect',\n            connect_error:'onError',\n            scope:me\n        }) ;\n    }\n\n    add(me.socket = IO(url , {\n        path,\n        forceNew: true,\n        transports: [\n            'websocket'\n        ],\n        reconnection:false\n    }) , {\n        connect:'onConnect',\n        disconnect:'onDisconnect',\n        connect_error:'onError',\n        [dataEventName]:'onData',\n        scope:me\n    }) ;\n }\n\n            var_class_1608956297660 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297660 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::socket.io' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297660 ;\n        \nvar_global_main_1608956297660 = main;\n\n            var_init_locked_1608956297660 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956297660(options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "socket.io"
  },
  "src::data.channel.message.client": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.channel.message.client()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.channel.message.client"
  },
  "src::data.channel.message.server": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.channel.message.server()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.channel.message.server"
  },
  "src::data.channel.window": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.channel.window()",
    "standard": true,
    "importNames": [
      "src::data.channel",
      "src::event.listener.add",
      "src::event.listener.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Channel,on,off;\n    \n                    let var_init_locked_1613308339886;\n    \n                    let var_class_1613308339886;\n    \n                    \n\n                    let var_global_main_1613308339886 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1613308339886){\n\n            Channel = include('src::data.channel')();\non = include('src::event.listener.add');\noff = include('src::event.listener.remove');\n\n            \n/**\n * \n * 窗口之间的数据通道\n * \n * @import Channel from data.channel value\n * \n * @import on from event.listener.add\n * \n * @import off from event.listener.remove\n * \n * @class\n * \n */\n\nclass main extends Channel{\n\n    constructor(name , target , receivers){\n\n        super(receivers) ;\n\n        let me = this;\n\n        on(window , 'message' , ({\n            data,\n            ports\n        }) => {\n\n            let {\n                receivePort\n            } = me ;\n\n            if(data === `${name}-connect` && !receivePort){\n\n                let port = ports[0] ;\n\n                port.onmessage = ({\n                    data\n                }) => me.receiveData(data) ;\n\n                port.postMessage(`${name}-connected`) ;\n\n                me.receivePort = port ;\n\n                me.connect() ;\n            \n            }else if(data === `${name}-disconnect` && receivePort){\n\n                let {\n                    receivePort\n                } = me ;\n\n                receivePort.postMessage(`${name}-disconnected`) ;\n\n                receivePort.close() ;\n\n                delete me.receivePort ;\n\n                me.disconnect() ;\n\n            }\n        }) ;\n\n        me.target = target ;\n\n        me.name = name ;\n    }\n\n    doConnect(){\n\n        let me = this,\n        {\n            name,\n            target\n        } = me,\n        {\n            port1,\n            port2\n        } = new MessageChannel();\n\n        port1.onmessage = ({\n            data\n        }) => {\n\n            if(data === `${name}-connected`){\n\n                me.receiveConnected() ;\n            \n            }else if(data === `${name}-disconnected`){\n\n                me.sendPort.close() ;\n\n                delete me.sendPort ;\n\n                me.receiveDisconnected() ;\n\n            }else{\n\n                me.receiveData(data) ;\n            }\n        } ;\n\n        me.sendPort = port1 ;\n\n        target.postMessage(`${name}-connect` , '*' , [\n            port2\n        ]) ;\n    }\n\n    doDisconnect(){\n\n        let {\n            name,\n            target\n        } = this ;\n\n       target.postMessage(`${name}-disconnect` , '*') ;\n    }\n\n    doSend(data){\n\n        this.sendPort.postMessage(data) ;\n    }\n\n    doReply(data){\n\n        this.receivePort.postMessage(data) ;\n    }\n}\n\n            var_class_1613308339886 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1613308339886 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.channel.window' ;\n                }\n\n            } ;\n\n            main = var_class_1613308339886 ;\n        \nvar_global_main_1613308339886 = main;\n\n            var_init_locked_1613308339886 = true ;\n        }\n        \n    \n                        return var_global_main_1613308339886 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.channel.window"
  },
  "src::data.connection.accept": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.connection.accept(<mixed> ...args)",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956297690;\n    \n                    \n\n                    function main(...args){\n\n        \n/**\n * \n * 接收消息数据\n * \n * @import is.defined\n * \n * @param {mixed} [...args] 可选参数\n * \n * @return {object} 消息体 \n * \n */\n\nlet me = this,\n    message = me.processMessage(...args),\n    {\n        subscribers,\n        matchOnlyOnce\n    } = me ;\n\nif(isDefined(message)){\n\n    subscribers = subscribers.values() ;\n\n    for(let subscriber of subscribers){\n\n        if(!subscriber.closed && me.validateMessage(subscriber , message)){\n\n            let processedData = me.processData(subscriber , message) ;\n\n            if(isDefined(processedData)){\n\n                subscriber.accept(processedData) ;\n\n                if(matchOnlyOnce){\n\n                    break ;\n                }\n            }\n\n           \n            \n        }\n    }\n        \n}\n\n    }\n    \n                    return function(...args){\n    \n                        \n        if(!var_init_locked_1608956297690){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956297690 = true ;\n        }\n        \n    \n                        return main.call(this , ...args) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.accept"
  },
  "src::data.connection.activate": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.activate()",
    "standard": true,
    "importNames": [
      "src::array.includes"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let includes;\n    \n                    let var_init_locked_1608956297693;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 激活\n * \n * @import includes from array.includes\n * \n */\n\nlet me = this,\n{\n    subscribeParamList\n} = me;\n\nfor(let params of subscribeParamList){\n\n    me.doSubscriberOpen(...params) ;\n}\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297693){\n\n            includes = include('src::array.includes');\n\n            var_init_locked_1608956297693 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.activate"
  },
  "src::data.connection.ajax.request.browser": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.ajax.request.browser(<string> url , <object> config)",
    "standard": true,
    "importNames": [
      "src::data.connection.ajax.request"
    ],
    "dependentModules": {
      "axios": "^0.18.0",
      "qs": "^6.7.0"
    },
    "data": "(() =>{\n\n                    let request;\n    \n                    let var_init_locked_1608956297698;\n    \n                    \n\n                    function main(url , config){\n\n        \n/**\n * \n * 基于浏览器的 AJAX 请求实现\n * \n * @import request from ..request\n * \n * @require axios\n * \n * @require qs\n * \n * @param {string} url 请求路径\n * \n * @param {object} [config] 请求配置\n * \n */\n\nlet {\n    url:requestURL,\n    method,\n    data,\n    form,\n    responseHeaders\n} = request(url , config);\n\nconst axios = require('axios'),\n{\n    stringify\n} = require('qs');\n\n\nif(form === true){\n\n    data = stringify(data) ;\n}\n\nlet result = axios[method.toLowerCase()](requestURL , data) ;\n\nif(responseHeaders){\n\n    return result.then(({\n        data,\n        headers\n    }) => {\n        data,\n        headers\n    }) ;\n}\n\nreturn result.then(({\n    data\n}) => data) ;\n\n    }\n    \n                    return function(url , config){\n    \n                        \n        if(!var_init_locked_1608956297698){\n\n            request = include('src::data.connection.ajax.request');\n\n            var_init_locked_1608956297698 = true ;\n        }\n        \n    \n                        return main.call(this , url , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.ajax.request.browser"
  },
  "src::url.append": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::url.append(<string> url , <mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.string"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString;\n    \n                    let var_init_locked_1608956297710;\n    \n                    \n\n                    function main(url , data){\n\n        \n/**\n * \n * 基于已有链接附加查询信息\n * \n * @import is.string\n * \n * @param {string} url 链接\n * \n * @param {mixed} data 附加查询信息\n * \n * @return {mixed} 拼接了查询信息的链接 \n * \n */\n\nlet querystring ;\n\nif(isString(data)){\n\n    querystring = data ;\n\n}else{\n\n    querystring = [];\n\n    let names = Object.keys(data) ;\n\n    for(let name of names){\n\n        querystring.push(`${name}=${encodeURIComponent(data[name])}`) ;\n    }\n\n    querystring = querystring.join('&') ;\n\n}\n\nif(querystring){\n\n    if(url.includes('?')){\n\n        return `${url}&${querystring}` ;\n    }\n    \n    return `${url}?${querystring}` ;\n\n}\n\nreturn url ;\n\n\n    }\n    \n                    return function(url , data){\n    \n                        \n        if(!var_init_locked_1608956297710){\n\n            isString = include('src::is.string');\n\n            var_init_locked_1608956297710 = true ;\n        }\n        \n    \n                        return main.call(this , url , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "url.append"
  },
  "src::regexp.int": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::regexp.int(<string> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 匹配整数\n * \n * @param {string} data 参数说明\n * \n * @return {boolean} 如果匹配成功则返回 true , 否则返回 false \n * \n */\n\nreturn /^\\d+$/.test(data) ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "regexp.int"
  },
  "src::url.template.apply": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::url.template.apply(<string> url , <object> data)",
    "standard": true,
    "importNames": [
      "src::regexp.int"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isInt;\n    \n                    let var_init_locked_1608956297713;\n    \n                    \n\n                    function main(url , data){\n\n        \n/**\n * \n * 路径模板应用\n * \n * @import isInt from regexp.int\n * \n * @param {string} url 带有参数定义的URL\n * \n * @param {object} data 模板参数定义数据集合\n * \n * @return {string} 应用数据后的URL链接\n * \n */\n\nreturn url.replace(/\\:(\\w+)/g , (match , name) =>{\n\n    if(isInt(name)){\n\n        return `:${name}` ;\n    }\n\n    return data[name] || '' ;\n\n}) ;\n\n\n    }\n    \n                    return function(url , data){\n    \n                        \n        if(!var_init_locked_1608956297713){\n\n            isInt = include('src::regexp.int');\n\n            var_init_locked_1608956297713 = true ;\n        }\n        \n    \n                        return main.call(this , url , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "url.template.apply"
  },
  "src::data.connection.ajax.request": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.ajax.request(<string> url , {<string> method , <object> query , <object> params , <object> path , <boolean> requestJSON , <boolean> responseHeaders})",
    "standard": true,
    "importNames": [
      "src::url.append",
      "src::url.template.apply",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let append,apply,isObject;\n    \n                    let var_init_locked_1608956297701;\n    \n                    \n\n                    function main(url , {method , query , params , path , requestJSON , responseHeaders}){\n\n        \n/**\n * \n * 基于 AJAX 进行数据交互\n * \n * @import append from url.append\n * \n * @import apply from url.template.apply\n * \n * @import isObject from is.object.simple\n * \n * @param {string} url 请求路径\n * \n * @param {object} [config] 请求配置\n * \n * @param {string} [config.method = 'GET'] 请求方式，默认是 GET 请求\n * \n * @param {object} [config.query] GET请求的参数集合\n * \n * @param {object} [config.params = {}] 请求主体的参数集合\n * \n * @param {object} [config.path] 以路径参数形式提交的参数集合\n * \n * @param {boolean} [config.requestJSON = true] 是否以 JSON方式提交数据\n * \n * @param {boolean} [config.responseHeaders = false] 是否返回头部信息\n * \n */\n\nif(query){\n\n    url = append(url , query) ;\n}\n\nif(path){\n\n    url = apply(url , path) ;\n}\n\nlet form = false ;\n\nmethod = method.toUpperCase() ;\n\nswitch(method){\n\n    case 'GET':\n    case 'DELETE':\n\n        url = append(url , params) ;\n\n        break ;\n\n    case 'POST':\n    case 'PUT':\n\n        if(requestJSON === false){\n\n            form = true ;\n        }\n}\n\nreturn {\n    url,\n    method,\n    data:params,\n    form,\n    responseHeaders\n} ;\n\n    }\n    \n                    return function(url , {method = 'GET' , query , params = {} , path , requestJSON = true , responseHeaders = false}){\n    \n                        \n        if(!var_init_locked_1608956297701){\n\n            append = include('src::url.append');\napply = include('src::url.template.apply');\nisObject = include('src::is.object.simple');\n\n            var_init_locked_1608956297701 = true ;\n        }\n        \n    \n                        return main.call(this , url , {method , query , params , path , requestJSON , responseHeaders}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.ajax.request"
  },
  "src::data.connection.ajax.request.miniprogram": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.ajax.request.miniprogram(<string> url , <object> config)",
    "standard": true,
    "importNames": [
      "src::data.connection.ajax.request"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let request;\n    \n                    let var_init_locked_1608956297720;\n    \n                    \n\n                    function main(url , config){\n\n        \n/**\n * \n * 基于小程序的 AJAX 请求实现\n * \n * @import request from ..request\n * \n * @param {string} url 请求路径\n * \n * @param {object} [config] 请求配置\n * \n */\n\nlet {\n    url:requestURL,\n    method,\n    data,\n    form,\n    responseHeaders\n} = request(url , config),\nheader = {};\n\nif(form === true){\n\n    header['content-type'] = 'application/x-www-form-urlencoded' ;\n}\n\nreturn new Promise(callback =>{\n\n    wx.request({\n        header,\n        url:requestURL,\n        method,\n        data,\n        success({\n            data,\n            header\n        }){\n    \n            if(responseHeaders){\n\n                callback({\n                    data,\n                    header\n                }) ;\n            \n            }else{\n\n                callback(data) ;\n            }\n        }\n    }) ;\n\n}) ;\n\n\n\n\n    }\n    \n                    return function(url , config){\n    \n                        \n        if(!var_init_locked_1608956297720){\n\n            request = include('src::data.connection.ajax.request');\n\n            var_init_locked_1608956297720 = true ;\n        }\n        \n    \n                        return main.call(this , url , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.ajax.request.miniprogram"
  },
  "src::data.connection.ajax": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.ajax(<object> options)",
    "standard": true,
    "importNames": [
      "src::data.connection"
    ],
    "dependentModules": {
      "url-join": "^4.0.0"
    },
    "data": "(() =>{\n\n                    let Connection;\n    \n                    let var_init_locked_1608956297723;\n    \n                    let var_class_1608956297723;\n    \n                    \n\n                    let var_global_main_1608956297723 ;\n    \n                    return function(options){\n    \n                        \n        if(!var_init_locked_1608956297723){\n\n            Connection = include('src::data.connection')();\n\n            \n/**\n * \n * 基于 AJAX 进行数据交互\n * \n * @import Connection from data.connection value\n * \n * @require url-join\n * \n * @param {object}  options 配置\n * \n */\n\n const join = require('url-join') ;\n\n class main extends Connection{\n\n    constructor({\n        ajax\n    }){\n\n        super() ;\n\n        let me = this,\n        {\n            url:ajaxURL,\n            request\n        } = ajax ;\n\n        me.ajaxURL = ajaxURL ;\n\n        me.request = request ;\n    }\n\n    processSubscribeParams(subscriber , params){\n\n        let {\n            ajaxURL\n        } = this ;\n\n        return [\n            join(ajaxURL , subscriber.name),\n            params\n        ] ;\n    }\n\n    validateMessage(subscriber , {\n        subscriber:messageSubscriber\n    }){\n\n        return subscriber === messageSubscriber ;\n    }\n\n    processMessage(subscriber , data){\n\n        return {\n            subscriber,\n            data\n        } ;\n    }\n\n    async doSubscriberOpen(subscriber , url , params){\n\n        this.acceptMessage(subscriber , await request(url , params)) ;\n\n    }\n }\n\n\n            var_class_1608956297723 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297723 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.ajax' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297723 ;\n        \nvar_global_main_1608956297723 = main;\n\n            var_init_locked_1608956297723 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956297723(options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.ajax"
  },
  "src::data.subscriber.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.subscriber.constructor(<data.connection> connection , <string> name , {<string> fullName , <function> processData , <object> listeners , <mixed> params , <boolean> autoOpen , <object> extraParams , <object> defaultParams , <function> fn , <boolean> once , <mixed> scope , <string> namespace , <function> processAcceptData , <function> cacheAcceptData , <function> getCacheData})",
    "standard": true,
    "importNames": [
      "src::function.get",
      "src::event.listener.add",
      "src::function.empty",
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,add,emptyFn,from;\n    \n                    let var_init_locked_1608956297745;\n    \n                    \n\n                    function main(connection , name , {fullName , processData , listeners , params , autoOpen , extraParams , defaultParams , fn , once , scope , namespace , processAcceptData , cacheAcceptData , getCacheData}){\n\n        /**\n * \n * 初始化订阅器\n * \n * @import get from function.get\n * \n * @import add from event.listener.add\n * \n * @import emptyFn from function.empty value\n * \n * @import from from array.from\n * \n * @param {data.connection} connection 当前订阅器所在的连接对象\n * \n * @param {string} name 订阅名称\n * \n * @param {object} config 订阅器配置\n * \n * @param {string} config.fullName 订阅器全称\n * \n * @param {function} [config.processData] 处理数据方法\n *  \n * @param {object} [config.listeners = {}] 来自古地外部事件监听\n * \n * @param {mixed} [config.params] 默认打开的订阅参数\n * \n * @param {boolean} [config.autoOpen = true] 是否自动打开订阅器\n * \n * @param {object} [config.extraParams = {}] 附加参数\n * \n * @param {object} [config.defaultParams = {}] 默认参数\n * \n * @param {function} config.fn 订阅函数\n * \n * @param {boolean} [config.once = false] 仅订阅一次即取消\n * \n * @param {mixed} [config.scope] 订阅函数作用域\n * \n * @param {string} [config.namespace] 命名空间\n * \n * @param {function} [config.processAcceptData] 处理接收数据的方法\n * \n * @param {function} [config.cacheAcceptData] 缓存接收数据方法\n * \n * @param {function} [config.getCacheData] 获取缓存数据 \n * \n */\n\n\nlet me = this ;\n\nme.name = name ;\n\nme.fullName = fullName ;\n\nme.connection = connection ;\n\nme.$bubbleTarget = connection ;\n\nme.processData = processData || (({\n    data\n}) => data) ;\n\nme.cacheAcceptData = cacheAcceptData ||  emptyFn;\n\nme.processAcceptData = processAcceptData || (data => data) ;\n\nme.getCacheData = getCacheData || (data => data) ;\n\nme.extraParams = extraParams ;\n\nme.defaultParams = defaultParams ;\n\nme.bindFn = get(fn , scope) || emptyFn;\n\nadd(me , {\n    ...listeners,\n    scope\n}) ;\n\nif(autoOpen){\n\n    me.open(params) ;\n}\n\nif(once === true){\n\n    add(me , 'data' , () => connection.unsubscribe(name , namespace) , {\n        once:true\n    }) ;\n}\n\n\n    }\n    \n                    return function(connection , name , {fullName , processData , listeners = {} , params , autoOpen = true , extraParams = {} , defaultParams = {} , fn , once = false , scope , namespace , processAcceptData , cacheAcceptData , getCacheData}){\n    \n                        \n        if(!var_init_locked_1608956297745){\n\n            get = include('src::function.get');\nadd = include('src::event.listener.add');\nemptyFn = include('src::function.empty')();\nfrom = include('src::array.from');\n\n            var_init_locked_1608956297745 = true ;\n        }\n        \n    \n                        return main.call(this , connection , name , {fullName , processData , listeners , params , autoOpen , extraParams , defaultParams , fn , once , scope , namespace , processAcceptData , cacheAcceptData , getCacheData}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.constructor"
  },
  "src::data.subscriber.closed": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::data.subscriber.closed()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 返回当前订阅器的关闭状态\n * \n * @return {boolean} 返回 true 则表示为关闭，返回 false 则表示为打开\n * \n */\n\n return !this.hasOwnProperty('params') ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.closed"
  },
  "src::data.subscriber.open.prev": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.subscriber.open.prev()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 打开之前的订阅\n * \n */\n\nlet me = this,\n{\n    closed,\n    prevParams\n} = me ;\n\nif(closed){\n\n    me.open(prevParams) ;\n}\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.open.prev"
  },
  "src::data.subscriber.accept.data": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::data.subscriber.accept.data(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956297760;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 将推送数据传递给绑定函数\n * \n * @import is.defined\n * \n * @param {mixed} data 推送过来的数据\n * \n * @return {mixed} 返回说明 \n * \n */\n\n let me = this,\n {\n    bindFn,\n    closed,\n    params,\n    cache,\n    getCacheData\n } = me ;\n\n if(!closed){\n\n   if(isDefined(cache)){\n\n      bindFn(getCacheData(cache) , params) ;\n   \n   }else{\n\n      bindFn(data , params) ;\n   }\n\n   me.fireEvent('data' , data , params) ;\n }\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297760){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956297760 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.accept.data"
  },
  "src::data.subscriber.accept": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.subscriber.accept(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.defined",
      "src::data.subscriber.accept.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956297757;\n \n                    \n\n                    const var_current_scope_1608956297757 = new Map();\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297757){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956297757 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956297757.has(this)){\n\n            var_current_scope_1608956297757.set(this , (() => {\n                const setData = include('src::data.subscriber.accept.data').bind(this);\n\n                function main(data){\n\n        \n/**\n * \n * 接收数据\n * \n * @import is.defined\n * \n * @import setData from .accept.data scoped\n * \n * @param {mixed} data 数据\n * \n * \n */\n\nlet me = this,\n{\n    closed,\n    cache,\n    processAcceptData,\n    cacheAcceptData\n} = me;\n\nif(closed){\n\n    return;\n}\n\ndata = processAcceptData(data) ;\n\nif(isDefined(data)){\n\n    me.cache = cacheAcceptData(data , cache) ;\n\n    setData(data) ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297757.get(this) ;\n\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.accept"
  },
  "src::data.subscriber.reopen": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.subscriber.reopen()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 重新打开订阅器\n * \n */\n\nlet me = this,\n{\n    closed,\n    params\n} = me ;\n\nif(!closed){\n\n    me.close() ;\n\n    me.open(params) ;\n}\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.reopen"
  },
  "src::data.subscriber.open": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.subscriber.open(<object> params)",
    "standard": true,
    "importNames": [
      "src::is.defined",
      "src::data.equals",
      "src::object.assign",
      "src::data.subscriber.accept.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined,equals,assign;\n    \n                    let var_init_locked_1608956297767;\n \n                    \n\n                    const var_current_scope_1608956297767 = new Map();\n    \n                    return function(params = {}){\n    \n                        \n        if(!var_init_locked_1608956297767){\n\n            isDefined = include('src::is.defined');\nequals = include('src::data.equals');\nassign = include('src::object.assign');\n\n            var_init_locked_1608956297767 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956297767.has(this)){\n\n            var_current_scope_1608956297767.set(this , (() => {\n                const setData = include('src::data.subscriber.accept.data').bind(this);\n\n                function main(params){\n\n        \n/**\n * \n * 打开订阅器\n * \n * @import is.defined\n * \n * @import equals from data.equals\n * \n * @import assign from object.assign\n * \n * @import setData from .accept.data scoped\n * \n * @param {object} [params = {}] 订阅参数\n * \n */\n\nlet me = this,\n{\n    name,\n    extraParams,\n    defaultParams,\n    params:oldParams,\n    connection\n} = me ;\n\nparams = assign({} , defaultParams , params , extraParams) ;\n\nif(!oldParams || !equals(params , oldParams)){\n\n    me.close() ;\n\n    me.params = params ;\n    \n    me.fireEvent('open' , params , oldParams) ;\n\n    let subscriber = connection.findOpenedSubscriberByName(name , me) ;\n\n    if(subscriber){\n\n        let {\n            cache\n        } = subscriber ;\n\n        if(isDefined(cache)){\n\n            me.cache = cahce ;\n\n            setData() ;\n        }\n    }\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297767.get(this) ;\n\n        \n    \n                        return main.call(this , params) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.open"
  },
  "src::data.subscriber.close": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.subscriber.close()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 关闭订阅器\n * \n */\n\nlet me = this,\n{\n    params,\n    closed\n} = me;\n\nif(closed){\n\n    return ;\n}\n\nme.prevParams = me.params ;\n\ndelete me.params ;\n\ndelete me.cache ;\n\nme.fireEvent('close' , params) ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.close"
  },
  "src::event.listener.remove.all": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::event.listener.remove.all(<mixed> target)",
    "standard": true,
    "importNames": [
      "src::event.listeners",
      "src::event.listener.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let listeners,remove;\n    \n                    let var_init_locked_1608956297776;\n    \n                    \n\n                    function main(target){\n\n        \n/**\n * \n * 去除所有事件监听\n * \n * @import listeners from ....listeners value\n * \n * @import remove from ..remove\n * \n * @param {mixed} target 事件主体\n * \n */\n\n let result = listeners.find(target) ;\n\n for(let {\n     key\n } of result){\n\n    remove(target , key[1] , key[2] , key[3]) ;\n }\n\n    }\n    \n                    return function(target){\n    \n                        \n        if(!var_init_locked_1608956297776){\n\n            listeners = include('src::event.listeners')();\nremove = include('src::event.listener.remove');\n\n            var_init_locked_1608956297776 = true ;\n        }\n        \n    \n                        return main.call(this , target) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "event.listener.remove.all"
  },
  "src::data.subscriber.destroy": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.subscriber.destroy()",
    "standard": true,
    "importNames": [
      "src::event.listener.remove.all"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let removeAll;\n    \n                    let var_init_locked_1608956297773;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 销毁\n * \n * @import removeAll from event.listener.remove.all\n * \n */\n\nlet me = this,\n{\n    connection\n} = me;\n\nme.close() ;\n\ndelete me.bindFn ;\n\ndelete me.extraParams ;\n\ndelete me.defaultParams ;\n\nme.fireEvent('destroy') ;\n\nremoveAll(me) ;\n\nconnection.subscribers.delete(me.fullName) ;\n\ndelete me.fullName ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297773){\n\n            removeAll = include('src::event.listener.remove.all');\n\n            var_init_locked_1608956297773 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber.destroy"
  },
  "src::data.subscriber": {
    "meta": "code.meta.class",
    "signature": "<void> src::data.subscriber()",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::class.empty",
      "src::data.subscriber.constructor",
      "src::data.subscriber.closed",
      "src::data.subscriber.open.prev",
      "src::data.subscriber.accept",
      "src::data.subscriber.reopen",
      "src::data.subscriber.open",
      "src::data.subscriber.close",
      "src::data.subscriber.destroy",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let mixin_1608956297740__1,extend,constructor,get_closed,method_prevOpen,method_accept,method_reopen,method_open,method_close,method_destroy,isObject;\n    \n                    let var_init_locked_1608956297740;\n    \n                    let var_class_1608956297740;\n    \n                    \n\n                    let var_global_main_1608956297740 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297740){\n\n            mixin_1608956297740__1 = include('src::mixin.observable');\nextend = include('src::class.empty')();\nconstructor = include('src::data.subscriber.constructor');\nget_closed = include('src::data.subscriber.closed');\nmethod_prevOpen = include('src::data.subscriber.open.prev');\nmethod_accept = include('src::data.subscriber.accept');\nmethod_reopen = include('src::data.subscriber.reopen');\nmethod_open = include('src::data.subscriber.open');\nmethod_close = include('src::data.subscriber.close');\nmethod_destroy = include('src::data.subscriber.destroy');\nisObject = include('src::is.object.simple');\n\n            class main extends mixins({extend , mixins:[include('mixin.observable')]}){\n\n            \n\n            \n\n            constructor(...args){\n\n            super(...args) ;\n\n            constructor.apply(this , args) ;\n\n        }\n\n            prevOpen(...args){\n\n            return method_prevOpen.apply(this , args) ;\n\n        }\naccept(...args){\n\n            return method_accept.apply(this , args) ;\n\n        }\nreopen(...args){\n\n            return method_reopen.apply(this , args) ;\n\n        }\nopen(...args){\n\n            return method_open.apply(this , args) ;\n\n        }\nclose(...args){\n\n            return method_close.apply(this , args) ;\n\n        }\ndestroy(...args){\n\n            return method_destroy.apply(this , args) ;\n\n        }\n\n            get closed(){\n\n                return get_closed.call(this) ;\n    \n            }\n\n        }\n\n            var_class_1608956297740 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297740 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.subscriber' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297740 ;\n        \nvar_global_main_1608956297740 = main;\n\n            var_init_locked_1608956297740 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297740 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.subscriber"
  },
  "src::is.class": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.class(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isType;\n    \n                    let var_init_locked_1608956297782;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断数据是否为类\n * \n * @import is.type\n * \n * @param {mixed} data 检测数据\n * \n * @return {boolean} 如果指定数据是类则返回 true ，否则返回 false \n * \n */\n\nreturn isType(data , 'function') && data.__ZBEE_IS_CLASS__ ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297782){\n\n            isType = include('src::is.type');\n\n            var_init_locked_1608956297782 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.class"
  },
  "src::class.create": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::class.create(<mixed> baseClass , <mixed> ...args)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.function",
      "src::is.class"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isFunction,isClass;\n    \n                    let var_init_locked_1608956297779;\n    \n                    \n\n                    function main(baseClass , ...args){\n\n        \n/**\n * \n * 实例基于指定类对象\n * \n * @import is.string\n * \n * @import is.function\n * \n * @import is.class\n * \n * @param {mixed} baseClass 类\n * \n * @param {mixed} [...args] 类参数\n * \n */\n\n\n\nif(isString(baseClass)){\n\n    baseClass = include(baseClass) ;\n}\n\nif(isFunction(baseClass)){\n\n    baseClass = baseClass(...args) ;\n\n    if(!isClass(baseClass)){\n\n        return baseClass ;\n    }\n}\n\nif(isClass(baseClass)){\n\n    return new baseClass(...args) ;\n}\n\n    }\n    \n                    return function(baseClass , ...args){\n    \n                        \n        if(!var_init_locked_1608956297779){\n\n            isString = include('src::is.string');\nisFunction = include('src::is.function');\nisClass = include('src::is.class');\n\n            var_init_locked_1608956297779 = true ;\n        }\n        \n    \n                        return main.call(this , baseClass , ...args) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "class.create"
  },
  "src::data.connection.subscribe.name": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::data.connection.subscribe.name(<string> name , <string> namespace)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(name , namespace){\n\n        \n/**\n * \n * 获取订阅器名称\n * \n * @param {string} name 订阅器名称\n * \n * @param {string} [namespace] 命名空间s\n * \n * @return {string} 订阅器名称\n * \n */\n\nif(namespace){\n\n    return `${name}<${namespace}>` ;\n}\n\nreturn name ;\n\n    }\n    \n                    return function(name , namespace){\n    \n                        \n    \n                        return main.call(this , name , namespace) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.subscribe.name"
  },
  "src::data.connection.base": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.base()",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::is.string",
      "src::is.function",
      "src::is.boolean",
      "src::is.array",
      "src::data.subscriber",
      "src::function.get",
      "src::class.create",
      "src::array.includes",
      "src::array.remove",
      "src::data.connection.subscribe.name",
      "src::mixin.observable",
      "src::event.listener.add",
      "src::data.equals"
    ],
    "dependentModules": {
      "regex-parser": "^2.2.10"
    },
    "data": "(() =>{\n\n                    let isObject,isString,isFunction,isBoolean,isArray,Subscriber,get,create,includes,remove,getName,Observable,add,equals;\n    \n                    let var_init_locked_1608956297735;\n    \n                    let var_class_1608956297735;\n    \n                    \n\n                    let var_global_main_1608956297735 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297735){\n\n            isObject = include('src::is.object.simple');\nisString = include('src::is.string');\nisFunction = include('src::is.function');\nisBoolean = include('src::is.boolean');\nisArray = include('src::is.array');\nSubscriber = include('src::data.subscriber')();\nget = include('src::function.get');\ncreate = include('src::class.create');\nincludes = include('src::array.includes');\nremove = include('src::array.remove');\ngetName = include('src::data.connection.subscribe.name');\nObservable = include('src::mixin.observable');\nadd = include('src::event.listener.add');\nequals = include('src::data.equals');\n\n            /**\n * \n * 数据连接基础类\n * \n * @import isObject from is.object.simple\n * \n * @import is.string\n * \n * @import is.function\n * \n * @import is.boolean\n * \n * @import is.array\n * \n * @import Subscriber from data.subscriber value\n * \n * @import get from function.get\n * \n * @import create from class.create\n * \n * @import includes from array.includes\n * \n * @import remove from array.remove\n * \n * @import getName from .subscribe.name\n * \n * @import Observable from mixin.observable\n * \n * @import add from event.listener.add\n * \n * @import equals from data.equals\n * \n * @require regex-parser\n * \n * @class\n * \n */\n\n const createRegex = require('regex-parser'); \n\n function createRules(rules){\n\n    let result = [] ;\n\n    for(let {\n        test,\n        use\n    } of rules){\n\n        if(isFunction(use)){\n\n            result.push({\n                test:createRegex(test),\n                use\n            }) ;\n        }\n    }\n\n    return result ;\n }\n\n class main extends mixins({\n     mixins:[\n        Observable\n     ]\n }){\n\n    constructor({\n        subscriber = Subscriber,\n        rules = [],\n        matchOnlyOnce = false,\n        ...options\n    }){\n\n        super(options) ;\n\n        let me = this ;\n\n        me.subscriber = subscriber ;\n\n        me.subscribers = new Map() ;\n\n        me.rules = createRules(rules) ;\n\n        me.subscribeParamList = [] ;\n\n        me.matchOnlyOnce = matchOnlyOnce ;\n\n        add(me , {\n            ...me.subscriberListeners,\n            scope:me\n        }) ;\n    }\n\n    processMessage(...args){\n\n        return {} ;\n    }\n\n    processData(subscriber , message){\n\n        return subscriber.processData(message) ;\n    }\n\n    validateMessage(subscriber , message){\n\n        return true ;\n    }\n\n\n    processSubscribeParams(subscriber , params){\n\n        return [\n            params\n        ] ;\n    }\n\n    /**\n     * \n     * 构建订阅器\n     * \n     * @param {string} name  订阅名称 \n     * \n     * @param {mixed} options 订阅器参数\n     * \n     * @return {data.Subscriber} 订阅器\n     * \n     */\n    createSubscriber(name , options){\n\n        let me = this,\n        {\n            subscriber\n        } = me ;\n\n        return create(subscriber , me , name , options) ;\n    }\n\n    onCreateSubscriber(subscriber){\n\n\n    }\n\n    get subscriberListeners(){\n\n        return {\n            open:'onSubscriberOpen',\n            close:'onSubscriberClose'\n        } ;\n    }\n\n    onSubscriberOpen(subscriber , params){\n\n        let me = this;\n\n        params = me.processSubscribeParams(subscriber , params) ;\n\n        if(isArray(params)){\n\n            if(me.validSubscriberOpenParams(params)){\n\n                me.doSubscriberOpen(...params) ;\n\n                me.subscribeParamList.push(params) ;\n            }\n        }\n    }\n\n    validSubscriberOpenParams(params){\n\n        let {\n            subscribeParamList\n        } = this ;\n\n        if(!includes(subscribeParamList , params)){\n\n            return true ;\n        }\n\n        return false ;\n    }\n\n    doSubscriberOpen(...args){\n\n\n    }\n\n    onSubscriberClose(subscriber , params){\n\n        let me = this ;\n\n        params = me.processSubscribeParams(subscriber , params) ;\n\n        if(isArray(params)){\n\n            if(me.validSubscriberCloseParams(params)){\n\n                me.doSubscriberClose(...params) ;\n\n                remove(me.subscribeParamList , params) ;\n            }\n        }\n\n    }\n\n    validSubscriberCloseParams(params){\n\n        let me = this,\n            subscribers = me.subscribers.values() ;\n\n        for(let subscriber of subscribers){\n\n            let {\n                closed,\n                params:subscribeParams\n            } = subscriber ;\n\n            if(!closed && equals(params , me.processSubscribeParams(subscriber , subscribeParams))){\n\n                return false ;\n            }\n        }\n\n        return true ;\n    }\n\n    doSubscriberClose(...args){\n\n\n    }\n\n    getSubscriber(name , namespace){\n\n        return this.subscribers.get(getName(name , namespace)) ;\n    }\n\n    /**\n     * \n     * @param {string} name 订阅器名称\n     *  \n     * @param {string} method 订阅器方法名称\n     *  \n     * @param  {mixed} ...args 订阅器方法参数\n     */\n    doSubscriberMethod(name , method , ...args){\n\n        let me = this,\n        {\n            subscribers\n        } = me,\n        subscriber = subscribers.get(name);\n\n        if(subscriber){\n\n            subscriber[method](...args) ;\n\n            return subscriber ;\n        }\n    }\n }\n\n            var_class_1608956297735 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297735 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.base' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297735 ;\n        \nvar_global_main_1608956297735 = main;\n\n            var_init_locked_1608956297735 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297735 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.base"
  },
  "src::data.connection.subscribed": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::data.connection.subscribed(<string> name , <string> connectionId)",
    "standard": true,
    "importNames": [
      "src::data.connection.subscribe.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956297786;\n    \n                    \n\n                    function main(name , connectionId){\n\n        \n/**\n * \n * 判定是否订阅\n * \n * @import getName from .subscribe.name\n * \n * @param {string} name 订阅名称\n * \n * @param {string} [connectionId] 连接编号\n * \n * @return {boolean} 如果已订阅则返回 true ， 否则返回 false\n * \n */\n\nlet me = this,\n{\n    subscribers\n} = me;\n\nreturn subscribers.has(getName(name , connectionId)) ;\n\n \n\n    }\n    \n                    return function(name , connectionId){\n    \n                        \n        if(!var_init_locked_1608956297786){\n\n            getName = include('src::data.connection.subscribe.name');\n\n            var_init_locked_1608956297786 = true ;\n        }\n        \n    \n                        return main.call(this , name , connectionId) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.subscribed"
  },
  "src::data.connection.subscribe.once": {
    "meta": "code.meta.script.function",
    "signature": "<Promise> src::data.connection.subscribe.once(<string> name , <object> options)",
    "standard": true,
    "importNames": [
      "src::object.assign"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let assign;\n    \n                    let var_init_locked_1608956297789;\n    \n                    \n\n                    function main(name , options){\n\n        \n/**\n * \n * 订阅后获取数据后立即取消订阅，并返回获得数据\n * \n * @import assign from object.assign\n * \n * @param {string} name 订阅名称\n * \n * @param {object} [options = {}] 订阅配置\n * \n * @return {Promise}\n * \n */\n\n let me = this ;\n\n return new Promise(fn =>  me.subscribe(name , {\n    ...options,\n    fn,\n    once:true\n})) ;\n\n    }\n    \n                    return function(name , options = {}){\n    \n                        \n        if(!var_init_locked_1608956297789){\n\n            assign = include('src::object.assign');\n\n            var_init_locked_1608956297789 = true ;\n        }\n        \n    \n                        return main.call(this , name , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.subscribe.once"
  },
  "src::function.defer": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::function.defer(<mixed> fn , {<mixed> scope , <mixed> defer})",
    "standard": true,
    "importNames": [
      "src::function.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956297801;\n    \n                    \n\n                    function main(fn , {scope , defer}){\n\n        \n/**\n * \n * 延时执行函数\n * \n * @import get from function.get\n * \n * @param {mixed} fn 函数\n * \n * @param {object} [config = {}] 函数配置\n * \n * @param {mixed} [config.scope] 函数作用域\n * \n * @param {mixed} [config.defer = 0] 延时时间\n * \n */\n\n return setTimeout(() => get(fn , scope)() , defer) ;\n\n    }\n    \n                    return function(fn , {scope , defer = 0} = {}){\n    \n                        \n        if(!var_init_locked_1608956297801){\n\n            get = include('src::function.get');\n\n            var_init_locked_1608956297801 = true ;\n        }\n        \n    \n                        return main.call(this , fn , {scope , defer}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "function.defer"
  },
  "src::data.pusher": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.pusher(<function> onOpen , <function> onClose)",
    "standard": true,
    "importNames": [
      "src::is.defined",
      "src::array.clear",
      "src::function.defer"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined,clear,defer;\n    \n                    let var_init_locked_1608956297795;\n    \n                    let var_class_1608956297795;\n    \n                    \n\n                    let var_global_main_1608956297795 ;\n    \n                    return function(onOpen , onClose){\n    \n                        \n        if(!var_init_locked_1608956297795){\n\n            isDefined = include('src::is.defined');\nclear = include('src::array.clear');\ndefer = include('src::function.defer');\n\n            \n/**\n * \n * 数据推送器\n * \n * @import is.defined\n * \n * @import clear from array.clear\n * \n * @import defer from function.defer\n * \n * @param {function} onOpen 当开始推送时回调函数\n * \n * @param {function} onClose 当开始推送时回调函数\n * \n */\n\n class main{\n\n    constructor(onOpen , onClose){\n\n        let me = this ;\n\n        me.onOpen = onOpen ;\n\n        me.onClose = onClose ;\n\n        me.callbacks = [] ;\n\n        defer(open , {\n            scope:me\n        }) ;\n    }\n\n    close(){\n\n        let {\n            callbacks,\n            onClose\n        } = this ;\n\n        clear(callbacks) ;\n\n        onClose() ;\n    }\n\n    push(callback){\n\n        let me = this,\n            {\n                callbacks\n            } = me;\n\n        callbacks.push(callback) ;\n\n        return me ;\n    }\n }\n\n function open(){\n\n    let me = this,\n    {\n        callbacks,\n        onOpen\n    } = me;\n\n    onOpen(data => {\n\n        for(let callback of callbacks){\n\n            let result = callback(data) ;\n\n            if(isDefined(result)){\n\n                data = result ;\n            }\n        }\n\n    }) ;\n }\n\n            var_class_1608956297795 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297795 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.pusher' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297795 ;\n        \nvar_global_main_1608956297795 = main;\n\n            var_init_locked_1608956297795 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956297795(onOpen , onClose) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.pusher"
  },
  "src::data.connection.subscribe.push": {
    "meta": "code.meta.script.function",
    "signature": "<Promise> src::data.connection.subscribe.push(<string> name , <object> options)",
    "standard": true,
    "importNames": [
      "src::object.assign",
      "src::data.pusher"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let assign,createPusher;\n    \n                    let var_init_locked_1608956297792;\n    \n                    \n\n                    function main(name , options){\n\n        \n/**\n * \n * 订阅后进行推送\n * \n * @import assign from object.assign\n * \n * @import createPusher from data.pusher\n * \n * @param {string} name 订阅名称\n * \n * @param {object} [options = {}] 订阅配置\n * \n * @return {Promise}\n * \n */\n\n let me = this,\n     subscriber ;\n\nreturn createPusher(fn => subscriber = me.subscribe(name , {\n    ...options,\n    fn\n}) , () => {\n\n    subscriber.destroy() ;\n\n    subscriber = null ;\n}) ;\n\n    }\n    \n                    return function(name , options = {}){\n    \n                        \n        if(!var_init_locked_1608956297792){\n\n            assign = include('src::object.assign');\ncreatePusher = include('src::data.pusher');\n\n            var_init_locked_1608956297792 = true ;\n        }\n        \n    \n                        return main.call(this , name , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.subscribe.push"
  },
  "src::data.connection.find.subscriber.opened.name": {
    "meta": "code.meta.script.function",
    "signature": "<data.Subscriber> src::data.connection.find.subscriber.opened.name(<string> name , <data.Subscriber> ignoreSubscriber)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(name , ignoreSubscriber){\n\n        \n/**\n * \n * 获得一个指定名称的缴活订阅器\n * \n * @param {string} name 订阅器名称\n * \n * @param {data.Subscriber} [ignoreSubscriber] 忽略的订阅器\n * \n * @return {data.Subscriber} 订阅器 \n * \n */\n\n let subscribers = this.subscribers.values() ;\n\n for(let subscriber of subscribers){\n\n    let {\n        name:subscriberName\n    } = subscriber ;\n\n    if(subscriberName === name && subscriber !== ignoreSubscriber){\n\n        return subscriber ;\n    }\n }\n\n    }\n    \n                    return function(name , ignoreSubscriber){\n    \n                        \n    \n                        return main.call(this , name , ignoreSubscriber) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.find.subscriber.opened.name"
  },
  "src::data.connection.subscribe.namespace.generate": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::data.connection.subscribe.namespace.generate(<string> name)",
    "standard": true,
    "importNames": [
      "src::id.generate",
      "src::data.connection.subscribe.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let generate,getName;\n    \n                    let var_init_locked_1608956297816;\n    \n                    \n\n                    function main(name){\n\n        \n/**\n * \n * 生成可用的命名空间\n * \n * @import generate from id.generate\n * \n * @import getName from ..name\n * \n * @param {string} name 订阅名称\n * \n * @return {string} 命名空间 \n * \n */\n\n let {\n    subscribers\n } = this,\n fullName;\n\n do{\n\n    fullName = getName(name , generate('connection-')) ;\n\n } while(subscribers.has(fullName)) ;\n\n return fullName ;\n\n \n\n    }\n    \n                    return function(name){\n    \n                        \n        if(!var_init_locked_1608956297816){\n\n            generate = include('src::id.generate');\ngetName = include('src::data.connection.subscribe.name');\n\n            var_init_locked_1608956297816 = true ;\n        }\n        \n    \n                        return main.call(this , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.subscribe.namespace.generate"
  },
  "src::data.connection.subscribe": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.subscribe(<string> name , <object> options)",
    "standard": true,
    "importNames": [
      "src::object.assign",
      "src::data.connection.subscribe.name",
      "src::data.connection.subscribe.namespace.generate"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let assign,getName;\n    \n                    let var_init_locked_1608956297813;\n \n                    \n\n                    const var_current_scope_1608956297813 = new Map();\n    \n                    return function(name , options = {}){\n    \n                        \n        if(!var_init_locked_1608956297813){\n\n            assign = include('src::object.assign');\ngetName = include('src::data.connection.subscribe.name');\n\n            var_init_locked_1608956297813 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956297813.has(this)){\n\n            var_current_scope_1608956297813.set(this , (() => {\n                const generate = include('src::data.connection.subscribe.namespace.generate').bind(this);\n\n                /**\n * \n * 单次订阅\n * \n * @import assign from object.assign\n * \n * @import getName from .subscribe.name\n * \n * @import generate from .subscribe.namespace.generate scoped\n * \n * @param {string} name 订阅名称\n * \n * @param {object} [options = {}] 订阅配置\n * \n */\n\nfunction main(name , options){\n\n    let me = this,\n    {\n        subscribers,\n        forceSubscribe\n    } = me,\n    {\n        namespace\n    } = options;\n\n    if(me.isSubscribed(name , namespace)){\n\n        namespace = generate(name) ;\n        \n    }\n\n    let fullName = getName(name , namespace),\n        subscriber = me.createSubscriber(name , assign({} , convertNameToSubscriberOptions.call(me , name) , {\n            ...options,\n            fullName\n        })) ;\n\n    subscribers.set(fullName , subscriber) ;\n\n    me.onCreateSubscriber(subscriber) ;\n\n    return subscriber ;\n}\n\nfunction convertNameToSubscriberOptions(name){\n\n    let {\n        rules\n    } = this;\n\n    for(let {\n        test,\n        use\n    } of rules){\n\n        let args = name.match(test) ;\n\n        if(args){\n\n            return use(...args) ;\n        }\n    }\n\n    return {} ;\n }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297813.get(this) ;\n\n        \n    \n                        return main.call(this , name , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.subscribe"
  },
  "src::data.connection.unsubscribe": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.unsubscribe(<string> name , <string> namespace)",
    "standard": true,
    "importNames": [
      "src::data.connection.subscribe.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956297819;\n    \n                    \n\n                    function main(name , namespace){\n\n        \n/**\n * \n * 取消单次订阅\n * \n * @import getName from .subscribe.name\n * \n * @param {string} name 订阅名称\n * \n * @param {string} [namespace] 命名空间\n * \n */\n\nlet me = this,\n    {\n        subscribers\n    } = me,\n    fullNames = [];\n\nif(namespace){\n\n    fullNames.push(getName(name , namespace)) ;\n\n}else{\n\n    let  subscriberNames = subscribers.keys(),\n         namespaceRe = /\\<[^\\<\\>]+\\>$/;\n\n    for(let subscriberName of subscriberNames){\n\n        if(subscriberName.replace(namespaceRe , '') === name){\n\n            fullNames.push(subscriberName) ;\n        }\n    }\n}\n\nfor(let fullName of fullNames){\n\n    me.doSubscriberMethod(fullName , 'destroy') ;\n}\n\n\n\n    }\n    \n                    return function(name , namespace){\n    \n                        \n        if(!var_init_locked_1608956297819){\n\n            getName = include('src::data.connection.subscribe.name');\n\n            var_init_locked_1608956297819 = true ;\n        }\n        \n    \n                        return main.call(this , name , namespace) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.unsubscribe"
  },
  "src::data.connection.subscribes": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.connection.subscribes(<object> config)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.function",
      "src::is.object.simple",
      "src::function.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isFunction,isObject,get;\n    \n                    let var_init_locked_1608956297825;\n    \n                    \n\n                    function main(config){\n\n        \n/**\n * \n * 批量订阅\n * \n * @import is.string\n * \n * @import is.function\n * \n * @import isObject from is.object.simple\n * \n * @import get from function.get\n * \n * @param {object} config 批量订阅配置\n * \n * @return {object} 实例化后的订阅器集合\n * \n */\n\nlet {\n    scope,\n    namespace,\n    ...subscribers\n} = config,\nme = this,\nnames = Object.keys(subscribers),\nresult = {};\n\nfor(let name of names){\n\n    let target = subscribers[name],\n        subscriber;\n\n    if(isString(target) || isFunction(target)){\n\n        subscriber = me.subscribe(name , {\n            fn:target,\n            namespace,\n            scope\n        }) ;\n\n    }else if(isObject(target)){\n\n        subscriber = me.subscribe(name , {\n            ...target,\n            namespace,\n            scope\n        }) ;\n    }\n\n    if(subscriber){\n\n        result[name] = subscriber ;\n    }\n}\n\nreturn result ;\n\n    }\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956297825){\n\n            isString = include('src::is.string');\nisFunction = include('src::is.function');\nisObject = include('src::is.object.simple');\nget = include('src::function.get');\n\n            var_init_locked_1608956297825 = true ;\n        }\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.subscribes"
  },
  "src::data.connection.unsubscribes": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.unsubscribes(<string[]> names , <string> namespace)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(names , namespace){\n\n        \n/**\n * \n * 批量取消订阅\n * \n * @param {string[]} names 批量订阅配置\n * \n * @param {string} [namespace] 命名空间\n * \n */\n\nlet me = this;\n\nfor(let name of names){\n\n    me.unsubscribe(name , namespace) ;\n}\n\n    }\n    \n                    return function(names , namespace){\n    \n                        \n    \n                        return main.call(this , names , namespace) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.unsubscribes"
  },
  "src::data.connection.deactivate": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.deactivate()",
    "standard": true,
    "importNames": [
      "src::array.includes"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let includes;\n    \n                    let var_init_locked_1608956297833;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 冻结\n * \n * @import includes from array.includes\n * \n */\n\nlet me = this,\n{\n    subscribeParamList\n} = me;\n\nfor(let params of subscribeParamList){\n\n    me.doSubscriberClose(...params) ;\n}\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297833){\n\n            includes = include('src::array.includes');\n\n            var_init_locked_1608956297833 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.deactivate"
  },
  "src::data.connection": {
    "meta": "code.meta.class",
    "signature": "<void> src::data.connection()",
    "standard": true,
    "importNames": [
      "src::data.connection.base",
      "src::data.connection.accept",
      "src::data.connection.subscribed",
      "src::data.connection.subscribe.once",
      "src::data.connection.subscribe.push",
      "src::data.connection.find.subscriber.opened.name",
      "src::data.connection.subscribe",
      "src::data.connection.unsubscribe",
      "src::data.connection.subscribes",
      "src::data.connection.unsubscribes",
      "src::data.connection.activate",
      "src::data.connection.deactivate",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let extend,method_acceptMessage,method_isSubscribed,method_subscribeOnce,method_subscribePush,method_findOpenedSubscriberByName,method_subscribe,method_unsubscribe,method_subscribes,method_unsubscribes,method_activate,method_deactivate,isObject;\n    \n                    let var_init_locked_1608956297727;\n    \n                    let var_class_1608956297727;\n    \n                    \n\n                    let var_global_main_1608956297727 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297727){\n\n            extend = include('src::data.connection.base')();\nmethod_acceptMessage = include('src::data.connection.accept');\nmethod_isSubscribed = include('src::data.connection.subscribed');\nmethod_subscribeOnce = include('src::data.connection.subscribe.once');\nmethod_subscribePush = include('src::data.connection.subscribe.push');\nmethod_findOpenedSubscriberByName = include('src::data.connection.find.subscriber.opened.name');\nmethod_subscribe = include('src::data.connection.subscribe');\nmethod_unsubscribe = include('src::data.connection.unsubscribe');\nmethod_subscribes = include('src::data.connection.subscribes');\nmethod_unsubscribes = include('src::data.connection.unsubscribes');\nmethod_activate = include('src::data.connection.activate');\nmethod_deactivate = include('src::data.connection.deactivate');\nisObject = include('src::is.object.simple');\n\n            class main extends mixins({extend , mixins:[]}){\n\n            \n\n            \n\n            \n\n            acceptMessage(...args){\n\n            return method_acceptMessage.apply(this , args) ;\n\n        }\nisSubscribed(...args){\n\n            return method_isSubscribed.apply(this , args) ;\n\n        }\nsubscribeOnce(...args){\n\n            return method_subscribeOnce.apply(this , args) ;\n\n        }\nsubscribePush(...args){\n\n            return method_subscribePush.apply(this , args) ;\n\n        }\nfindOpenedSubscriberByName(...args){\n\n            return method_findOpenedSubscriberByName.apply(this , args) ;\n\n        }\nsubscribe(...args){\n\n            return method_subscribe.apply(this , args) ;\n\n        }\nunsubscribe(...args){\n\n            return method_unsubscribe.apply(this , args) ;\n\n        }\nsubscribes(...args){\n\n            return method_subscribes.apply(this , args) ;\n\n        }\nunsubscribes(...args){\n\n            return method_unsubscribes.apply(this , args) ;\n\n        }\nactivate(...args){\n\n            return method_activate.apply(this , args) ;\n\n        }\ndeactivate(...args){\n\n            return method_deactivate.apply(this , args) ;\n\n        }\n\n            \n\n        }\n\n            var_class_1608956297727 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297727 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297727 ;\n        \nvar_global_main_1608956297727 = main;\n\n            var_init_locked_1608956297727 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297727 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection"
  },
  "src::data.connection.deploy.lifecycle": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.connection.deploy.lifecycle(<object> connections , <object> component , <function> getConnectionId)",
    "standard": true,
    "importNames": [
      "src::data.connection.deploy"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let deploy;\n    \n                    let var_init_locked_1608956297837;\n    \n                    \n\n                    function main(connections , component , getConnectionId){\n\n        \n/**\n * \n * 对象版部署封装\n * \n * @import deploy from ..deploy\n * \n * @param {object} connections 订阅对象\n * \n * @param {object} component 组件定义对象\n * \n * @param {function} [getConnectionId] 获得连接编号\n * \n * @return {object} 增加订阅功能的组件定义对象\n * \n */\n\n let names = Object.keys(connections),\n     config = {};\n\n for(let name of names){\n\n    let field = name === 'default' ? 'subscribers' : `${name}_subscribers`,\n        subscribers = component[field],\n        varName = `$${field}`,\n        connection = connections[name];\n\n    if(subscribers){\n\n        config[name] ={\n            varName,\n            connection,\n            subscribers\n        } ;\n\n        delete component[field] ;\n\n    }else{\n\n        config[name] = {\n            varName,\n            connection,\n            subscribers:{}\n        } ;\n    }\n }\n\n return deploy(connections , config , getConnectionId);\n\n    }\n    \n                    return function(connections , component , getConnectionId){\n    \n                        \n        if(!var_init_locked_1608956297837){\n\n            deploy = include('src::data.connection.deploy');\n\n            var_init_locked_1608956297837 = true ;\n        }\n        \n    \n                        return main.call(this , connections , component , getConnectionId) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.deploy.lifecycle"
  },
  "src::data.connection.deploy": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.connection.deploy(<array> connections , <object> subscriberMap , <function> getConnectionId)",
    "standard": true,
    "importNames": [
      "src::id.generate",
      "src::is.object.simple",
      "src::is.array",
      "src::is.function",
      "src::is.string",
      "src::function.empty"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let generate,isObject,isArray,isFunction,isString,empty;\n    \n                    let var_init_locked_1608956297844;\n    \n                    \n\n                    function main(connections , subscriberMap , getConnectionId){\n\n        /**\n * \n * 实现部署\n * \n * @import generate from id.generate\n * \n * @import isObject from is.object.simple\n * \n * @import is.array\n * \n * @import is.function\n * \n * @import is.string\n * \n * @import isObject from is.object.simple\n * \n * @import empty from function.empty value\n * \n * @param {array} connections 连接实例集合\n * \n * @param {object} subscriberMap 订阅器定义集合\n * \n * @param {function} [getConnectionId] 获得连接编号\n * \n * @return {object}\n * \n */\n\n let {\n    keys\n } = Object;\n\n getConnectionId = getConnectionId || empty ;\n\n let defaultConnectionId = generate('connection-') ;\n\n function isMounted(){\n\n    return this.hasOwnProperty('$connectionId') ;\n }\n\n return {\n\n    mounted(){\n\n        let scope = this ;\n\n        if(isMounted.call(scope)){\n\n            return ;\n        }\n\n        let names = keys(subscriberMap),\n            namespace = scope.$connectionId = getConnectionId.call(scope) || defaultConnectionId ;\n\n        for(let name of names){\n\n            let {\n                varName,\n                connection,\n                subscribers\n            } = subscriberMap[name] ;\n            \n            scope[varName] = new Proxy(connection.subscribes({\n                ...subscribers,\n                namespace,\n                scope\n            }) , {\n\n                set(subscribers , name , config){\n\n                    if(!subscribers.hasOwnProperty(name)){\n\n                        let subscriber = connection.subscribes({\n                            [name]:config,\n                            namespace,\n                            scope\n                        })[name] ;\n\n                        if(subscriber){\n\n                            subscribers[name] = subscriber ;\n                        }\n                    }\n\n                    return subscribers ;\n\n                },\n\n                get(subscribers , name){\n\n                    return subscribers[name] ;\n                },\n\n                deleteProperty(subscribers , name){\n\n                    if(subscribers.hasOwnProperty(name)){\n\n                        connection.unsubscribe(name , namespace) ;\n\n                        delete subscribers[name] ;\n                    }\n\n                    return subscribers ;\n                },\n\n                ownKeys(subscribers){\n\n                    return Object.keys(subscribers) ;\n                }\n\n            }) ;\n        }\n\n    },\n\n    unmounted(){\n\n        let scope = this ;\n\n        if(!isMounted.call(scope)){\n\n            return ;\n        }\n\n        let names = keys(subscriberMap),\n            {\n                $connectionId:namespace\n            } = scope;\n\n        for(let name of names){\n\n            let {\n                varName,\n                connection,\n            } = subscriberMap[name] ;\n\n            connection.unsubscribes(keys(scope[varName]) , namespace) ;\n\n            delete scope[varName] ;\n        }\n\n        delete scope.$connectionId ;\n    }\n\n } ;\n\n    }\n    \n                    return function(connections , subscriberMap , getConnectionId){\n    \n                        \n        if(!var_init_locked_1608956297844){\n\n            generate = include('src::id.generate');\nisObject = include('src::is.object.simple');\nisArray = include('src::is.array');\nisFunction = include('src::is.function');\nisString = include('src::is.string');\nisObject = include('src::is.object.simple');\nempty = include('src::function.empty')();\n\n            var_init_locked_1608956297844 = true ;\n        }\n        \n    \n                        return main.call(this , connections , subscriberMap , getConnectionId) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.deploy"
  },
  "src::data.connection.deploy.miniprogram": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.connection.deploy.miniprogram(<object> connections , <object> component , <array> defaultConnectionNames)",
    "standard": true,
    "importNames": [
      "src::data.connection.socket.manager",
      "src::function.empty",
      "src::data.connection.deploy.lifecycle"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Manager,empty,deploy;\n    \n                    let var_init_locked_1608956297851;\n    \n                    \n\n                    function main(connections , component , defaultConnectionNames){\n\n        \n/**\n * \n * 基于数据连接的小程序封装\n * \n * @import Manager from data.connection.socket.manager value\n * \n * @import empty from function.empty value\n * \n * @import deploy from .lifecycle\n * \n * @param {object} connections 订阅对象\n * \n * @param {object} component 组件定义对象\n * \n * @param {array} [defaultConnectionNames = []] 默认连接名称集合\n * \n * @return {object} 增加订阅功能的组件定义对象\n * \n */\n\nconst {                 \n    onLoad:originLoad = empty,\n    onShow:originShow = empty,\n    onHide:originHide = empty,\n    onUnload:originUnload = empty,\n    connections:connectionNames = defaultConnectionNames,\n    ...options\n } = component;\n\nlet {\n    mounted,\n    unmounted,\n    subscribe,\n    unsubscribe\n} = deploy(connections , component) ;\n\nfunction initSockets(){\n\n     if(!this.hasOwnProperty('$connectionId')){\n\n          let names = Object.keys(connections);\n\n          for(let name of names){\n\n               if(!connectionNames.includes(name)){\n\n                    Manager.disconnect(connections[name]) ;\n\n               }\n          }\n\n          for(let name of names){\n\n               if(connectionNames.includes(name)){\n\n                    Manager.connect(connections[name]) ;\n               }\n          }\n     }\n}\n\nreturn {\n    ...options,\n    onLoad(options){\n\n        let me = this ;\n\n        initSockets.call(me) ;\n\n        mounted.call(me) ;\n            \n        originLoad.call(me , options) ;\n        \n   },\n\n   onShow(){\n\n        let me = this ;\n\n        initSockets.call(me) ;\n\n        mounted.call(me) ;\n            \n        originShow.call(me , options) ;\n   },\n\n   onHide(){\n\n        let me = this ;\n\n        originHide.call(me) ;\n\n        unmounted.call(me) ;\n   },\n\n   onUnload(){\n\n        let me = this ;\n\n        originUnload.call(me) ;\n\n        unmounted.call(me) ;\n   },\n   subscribe,\n   unsubscribe\n} ;\n\n    }\n    \n                    return function(connections , component , defaultConnectionNames = []){\n    \n                        \n        if(!var_init_locked_1608956297851){\n\n            Manager = include('src::data.connection.socket.manager')();\nempty = include('src::function.empty')();\ndeploy = include('src::data.connection.deploy.lifecycle');\n\n            var_init_locked_1608956297851 = true ;\n        }\n        \n    \n                        return main.call(this , connections , component , defaultConnectionNames) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.deploy.miniprogram"
  },
  "src::data.connection.socket": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.socket()",
    "standard": true,
    "importNames": [
      "src::data.connection",
      "src::mixin.observable",
      "src::event.listener.add",
      "src::data.connection.socket.manager",
      "src::environment.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Connection,observable,add,Manager,getName;\n    \n                    let var_init_locked_1608956297868;\n    \n                    let var_class_1608956297868;\n    \n                    \n\n                    let var_global_main_1608956297868 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297868){\n\n            Connection = include('src::data.connection')();\nobservable = include('src::mixin.observable');\nadd = include('src::event.listener.add');\nManager = include('src::data.connection.socket.manager')();\ngetName = include('src::environment.name');\n\n            \n\n/**\n * \n * Socket 通信\n * \n * @import Connection from data.connection value\n * \n * @import observable from mixin.observable\n * \n * @import add from event.listener.add\n * \n * @import Manager from .socket.manager value\n * \n * @import getName from environment.name\n * \n * @class\n * \n */\n\n class main extends Connection{\n\n    constructor({\n        socket,\n        ...superOptions\n    }){\n\n        super(superOptions) ;\n\n        let me = this ;\n\n        let {\n            url,\n            ...options\n        } = socket,\n        {\n            reconnection = true,\n            reconnectionDelay = 1000,\n            autoConnect = true,\n            ...otherOptions\n        } = options;\n\n        me.initialize(url , otherOptions) ;\n\n        if(autoConnect){\n\n            Manager.connect(me) ;\n        }\n\n        if(reconnection){\n\n            add(me , {\n                lostconnect:'onReconnect',\n                connecttimeout:'onReconnect',\n                scope:me\n            }) ;\n        }\n\n        add(me , 'connect' , () => me.activate()) ;\n\n        me.reconnectionDelay = reconnectionDelay ;\n\n        if(getName() === 'browser'){\n\n            let isDoReconnect = false;\n\n            add(window , {\n                offline(){\n\n                    if(me.isConnected){\n\n                        isDoReconnect = true ;\n                    }\n                },\n                online(){\n\n                    if(me.isConnected && isDoReconnect){\n\n                        me.onReconnect() ;\n                    }\n\n                    isDoReconnect = false ;\n                },\n                scope:me\n            }) ;\n        }\n    }\n\n    onReconnect(){\n\n        let me = this,\n        {\n            reconnectionDelay\n        } = me;\n\n        setTimeout(() => {\n\n            Manager.disconnect(me) ;\n\n            Manager.connect(me) ;\n\n        } , reconnectionDelay) ;\n        \n    }\n\n    initialize(url , options){\n\n\n    }\n\n    get isConnecting(){\n\n        return isState.call(this , 0) ;\n    }\n\n    get isConnected(){\n\n        return isState.call(this , 1) ;\n    }\n\n    get isDisconnecting(){\n\n        return isState.call(this , 2) ;\n    }\n    \n    get isDisconnected(){\n\n        return isState.call(this , 3) ;\n    }\n\n    connect(){\n\n        let me = this,\n        {\n            isDisconnected\n        } = me ;\n\n        if(isDisconnected){\n\n           me.doConnect() ;\n        }\n    }\n\n    doConnect(){\n\n    }\n\n    disconnect(){\n\n        let me = this,\n        {\n            isDisconnected,\n            isDisconnecting\n        } = me ;\n\n        if(!isDisconnected || !isDisconnecting){\n\n            me.disconnectingState = true ;\n\n            me.deactivate() ;\n\n            me.doDisconnect() ;\n        }\n    }\n\n    doDisconnect(){\n\n    }\n\n    validateMessage({\n        params:baseParams\n    },{\n        params:equalParams\n    }){\n\n        let names = Object.keys(equalParams) ;\n\n        for(let name of names){\n\n            if(baseParams[name] !== equalParams[name]){\n\n                return false ;\n            }\n        }\n\n        return true ;\n    }\n }\n\n function isState(state){\n\n    let {\n        socket\n    } = this ;\n\n    if(!socket){\n\n        return state === 3 ;\n    }\n\n    return socket.readyState === state ;\n }\n\n            var_class_1608956297868 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297868 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.socket' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297868 ;\n        \nvar_global_main_1608956297868 = main;\n\n            var_init_locked_1608956297868 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297868 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.socket"
  },
  "src::data.connection.socket.manager": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.socket.manager()",
    "standard": true,
    "importNames": [
      "src::data.connection.socket",
      "src::event.listener.add",
      "src::event.listener.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Socket,add,remove;\n    \n                    let var_init_locked_1608956297855;\n    \n                    let var_class_1608956297855;\n    \n                    let var_once_value_1608956297855;\n\n                    let var_global_main_1608956297855 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297855){\n\n            Socket = include('src::data.connection.socket');\nadd = include('src::event.listener.add');\nremove = include('src::event.listener.remove');\n\n            \n/**\n * \n * 管理多个 WebSocket 推送器开关\n * \n * @import Socket from data.connection.socket\n * \n * @import add from event.listener.add\n * \n * @import remove from event.listener.remove\n * \n * @once\n * \n */\n\n const processQueue = [];\n\n let isProcessorStarted = false,\n     previousSocket;\n\n class main{\n\n    isSocket(socket){\n\n        return socket instanceof Socket() ;\n    }\n\n    isConnected(socket){\n\n        return this.isSocket(socket) && socket.isConnected ;\n    }\n\n    connect(socket){\n\n        todo.call(this , socket , 'connect') ;\n    }\n\n    disconnect(socket){\n\n       todo.call(this , socket , 'disconnect') ;\n    }\n }\n\n function todo(socket , action) {\n\n    if(this.isSocket(socket)){\n\n        processQueue.push({\n            socket,\n            action\n        }) ;\n    \n        start() ;\n    }\n }\n\n function start() {\n\n    if(!isProcessorStarted){\n\n        isProcessorStarted = true ;\n\n        doSetTimeoutProcessing() ;\n    }\n }\n\n function doSetTimeoutProcessing(){\n\n    setTimeout(doProcessing , 0) ;\n }\n\n function doProcessing(){\n\n    let [\n        process\n    ] = processQueue;\n\n    if(process){\n        \n        let {\n            socket,\n            action\n        } = process ;\n\n        let {\n            isDisconnected,\n            isConnected,\n            isDisconnecting,\n            isConnecting\n        } = socket;\n\n        if(previousSocket){\n\n            remove(previousSocket , {\n                lostconnect:doSetTimeoutProcessing,\n                disconnect:doSetTimeoutProcessing,\n                connect:doSetTimeoutProcessing\n            }) ;\n        }\n\n        if(isDisconnected || isConnected){\n\n            previousSocket = socket ;\n\n            processQueue.shift() ;\n\n            add(socket , 'lostconnect' , doSetTimeoutProcessing) ;\n\n            switch(action){\n\n                case 'connect':\n\n                    if(isDisconnected){\n\n                        add(socket , 'connect' , doSetTimeoutProcessing , {\n                            once:true\n                        }) ;\n\n                        socket.connect() ;\n                    \n                    }else{\n\n                        doSetTimeoutProcessing() ;\n                    }\n\n                    break ;\n\n                case 'disconnect':\n\n                    if(isConnected){\n\n                        add(socket , 'disconnect' , doSetTimeoutProcessing , {\n                            once:true\n                        }) ;\n\n                        socket.disconnect() ;\n                                            \n                    }else{\n\n                        doSetTimeoutProcessing() ;\n                    }\n            }\n        \n        }else if(isDisconnecting){\n\n            add(socket , 'disconnect' , doSetTimeoutProcessing , {\n                once:true\n            }) ;\n        \n        }else if(isConnecting){\n\n            add(socket , 'connect' , doSetTimeoutProcessing , {\n                once:true\n            }) ;\n        }\n    \n    }else{\n\n        previousSocket = null ;\n\n        isProcessorStarted = false ;\n    }\n }\n\n            var_class_1608956297855 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297855 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.socket.manager' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297855 ;\n        \nvar_global_main_1608956297855 = main;\n\n            var_init_locked_1608956297855 = true ;\n        }\n        \n    \n                        \n        if(var_once_value_1608956297855){\n\n            return var_once_value_1608956297855 ;\n\n        }\n        return var_once_value_1608956297855 = new var_global_main_1608956297855() ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.socket.manager"
  },
  "src::data.connection.deploy.module": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.connection.deploy.module(<object> connections , <object> module)",
    "standard": true,
    "importNames": [
      "src::function.empty",
      "src::data.connection.deploy.lifecycle"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let empty,deploy;\n    \n                    let var_init_locked_1608956297873;\n    \n                    \n\n                    function main(connections , module){\n\n        \n/**\n * \n * 基于数据连接的模块封装\n * \n * @import empty from function.empty value\n * \n * @import deploy from .lifecycle\n * \n * @param {object} connections 订阅对象\n * \n * @param {object} module 组件定义对象\n * \n * @return {object} 增加订阅功能的组件定义对象\n * \n */\n\n let {\n     mounted\n } = deploy(connections , module) ;\n\n mounted.call(module) ;\n\n return module ;\n\n    }\n    \n                    return function(connections , module){\n    \n                        \n        if(!var_init_locked_1608956297873){\n\n            empty = include('src::function.empty')();\ndeploy = include('src::data.connection.deploy.lifecycle');\n\n            var_init_locked_1608956297873 = true ;\n        }\n        \n    \n                        return main.call(this , connections , module) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.deploy.module"
  },
  "src::data.connection.deploy.react": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::data.connection.deploy.react(<object> connections , <object> componentClass)",
    "standard": false,
    "importNames": [
      "src::data.connection.deploy.lifecycle",
      "src::function.empty"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let deploy,empty;\n    \n                    let var_init_locked_1608956297877;\n    \n                    \n\n                    function main(connections , componentClass){\n\n        /**\n * \n * 基于数据连接的 React 封装\n * \n * @import deploy from .lifecycle\n * \n * @import empty from function.empty value\n * \n * @param {object} connections 订阅对象\n * \n * @param {object} componentClass 组件定义对象\n * \n * @return {mixed} 组件类引用\n * \n * @non-standard\n * \n */\n\nclass Component extends componentClass{\n\n    constructor(props){\n\n        super(props) ;\n\n        let me = this ;\n\n        let {\n            mounted,\n            unmounted\n        } = deploy(connections , me , function(){\n\n            return this.props.connectionId ;\n\n        }) ;\n\n        const {\n            componentDidMount:originMounted = empty,\n            componentWillUnmount:originUnmounted = empty\n         } = me;\n\n         me.componentDidMount = () =>{\n\n            mounted.call(me) ;\n           \n            originMounted.call(me) ;\n            \n         } ;\n\n         me.componentWillUnmount = () =>{\n\n            originUnmounted.call(me) ;\n    \n            unmounted.call(me) ;\n         } ;\n    }\n    \n} ;\n\nreturn props => <Component {...props}/> ;\n\n    }\n    \n                    return function(connections , componentClass){\n    \n                        \n        if(!var_init_locked_1608956297877){\n\n            deploy = include('src::data.connection.deploy.lifecycle');\nempty = include('src::function.empty')();\n\n            var_init_locked_1608956297877 = true ;\n        }\n        \n    \n                        return main.call(this , connections , componentClass) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.deploy.react"
  },
  "src::data.connection.deploy.vue": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.connection.deploy.vue(<object> connections , <object> component)",
    "standard": true,
    "importNames": [
      "src::function.empty",
      "src::data.connection.deploy.lifecycle"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let empty,deploy;\n    \n                    let var_init_locked_1608956297882;\n    \n                    \n\n                    function main(connections , component){\n\n        \n/**\n * \n * 基于数据连接的 VUE 封装\n * \n * @import empty from function.empty value\n * \n * @import deploy from .lifecycle\n * \n * @param {object} connections 订阅对象\n * \n * @param {object} component 组件定义对象\n * \n * @return {object} 增加订阅功能的组件定义对象\n * \n */\n\n let {\n     mounted,\n     unmounted\n } = deploy(connections , component , function(){\n\n    return this.connectionId ;\n\n }) ;\n\n const {\n    mounted:originMounted = empty,\n    destroyed:originUnmounted = empty,\n    ...options\n } = component;\n\n return {\n    mounted(){\n\n      let me = this ;\n\n      mounted.call(me) ;\n         \n      originMounted.call(me) ;\n    },\n\n    destroyed(){\n\n      let me = this ;\n\n      originUnmounted.call(me) ;\n\n      unmounted.call(me) ;\n      \n    },\n\n    ...options\n } ;\n\n    }\n    \n                    return function(connections , component){\n    \n                        \n        if(!var_init_locked_1608956297882){\n\n            empty = include('src::function.empty')();\ndeploy = include('src::data.connection.deploy.lifecycle');\n\n            var_init_locked_1608956297882 = true ;\n        }\n        \n    \n                        return main.call(this , connections , component) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.deploy.vue"
  },
  "src::data.connection.flow": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.flow(<data.connection.Mesage> message , <object> flows , <object> methods , <mixed> callback , <mixed> scoped)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::is.string",
      "src::is.function",
      "src::is.array",
      "src::is.promise",
      "src::is.defined",
      "src::id.generate",
      "src::function.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,isString,isFunction,isArray,isPromise,isDefined,generate,get;\n    \n                    let var_init_locked_1608956297886;\n    \n                    let var_class_1608956297886;\n    \n                    \n\n                    let var_global_main_1608956297886 ;\n    \n                    return function(message , flows , methods , callback , scoped){\n    \n                        \n        if(!var_init_locked_1608956297886){\n\n            isObject = include('src::is.object.simple');\nisString = include('src::is.string');\nisFunction = include('src::is.function');\nisArray = include('src::is.array');\nisPromise = include('src::is.promise');\nisDefined = include('src::is.defined');\ngenerate = include('src::id.generate');\nget = include('src::function.get');\n\n            /**\n * \n * 流程\n * \n * @import isObject from is.object.simple\n * \n * @import is.string\n * \n * @import is.function\n * \n * @import is.array\n * \n * @import is.promise\n * \n * @import is.defined\n * \n * @import generate from id.generate\n * \n * @import get from function.get\n * \n * @param {data.connection.Mesage} message 消息机\n * \n * @param {object} flows 流程定义\n * \n * @param {object} methods 流程节点定义\n * \n * @param {mixed} callback 回调函数\n * \n * @param {mixed} scoped 回调函数作用域\n * \n */\n\n class main{\n\n    constructor(message , flows , methods , context){\n\n        let me = this ;\n        \n        me.flows = flows ;\n\n        let currentMethods = me.methods = {},\n            innerContext = {},\n            {\n                next\n            } = me,\n            names =  me.methodNames = Object.keys(methods) ;\n\n        for(let name of names){\n\n            let method = methods[name] ;\n\n            if(isFunction(method)){\n\n                currentMethods[name] = ({\n                    data\n                }) => {\n\n                    let result = method.call(innerContext , data , context) ;\n\n                    if(isPromise(result)){\n\n                        result.then(next.bind(me , name)) ;\n                    \n                    }else{\n\n                        next.call(me , name , result) ;\n                    }\n\n                } ;\n            }\n        }\n\n        me.message = message ;\n\n        me.started = false ;\n    }\n\n    getFullAddress(name){\n\n        return `${name}<${this.flowId}>` ;\n    }\n\n    send(name , value){\n\n        let me = this,\n        {\n            message\n        } = me ;\n\n        message.send(me.getFullAddress(name) , value) ;\n    }\n\n    start(value , name = 'start'){\n\n        let me = this ;\n\n        let {\n            started\n        } = me ;\n\n        if(!started){\n\n            me.started = true ;\n\n            let {\n                methods\n            } = me ;\n\n            message.subscribes({\n                ...methods,\n                connectionId:me.flowId = generate('flow-')\n            }) ;\n\n            me.send(name , value) ;\n        \n        }else{\n\n            me.end() ;\n\n            me.start(value , name) ;\n        }\n    }\n\n    end(){\n\n        let me = this,\n        {\n            started\n        } = me;\n\n        if(started){\n\n            let {\n                message,\n                methodNames,\n                flowId\n            } = me ;\n    \n            message.unsubscribes(methodNames , flowId) ;\n    \n            me.started = false ;\n        }\n    }\n\n    next(name , value){\n\n        let me = this,\n        {\n            flows,\n            message\n        } = me,\n        next = flows[name];\n    \n        if(isString(next)){\n\n            me.send(next , value) ;\n        \n        }else if(isObject(next)){\n\n            let {\n                external,\n                next:from\n            } = next ;\n\n            message.send({\n                from:me.getFullAddress(from),\n                to:external\n            } , value) ;\n\n        }else if(isArray(next)){\n\n            let defaultNext ;\n\n            for(let {\n                value:caseValue,\n                type,\n                next:caseNext\n            } of next){\n\n                if(!isDefined(caseValue) && !isDefined(type)){\n\n                    defaultNext = caseNext ;\n\n                    continue ;\n                }\n\n                if(type){\n\n                    if(typeof value === type){\n\n                        me.send(caseNext , value) ;\n\n                        break ;\n                    }\n\n                    continue ;\n                }\n\n                if(caseValue === value){\n\n                    me.send(caseNext , value) ;\n\n                    break ;\n                }\n            }\n\n            if(defaultNext){\n\n                me.send(defaultNext , value) ;\n            }\n\n        }\n    }\n }\n\n            var_class_1608956297886 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297886 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.flow' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297886 ;\n        \nvar_global_main_1608956297886 = main;\n\n            var_init_locked_1608956297886 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956297886(message , flows , methods , callback , scoped) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.flow"
  },
  "src::promise.create.processive": {
    "meta": "code.meta.script.function",
    "signature": "<promise.Processive> src::promise.create.processive(<function> onInit , <function> onCancel)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::array.remove",
      "src::array.includes",
      "src::is.empty",
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction,remove,includes,isEmpty,isDefined;\n    \n                    let var_init_locked_1608956297896;\n    \n                    let var_class_1608956297896;\n    \n                    \n\n                    let var_global_main_1608956297896 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297896){\n\n            isFunction = include('src::is.function');\nremove = include('src::array.remove');\nincludes = include('src::array.includes');\nisEmpty = include('src::is.empty');\nisDefined = include('src::is.defined');\n\n            \n/**\n * \n * 创建持续性 Promise\n * \n * @import is.function\n * \n * @import remove from array.remove\n * \n * @import includes from array.includes\n * \n * @import is.empty\n * \n * @import is.defined\n * \n * @param {function} onInit 实始化 Promise 引用\n * \n * @param {function} onCancel 取消 Promise 时调用\n * \n * @class\n * \n * @return {promise.Processive} 持续性 Promise \n * \n */\n\n class main{\n\n    constructor(onInit , onCancel){\n\n        let me = this ;\n\n        me.resolveCallbacks = [] ;\n\n        me.rejectCallbacks = [] ;\n\n        let {\n            resolve,\n            reject\n        } = me ;\n\n       me.onCancelResult = onInit(resolve.bind(me) , reject.bind(me)) ;\n\n       me.onCancel = onCancel ;\n    }\n\n    async cancel(callback){\n\n        let {\n            onCancelResult,\n            onCancel,\n            resolveCallbacks\n        } = this ;\n\n        if(isFunction(callback)){\n\n            if(includes(resolveCallbacks , callback)){\n\n                remove(resolveCallbacks , callback) ;\n            }\n\n            if(isEmpty(resolveCallbacks)){\n\n                await onCancel(onCancelResult) ;\n            }\n        \n        }else{\n\n            await onCancel(onCancelResult) ;\n        }\n    }\n\n    resolve(data){\n\n        let {\n            resolveCallbacks\n        } = this;\n\n        for(let resolveCallback of resolveCallbacks){\n\n            let result = resolveCallback(data) ;\n\n            if(isDefined(result)){\n\n                data = result ;\n            }\n        }\n    }\n\n    reject(error){\n\n        let {\n            rejectCallbacks\n        } = this ;\n\n        for(let rejectCallback of rejectCallbacks){\n\n            rejectCallback(error) ;\n        }\n    }\n\n    then(callback){\n\n        let me = this,\n        {\n            resolveCallbacks\n        } = me;\n\n        resolveCallbacks.push(callback) ;\n\n        return me ;\n    }\n\n    catch(callback){\n\n        let me = this,\n        {\n            rejectCallbacks\n        } = me;\n\n        rejectCallbacks.push(callback) ;\n\n        return me ;\n    }\n }\n\n            var_class_1608956297896 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297896 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::promise.create.processive' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297896 ;\n        \nvar_global_main_1608956297896 = main;\n\n            var_init_locked_1608956297896 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297896 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "promise.create.processive"
  },
  "src::is.promise.processive": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.promise.processive(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::promise.create.processive"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let ProcessivePromise;\n    \n                    let var_init_locked_1608956297893;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判定是否为持续 Promise 对象\n * \n * @import ProcessivePromise from promise.create.processive value\n * \n * @param {mixed} data 数据\n * \n * @return {boolean}  如果为持续 Promise 对象，则返回 true , 否则返回 false \n * \n */\n\n return data instanceof ProcessivePromise ;\n \n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297893){\n\n            ProcessivePromise = include('src::promise.create.processive')();\n\n            var_init_locked_1608956297893 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.promise.processive"
  },
  "src::is.promise.native": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.promise.native(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断数据是否为原始 Promise 对象\n * \n * @param {mixed} data 测试数据\n * \n * @return {boolean} 如果是 Promise 则返回 true , 否则返回 false\n * \n */\n\n return data instanceof Promise ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.promise.native"
  },
  "src::is.promise": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.promise(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.promise.processive",
      "src::is.promise.native"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isProcessive,isNative;\n    \n                    let var_init_locked_1608956297891;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断数据是否为 Promise 对象\n * \n * @import isProcessive from .promise.processive\n * \n * @import isNative from .promise.native\n * \n * @param {mixed} data 测试数据\n * \n * @return {boolean} 如果是 Promise 则返回 true , 否则返回 false\n * \n */\n\n return isNative(data) || isProcessive(data);\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297891){\n\n            isProcessive = include('src::is.promise.processive');\nisNative = include('src::is.promise.native');\n\n            var_init_locked_1608956297891 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.promise"
  },
  "src::data.connection.message.address": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.message.address(<string> name , <object> options)",
    "standard": true,
    "importNames": [
      "src::data.Subscriber",
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Subscriber,isDefined;\n    \n                    let var_init_locked_1608956297901;\n    \n                    let var_class_1608956297901;\n    \n                    \n\n                    let var_global_main_1608956297901 ;\n    \n                    return function(name , options){\n    \n                        \n        if(!var_init_locked_1608956297901){\n\n            Subscriber = include('src::data.Subscriber')();\nisDefined = include('src::is.defined');\n\n            \n/**\n * \n * 消息地址\n * \n * @import Subscriber from data.Subscriber value\n * \n * @import is.defined\n * \n * @param {string} name 消息地址\n * \n * @param {object} options 消息配置\n * \n */\n\n class main extends Subscriber{\n\n    send(to , data){\n\n        let me = this ;\n\n        me.fireEvent('send' , {\n            from:me.name,\n            to,\n            data\n        }) ;\n    }\n\n    accept(data){\n\n        let me = this,\n            result = super.accept(data),\n            {\n                from\n            } = data;\n\n        if(from){\n\n            if(isDefined(result)){\n\n                if(result instanceof Promise){\n\n                    result.then(data => me.send(from , data)) ;\n                \n                }else{\n\n                    me.send(from , result) ;\n                }\n            }\n        }\n    }\n }\n\n \n\n            var_class_1608956297901 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297901 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.message.address' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297901 ;\n        \nvar_global_main_1608956297901 = main;\n\n            var_init_locked_1608956297901 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956297901(name , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.message.address"
  },
  "src::data.Subscriber.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.Subscriber.constructor(<data.connection> connection , <string> name , {<string> fullName , <function> processData , <object> listeners , <mixed> params , <boolean> autoOpen , <object> extraParams , <object> defaultParams , <function> fn , <boolean> once , <mixed> scope , <string> namespace , <function> processAcceptData , <function> cacheAcceptData , <function> getCacheData})",
    "standard": true,
    "importNames": [
      "src::function.get",
      "src::event.listener.add",
      "src::function.empty",
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,add,emptyFn,from;\n    \n                    let var_init_locked_1608956297909;\n    \n                    \n\n                    function main(connection , name , {fullName , processData , listeners , params , autoOpen , extraParams , defaultParams , fn , once , scope , namespace , processAcceptData , cacheAcceptData , getCacheData}){\n\n        /**\n * \n * 初始化订阅器\n * \n * @import get from function.get\n * \n * @import add from event.listener.add\n * \n * @import emptyFn from function.empty value\n * \n * @import from from array.from\n * \n * @param {data.connection} connection 当前订阅器所在的连接对象\n * \n * @param {string} name 订阅名称\n * \n * @param {object} config 订阅器配置\n * \n * @param {string} config.fullName 订阅器全称\n * \n * @param {function} [config.processData] 处理数据方法\n *  \n * @param {object} [config.listeners = {}] 来自古地外部事件监听\n * \n * @param {mixed} [config.params] 默认打开的订阅参数\n * \n * @param {boolean} [config.autoOpen = true] 是否自动打开订阅器\n * \n * @param {object} [config.extraParams = {}] 附加参数\n * \n * @param {object} [config.defaultParams = {}] 默认参数\n * \n * @param {function} config.fn 订阅函数\n * \n * @param {boolean} [config.once = false] 仅订阅一次即取消\n * \n * @param {mixed} [config.scope] 订阅函数作用域\n * \n * @param {string} [config.namespace] 命名空间\n * \n * @param {function} [config.processAcceptData] 处理接收数据的方法\n * \n * @param {function} [config.cacheAcceptData] 缓存接收数据方法\n * \n * @param {function} [config.getCacheData] 获取缓存数据 \n * \n */\n\n\nlet me = this ;\n\nme.name = name ;\n\nme.fullName = fullName ;\n\nme.connection = connection ;\n\nme.$bubbleTarget = connection ;\n\nme.processData = processData || (({\n    data\n}) => data) ;\n\nme.cacheAcceptData = cacheAcceptData ||  emptyFn;\n\nme.processAcceptData = processAcceptData || (data => data) ;\n\nme.getCacheData = getCacheData || (data => data) ;\n\nme.extraParams = extraParams ;\n\nme.defaultParams = defaultParams ;\n\nme.bindFn = get(fn , scope) || emptyFn;\n\nadd(me , {\n    ...listeners,\n    scope\n}) ;\n\nif(autoOpen){\n\n    me.open(params) ;\n}\n\nif(once === true){\n\n    add(me , 'data' , () => connection.unsubscribe(name , namespace) , {\n        once:true\n    }) ;\n}\n\n\n    }\n    \n                    return function(connection , name , {fullName , processData , listeners = {} , params , autoOpen = true , extraParams = {} , defaultParams = {} , fn , once = false , scope , namespace , processAcceptData , cacheAcceptData , getCacheData}){\n    \n                        \n        if(!var_init_locked_1608956297909){\n\n            get = include('src::function.get');\nadd = include('src::event.listener.add');\nemptyFn = include('src::function.empty')();\nfrom = include('src::array.from');\n\n            var_init_locked_1608956297909 = true ;\n        }\n        \n    \n                        return main.call(this , connection , name , {fullName , processData , listeners , params , autoOpen , extraParams , defaultParams , fn , once , scope , namespace , processAcceptData , cacheAcceptData , getCacheData}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.Subscriber.constructor"
  },
  "src::data.Subscriber.accept.data": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::data.Subscriber.accept.data(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956297915;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 将推送数据传递给绑定函数\n * \n * @import is.defined\n * \n * @param {mixed} data 推送过来的数据\n * \n * @return {mixed} 返回说明 \n * \n */\n\n let me = this,\n {\n    bindFn,\n    closed,\n    params,\n    cache,\n    getCacheData\n } = me ;\n\n if(!closed){\n\n   if(isDefined(cache)){\n\n      bindFn(getCacheData(cache) , params) ;\n   \n   }else{\n\n      bindFn(data , params) ;\n   }\n\n   me.fireEvent('data' , data , params) ;\n }\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297915){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956297915 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.Subscriber.accept.data"
  },
  "src::data.Subscriber.accept": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.Subscriber.accept(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.defined",
      "src::data.Subscriber.accept.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956297912;\n \n                    \n\n                    const var_current_scope_1608956297912 = new Map();\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297912){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956297912 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956297912.has(this)){\n\n            var_current_scope_1608956297912.set(this , (() => {\n                const setData = include('src::data.Subscriber.accept.data').bind(this);\n\n                function main(data){\n\n        \n/**\n * \n * 接收数据\n * \n * @import is.defined\n * \n * @import setData from .accept.data scoped\n * \n * @param {mixed} data 数据\n * \n * \n */\n\nlet me = this,\n{\n    closed,\n    cache,\n    processAcceptData,\n    cacheAcceptData\n} = me;\n\nif(closed){\n\n    return;\n}\n\ndata = processAcceptData(data) ;\n\nif(isDefined(data)){\n\n    me.cache = cacheAcceptData(data , cache) ;\n\n    setData(data) ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297912.get(this) ;\n\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.Subscriber.accept"
  },
  "src::data.Subscriber.reopen": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.Subscriber.reopen()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 重新打开订阅器\n * \n */\n\nlet me = this,\n{\n    closed,\n    params\n} = me ;\n\nif(!closed){\n\n    me.close() ;\n\n    me.open(params) ;\n}\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.Subscriber.reopen"
  },
  "src::data.Subscriber.open": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.Subscriber.open(<object> params)",
    "standard": true,
    "importNames": [
      "src::is.defined",
      "src::data.equals",
      "src::object.assign",
      "src::data.Subscriber.accept.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined,equals,assign;\n    \n                    let var_init_locked_1608956297920;\n \n                    \n\n                    const var_current_scope_1608956297920 = new Map();\n    \n                    return function(params = {}){\n    \n                        \n        if(!var_init_locked_1608956297920){\n\n            isDefined = include('src::is.defined');\nequals = include('src::data.equals');\nassign = include('src::object.assign');\n\n            var_init_locked_1608956297920 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956297920.has(this)){\n\n            var_current_scope_1608956297920.set(this , (() => {\n                const setData = include('src::data.Subscriber.accept.data').bind(this);\n\n                function main(params){\n\n        \n/**\n * \n * 打开订阅器\n * \n * @import is.defined\n * \n * @import equals from data.equals\n * \n * @import assign from object.assign\n * \n * @import setData from .accept.data scoped\n * \n * @param {object} [params = {}] 订阅参数\n * \n */\n\nlet me = this,\n{\n    name,\n    extraParams,\n    defaultParams,\n    params:oldParams,\n    connection\n} = me ;\n\nparams = assign({} , defaultParams , params , extraParams) ;\n\nif(!oldParams || !equals(params , oldParams)){\n\n    me.close() ;\n\n    me.params = params ;\n    \n    me.fireEvent('open' , params , oldParams) ;\n\n    let subscriber = connection.findOpenedSubscriberByName(name , me) ;\n\n    if(subscriber){\n\n        let {\n            cache\n        } = subscriber ;\n\n        if(isDefined(cache)){\n\n            me.cache = cahce ;\n\n            setData() ;\n        }\n    }\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297920.get(this) ;\n\n        \n    \n                        return main.call(this , params) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.Subscriber.open"
  },
  "src::data.Subscriber.close": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.Subscriber.close()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 关闭订阅器\n * \n */\n\nlet me = this,\n{\n    params,\n    closed\n} = me;\n\nif(closed){\n\n    return ;\n}\n\nme.prevParams = me.params ;\n\ndelete me.params ;\n\ndelete me.cache ;\n\nme.fireEvent('close' , params) ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.Subscriber.close"
  },
  "src::data.Subscriber.destroy": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.Subscriber.destroy()",
    "standard": true,
    "importNames": [
      "src::event.listener.remove.all"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let removeAll;\n    \n                    let var_init_locked_1608956297925;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 销毁\n * \n * @import removeAll from event.listener.remove.all\n * \n */\n\nlet me = this,\n{\n    connection\n} = me;\n\nme.close() ;\n\ndelete me.bindFn ;\n\ndelete me.extraParams ;\n\ndelete me.defaultParams ;\n\nme.fireEvent('destroy') ;\n\nremoveAll(me) ;\n\nconnection.subscribers.delete(me.fullName) ;\n\ndelete me.fullName ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297925){\n\n            removeAll = include('src::event.listener.remove.all');\n\n            var_init_locked_1608956297925 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.Subscriber.destroy"
  },
  "src::data.Subscriber": {
    "meta": "code.meta.class",
    "signature": "<void> src::data.Subscriber()",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::class.empty",
      "src::data.Subscriber.constructor",
      "src::data.subscriber.closed",
      "src::data.subscriber.open.prev",
      "src::data.Subscriber.accept",
      "src::data.Subscriber.reopen",
      "src::data.Subscriber.open",
      "src::data.Subscriber.close",
      "src::data.Subscriber.destroy",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let mixin_1608956297904__1,extend,constructor,get_closed,method_prevOpen,method_accept,method_reopen,method_open,method_close,method_destroy,isObject;\n    \n                    let var_init_locked_1608956297904;\n    \n                    let var_class_1608956297904;\n    \n                    \n\n                    let var_global_main_1608956297904 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297904){\n\n            mixin_1608956297904__1 = include('src::mixin.observable');\nextend = include('src::class.empty')();\nconstructor = include('src::data.Subscriber.constructor');\nget_closed = include('src::data.subscriber.closed');\nmethod_prevOpen = include('src::data.subscriber.open.prev');\nmethod_accept = include('src::data.Subscriber.accept');\nmethod_reopen = include('src::data.Subscriber.reopen');\nmethod_open = include('src::data.Subscriber.open');\nmethod_close = include('src::data.Subscriber.close');\nmethod_destroy = include('src::data.Subscriber.destroy');\nisObject = include('src::is.object.simple');\n\n            class main extends mixins({extend , mixins:[include('mixin.observable')]}){\n\n            \n\n            \n\n            constructor(...args){\n\n            super(...args) ;\n\n            constructor.apply(this , args) ;\n\n        }\n\n            prevOpen(...args){\n\n            return method_prevOpen.apply(this , args) ;\n\n        }\naccept(...args){\n\n            return method_accept.apply(this , args) ;\n\n        }\nreopen(...args){\n\n            return method_reopen.apply(this , args) ;\n\n        }\nopen(...args){\n\n            return method_open.apply(this , args) ;\n\n        }\nclose(...args){\n\n            return method_close.apply(this , args) ;\n\n        }\ndestroy(...args){\n\n            return method_destroy.apply(this , args) ;\n\n        }\n\n            get closed(){\n\n                return get_closed.call(this) ;\n    \n            }\n\n        }\n\n            var_class_1608956297904 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297904 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.Subscriber' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297904 ;\n        \nvar_global_main_1608956297904 = main;\n\n            var_init_locked_1608956297904 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297904 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.Subscriber"
  },
  "src::data.connection.message": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.message()",
    "standard": true,
    "importNames": [
      "src::data.connection",
      "src::is.object.simple",
      "src::is.string",
      "src::data.connection.message.address",
      "src::is.defined",
      "src::object.assign",
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Connection,isObject,isString,createAddress,isDefined,assign,from;\n    \n                    let var_init_locked_1608956297929;\n    \n                    let var_class_1608956297929;\n    \n                    \n\n                    let var_global_main_1608956297929 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297929){\n\n            Connection = include('src::data.connection')();\nisObject = include('src::is.object.simple');\nisString = include('src::is.string');\ncreateAddress = include('src::data.connection.message.address');\nisDefined = include('src::is.defined');\nassign = include('src::object.assign');\nfrom = include('src::array.from');\n\n            /**\n * \n * 消息订阅\n * \n * @import Connection from data.connection value\n * \n * @import isObject from is.object.simple\n * \n * @import is.string\n * \n * @import createAddress from data.connection.message.address\n * \n * @import is.defined\n * \n * @import assign from object.assign\n * \n * @import from from array.from\n * \n * @singleton\n * \n */\n\n const exactAddressRe = /^[^<>]+<[^<>]+>$/ ;\n\n class main extends Connection{\n\n    constructor(){\n\n        super({\n            subscriber:createAddress\n        }) ;\n\n        this.resendMessages = [] ;\n    }\n\n    processMessage(message){\n\n        return message ;\n    }\n\n    processData(subscriber , {\n        from,\n        data\n    }){\n\n        return {\n            from,\n            data\n        } ;\n    }\n\n    hasAddress(name){\n\n        let {\n            subscribers\n        } = this ;\n\n        return subscribers.has(name) ;\n    }\n\n    validateMessage({\n        name\n    },{\n        to\n    }){\n\n        return to.test(name) ;\n    }\n\n    get subscriberListeners(){\n\n        return {\n            ...super.subscriberListeners,\n            send:'onMessageSend'\n        } ;\n    }\n\n    onMessageSend(address , message){\n\n        this.send(message) ;\n    }\n\n    onCreateSubscriber(){\n\n        let me = this,{\n            resendMessages\n        } = me,\n        messages = from(resendMessages);\n\n        resendMessages.length = 0 ;\n\n        for(let message of messages){\n\n            me.send(message) ;\n        }\n    }\n\n    send(address , data){\n\n        if(isString(address)){\n\n            address = {\n                to:address,\n                data\n            } ;\n        }\n\n        if(isObject(address)){\n\n            if(!address.hasOwnProperty('data')){\n\n                address = {\n                    ...address,\n                    data\n                } ;\n            }\n\n            address.getResendMessages = address.getResendMessages || default_get_resend_messages ;\n\n            let {\n                to,\n                getResendMessages\n            } = address ;\n\n            if(isString(to)){\n\n                if(exactAddressRe.test(to)){\n\n                    to = new RegExp(to) ;\n                \n                }else{\n    \n                    to = new RegExp(`^${to}(?:<[^<>]+>)?$`) ;\n                }\n            }\n\n            if(to instanceof RegExp){\n\n                address.to = to ;\n\n                let {\n                        reSendMessages\n                    } = this;\n\n                reSendMessages.push(...from(getResendMessages(address , me.acceptMessage(address)))) ;\n            }\n        }\n    }\n }\n\n function default_get_resend_messages(message , subscribers){\n\n    if(subscribers.length !== 0){\n\n        return message ;\n    }\n }\n\n            var_class_1608956297929 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297929 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.message' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297929 ;\n        \nvar_global_main_1608956297929 = main;\n\n            var_init_locked_1608956297929 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956297929() ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.message"
  },
  "src::data.connection.socket.io": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.socket.io()",
    "standard": true,
    "importNames": [
      "src::data.connection.socket",
      "src::event.listener.add",
      "src::socket.io.ws",
      "src::data.connection.socket.manager",
      "src::event.listener.remove.all"
    ],
    "dependentModules": {
      "socket.io-client": "2.3.0"
    },
    "data": "(() =>{\n\n                    let Connection,add,getWS,Manager,removeAll;\n    \n                    let var_init_locked_1608956297937;\n    \n                    let var_class_1608956297937;\n    \n                    \n\n                    let var_global_main_1608956297937 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297937){\n\n            Connection = include('src::data.connection.socket')();\nadd = include('src::event.listener.add');\ngetWS = include('src::socket.io.ws');\nManager = include('src::data.connection.socket.manager')();\nremoveAll = include('src::event.listener.remove.all');\n\n            /**\n * \n * 基于 socket.io 标准进行开发\n * \n * @import Connection from data.connection.socket value\n * \n * @import add from event.listener.add\n * \n * @import getWS from socket.io.ws\n * \n * @import Manager from .manager value\n * \n * @import removeAll from event.listener.remove.all\n * \n * @require socket.io-client\n * \n * @class\n * \n */\n\n const IO = require('socket.io-client') ;\n\n class main extends Connection{\n\n    initialize(url , options){\n\n       let me = this ;\n\n       me.socketURL = url ;\n\n       me.socketOptions = options ;\n    }\n\n    get socket(){\n\n        let {\n            io\n        } = this ;\n\n        if(io){\n\n            return getWS(this.io) ;\n        }\n    }\n\n    onSocketTimeout(){\n\n        this.fireEvent('connecttimeout') ;\n    }\n\n    onSocketMessage(...args){\n\n        this.acceptMessage(...args) ;\n    }\n\n    onSocketDisconnect(){\n\n        let me = this,\n            {\n                isDisconnected,\n                socket\n            } = me ;\n\n        if(!isDisconnected && socket){\n\n            add(socket , 'close' , 'onSocketDisconnect' , {\n                scope:me,\n                once:true\n            }) ;\n        \n        }else{\n\n            let me = this,\n            {\n                disconnectingState,\n                io\n            } = me ;\n\n            removeAll(io) ;\n\n            delete me.io ;\n\n            delete me.disconnectingState ;\n\n            if(disconnectingState){\n\n                me.fireEvent('disconnect') ;\n            \n            }else{\n\n                me.fireEvent('lostconnect') ;\n            }\n        }\n    }\n\n    onSocketError(){\n\n        let me = this,\n        {\n            isDisconnected,\n            onSocketError\n        } = me;\n\n        if(isDisconnected){\n\n            me.onSocketDisconnect() ;\n        \n        }else{\n\n            setTimeout(onSocketError.bind(me) , 0) ;\n        }\n    }\n\n    onSocketConnect(){\n\n        this.fireEvent('connect') ;\n    }\n\n    doConnect(){\n\n        let me = this,\n        {\n            socketURL,\n            socketOptions,\n            messageEventName,\n            subscribeResponseEventName\n        } = me;\n\n        add(me.io = IO(socketURL , {\n            forceNew: true,\n            transports: [\n                'websocket'\n            ],\n            reconnection:false,\n            ...socketOptions\n        }) , {\n            connect_error:'onSocketError',\n            connect:'onSocketConnect',\n            disconnect:'onSocketDisconnect',\n            connect_timeout:'onSocketTimeout',\n            [messageEventName]:'onSocketMessage',\n            [subscribeResponseEventName]:'onSocketSubscribeResponse',\n            scope:me\n        }) ;\n    }\n\n    onSocketSubscribeResponse(){\n\n\n    }\n\n    doDisconnect(){\n\n        this.io.disconnect() ;\n    }\n\n    get subscribeEventName(){\n\n        return 'sub'\n    }\n\n    get messageEventName(){\n\n        return 'msg' ;\n    }\n\n\n    get subscribeResponseEventName(){\n\n        return 'subresp' ;\n    }\n\n    get unsubscribeEventName(){\n\n        return 'unsub' ;\n    }\n\n    emit(event , ...params){\n\n        let me = this,\n        {\n            isConnected,\n            io\n        } = me ;\n\n        if(isConnected){\n\n            io.emit(event , ...params) ;\n        }\n        \n    }\n\n    doSubscriberOpen(...args){\n\n        let me = this,\n        {\n            subscribeEventName\n        } = me ;\n\n        me.emit(subscribeEventName , ...args) ;\n    }\n\n    doSubscriberClose(...args){\n\n        let me = this,\n        {\n            unsubscribeEventName\n        } = me ;\n\n        me.emit(unsubscribeEventName , ...args) ;\n    }\n }\n\n            var_class_1608956297937 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297937 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.socket.io' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297937 ;\n        \nvar_global_main_1608956297937 = main;\n\n            var_init_locked_1608956297937 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297937 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.socket.io"
  },
  "src::socket.io.ws": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::socket.io.ws(<mixed> socket)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(socket){\n\n        \n/**\n * \n * 获取 socket.io 内置的 socket 原生对象\n * \n * @param {mixed} socket socket.io 对象\n * \n * @return {mixed} 原生 socket 对象 \n * \n */\n\n let {\n    engine\n } = socket.io ;\n\n if(engine){\n\n    return engine.transport.ws ;\n }\n\n    }\n    \n                    return function(socket){\n    \n                        \n    \n                        return main.call(this , socket) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "socket.io.ws"
  },
  "src::data.connection.socket.standard.miniprogram": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.socket.standard.miniprogram()",
    "standard": true,
    "importNames": [
      "src::data.connection.socket.standard",
      "src::miniprogram.socket"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Connection,WebSocket;\n    \n                    let var_init_locked_1608956297943;\n    \n                    let var_class_1608956297943;\n    \n                    \n\n                    let var_global_main_1608956297943 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297943){\n\n            Connection = include('src::data.connection.socket.standard')();\nWebSocket = include('src::miniprogram.socket')();\n\n            /**\n * \n * 基于小程序进行开发\n * \n * @import Connection from data.connection.socket.standard value\n *\n * @import WebSocket from miniprogram.socket value\n * \n * @class\n * \n */\n\n class main extends Connection{\n\n    get WebSocket(){\n\n        return WebSocket ;\n    }\n }\n\n            var_class_1608956297943 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297943 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.socket.standard.miniprogram' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297943 ;\n        \nvar_global_main_1608956297943 = main;\n\n            var_init_locked_1608956297943 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297943 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.socket.standard.miniprogram"
  },
  "src::is.url.absolute": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.url.absolute(<string> url)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(url){\n\n        \n/**\n * \n * 判断当前链接是否为绝对路径\n * \n * @param {string} url 链接路径\n * \n * @return {boolean} 如果链接为绝对路径则返回 true , 否则返回 false\n * \n */\n\nreturn /^https?\\:\\/{2}/.test(url) ;\n\n\n    }\n    \n                    return function(url){\n    \n                        \n    \n                        return main.call(this , url) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.url.absolute"
  },
  "src::url.join": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::url.join(<string[]> ...urls)",
    "standard": true,
    "importNames": [
      "src::is.url.absolute"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isAbsolute;\n    \n                    let var_init_locked_1608956297952;\n    \n                    \n\n                    /**\n * \n * 将多个链接进行拼接并返回\n * \n * @import isAbsolute from is.url.absolute\n * \n * @param {string[]} [...urls] 多个 URL 链接\n * \n * @return {string} 拼接后的拼接\n * \n * @scoped\n * \n */\n\nconst urlSuffixRe = /^\\/|\\/$/ ;\n\nfunction main(...urls){\n\n    let len = urls.length,\n        i = 0,\n        result = [];\n\n    for(; i < len ; i ++){\n\n        let part = urls[i] || '';\n\n        part = part.replace(urlSuffixRe , '') ;\n\n        if(isAbsolute(part)){\n\n            result.length = 0 ;\n\n            result.push(part) ;\n        \n        }else if(part){\n\n            result.push(part) ;\n        }\n    }\n\n    return result.join('/') ;\n}\n\n\n\n\n    \n                    return function(...urls){\n    \n                        \n        if(!var_init_locked_1608956297952){\n\n            isAbsolute = include('src::is.url.absolute');\n\n            var_init_locked_1608956297952 = true ;\n        }\n        \n    \n                        return main.call(this , ...urls) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "url.join"
  },
  "src::timer.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::timer.constructor({<number> interval , <number> duration , <boolean> autoStart})",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main({interval , duration , autoStart}){\n\n        \n/**\n * \n * 初始化计时器\n * \n * @param {object} [config = {}] 参数\n * \n * @param {number} [config.interval = 1000] time 触发周期时长，默认为一秒种 \n * \n * @param {number} [config.duration = 60000] 计时时长，默认为一分钟\n * \n * @param {boolean} [config.autoStart = true] 是否自动启动，默认为自动启动\n * \n */\n\nlet me = this ;\n\nme.interval = interval ;\n\nme.duration = duration ;\n\nif(autoStart){\n\n    me.start() ;\n}\n\n    }\n    \n                    return function({interval = 1000 , duration = 60000 , autoStart = true} = {}){\n    \n                        \n    \n                        return main.call(this , {interval , duration , autoStart}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "timer.constructor"
  },
  "src::timer.reset": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::timer.reset()",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956297969;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 重置\n * \n * @import is.defined\n * \n */\n\n let me = this,\n {\n    intervalId\n } = me ;\n\n if(isDefined(intervalId)){\n\n    clearInterval(intervalId) ;\n\n    clearTimeout(intervalId) ;\n\n    delete me.intervalId ;\n\n    delete me.onInterval ;\n }\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297969){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956297969 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "timer.reset"
  },
  "src::timer.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::timer.end()",
    "standard": true,
    "importNames": [
      "src::timer.reset"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956297967 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956297967.has(this)){\n\n            var_current_scope_1608956297967.set(this , (() => {\n                const reset = include('src::timer.reset').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 结束计时\n * \n * @import reset from .reset scoped\n *\n */\n\n reset() ;\n \n this.fireEvent('timeend') ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297967.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "timer.end"
  },
  "src::timer.start": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::timer.start()",
    "standard": true,
    "importNames": [
      "src::is.number",
      "src::timer.end",
      "src::timer.reset"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isNumber,reset;\n    \n                    let var_init_locked_1608956297964;\n \n                    \n\n                    const var_current_scope_1608956297964 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297964){\n\n            isNumber = include('src::is.number');\nreset = include('src::timer.reset');\n\n            var_init_locked_1608956297964 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956297964.has(this)){\n\n            var_current_scope_1608956297964.set(this , (() => {\n                const end = include('src::timer.end').bind(this);\n\n                \n/**\n * \n * 启动计时\n * \n * @import is.number\n * \n * @import end from .end scoped\n * \n * @import reset from .reset\n * \n */\n\nfunction onInterval(duration , startTime){\n\n    let me = this,\n    {\n        interval,\n        onInterval\n    } = me,\n    remainDuration = duration - (Date.now() - startTime) ;\n\n    if(remainDuration > 0){\n    \n        me.fireEvent('time') ;\n\n        if(remainDuration < interval){\n\n            reset.call(me) ;\n\n            me.intervalId = setTimeout(onInterval , remainDuration) ;\n        }\n    \n    }else{\n\n        reset.call(me) ;\n\n        me.fireEvent('timeout') ;\n    }\n }\n\nfunction main(){\n\n    let me = this,\n    {\n        interval,\n        duration\n    } = me;\n\n    end() ;\n\n    me.fireEvent('timestart') ;\n\n    me.intervalId = setInterval(me.onInterval = onInterval.bind(me , duration , Date.now()) , interval) ;\n}\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956297964.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "timer.start"
  },
  "src::timer": {
    "meta": "code.meta.class",
    "signature": "<void> src::timer(<mixed> config)",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::class.empty",
      "src::timer.constructor",
      "src::timer.start",
      "src::timer.end",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let mixin_1608956297959__1,extend,constructor,method_start,method_end,isObject;\n    \n                    let var_init_locked_1608956297959;\n    \n                    let var_class_1608956297959;\n    \n                    \n\n                    let var_global_main_1608956297959 ;\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956297959){\n\n            mixin_1608956297959__1 = include('src::mixin.observable');\nextend = include('src::class.empty')();\nconstructor = include('src::timer.constructor');\nmethod_start = include('src::timer.start');\nmethod_end = include('src::timer.end');\nisObject = include('src::is.object.simple');\n\n            class main extends mixins({extend , mixins:[include('mixin.observable')]}){\n\n            \n\n            \n\n            constructor(...args){\n\n            super(...args) ;\n\n            constructor.apply(this , args) ;\n\n        }\n\n            start(...args){\n\n            return method_start.apply(this , args) ;\n\n        }\nend(...args){\n\n            return method_end.apply(this , args) ;\n\n        }\n\n            \n\n        }\n\n            var_class_1608956297959 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297959 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::timer' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297959 ;\n        \nvar_global_main_1608956297959 = main;\n\n            var_init_locked_1608956297959 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956297959(config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "timer"
  },
  "src::data.connection.socket.standard": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.socket.standard()",
    "standard": true,
    "importNames": [
      "src::data.connection.socket",
      "src::url.join",
      "src::timer",
      "src::event.listener.add",
      "src::event.listener.remove.all",
      "src::data.connection.socket.manager",
      "src::function.empty"
    ],
    "dependentModules": {
      "ws": "^7.1.2"
    },
    "data": "(() =>{\n\n                    let Connection,join,createTimer,add,removeAll,Manager,emptyFn;\n    \n                    let var_init_locked_1608956297947;\n    \n                    let var_class_1608956297947;\n    \n                    \n\n                    let var_global_main_1608956297947 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297947){\n\n            Connection = include('src::data.connection.socket')();\njoin = include('src::url.join');\ncreateTimer = include('src::timer');\nadd = include('src::event.listener.add');\nremoveAll = include('src::event.listener.remove.all');\nManager = include('src::data.connection.socket.manager')();\nemptyFn = include('src::function.empty')();\n\n            /**\n * \n * 标准推送\n * \n * @import Connection from data.connection.socket value\n * \n * @import join from url.join\n * \n * @import createTimer from timer\n * \n * @import add from event.listener.add\n * \n * @import removeAll from event.listener.remove.all\n * \n * @import Manager from .manager value\n * \n * @import emptyFn from function.empty value\n * \n * @require ws\n * \n * @class\n * \n * \n */\n\n const WebSocket = require('ws');\n\n class main extends Connection{\n\n    initialize(url , {\n        path,\n        timeout = 20000\n    }){\n\n        let me = this ;\n        \n        if(path){\n\n            url = join(url , path) ;\n        }\n\n        me.socketURL = url ;\n\n        me.socketTimeoutTimer = createTimer({\n            duration:timeout,\n            autoStart:false,\n            listeners:{\n                timeout:'onSocketTimeout',\n                scope:me\n            }\n        }) ;\n    }\n\n    onSocketTimeout(){\n\n        this.fireEvent('connecttimeout') ;\n    }\n\n    onSocketOpen(){\n\n        let me = this,\n        {\n            socketTimeoutTimer\n        } = me;\n\n        socketTimeoutTimer.end() ;\n\n        me.fireEvent('connect') ;\n    }\n\n    onSocketError(){\n\n        let me = this,\n        {\n            socket,\n            socketTimeoutTimer\n        } = me;\n\n        socketTimeoutTimer.end() ;\n\n        removeAll(socket) ;\n\n        delete me.socket ;\n\n        delete me.disconnectingState ;\n\n        me.fireEvent('lostconnect') ;\n    }\n\n    onSocketClose(){\n\n        let me = this,\n        {\n            socket,\n            socketTimeoutTimer,\n            disconnectingState\n        } = me;\n\n        socketTimeoutTimer.end() ;\n\n        removeAll(socket) ;\n\n        delete me.socket ;\n\n        delete me.disconnectingState ;\n\n        if(disconnectingState){\n\n            me.fireEvent('disconnect') ;\n        \n        }else{\n\n            me.fireEvent('lostconnect') ;\n        }\n    }\n\n    onSocketMessage({\n        data\n    }){\n\n        this.acceptMessage(data) ;\n    }\n\n    doConnect(){\n\n        let me = this,\n        {\n            socketTimeoutTimer,\n            socketURL\n        } = me ;\n\n        socketTimeoutTimer.start() ;\n\n        add(me.socket = new WebSocket(socketURL) , {\n            open:'onSocketOpen',\n            close:'onSocketClose',\n            error:'onSocketError',\n            message:'onSocketMessage',\n            scope:me\n        }) ;\n    }\n\n    doDisconnect(){\n\n        this.socket.close() ;\n    }\n\n    send(message){\n\n        let me = this,\n        {\n            socket,\n            isConnected\n        } = me ;\n\n        if(isConnected){\n\n            socket.send(message) ;\n        }\n    }\n }\n\n\n            var_class_1608956297947 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297947 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.socket.standard' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297947 ;\n        \nvar_global_main_1608956297947 = main;\n\n            var_init_locked_1608956297947 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297947 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.socket.standard"
  },
  "src::miniprogram.socket": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::miniprogram.socket()",
    "standard": true,
    "importNames": [
      "src::function.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956297972;\n    \n                    let var_class_1608956297972;\n    \n                    \n\n                    let var_global_main_1608956297972 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297972){\n\n            get = include('src::function.get');\n\n            \n/**\n * \n * 小程序 socket 类实现\n * \n * @import get from function.get\n * \n * @class\n *\n */\n\n const EventEmitter = require('events') ;\n\n function onOpen(){\n\n    this.emit('open') ;\n }\n\n function onMessage({\n     data\n }){\n\n    this.emit('message' , data) ;\n }\n\n function onError(){\n\n    this.emit('error') ;\n }\n\n function onClose(){\n\n    this.emit('close') ;\n }\n\n function on(name , fn){\n\n    let me = this ;\n\n    me.removeAllListeners(name) ;\n\n    me.on(name , fn) ;\n }\n\n class main extends EventEmitter{\n\n    constructor(url , protocols){\n\n        super() ;\n\n        let socket = wx.connectSocket({\n            url,\n            protocols\n        }),\n        me = this;\n\n        socket.onOpen(get(onOpen , me)) ;\n\n        socket.onMessage(get(onMessage , me)) ;\n\n        socket.onError(get(onError , me)) ;\n\n        socket.onClose(get(onClose , me)) ;\n\n        me.socket = socket ;\n    }\n\n    get readyState(){\n\n        return this.socket.readyState ;\n    }\n\n    set onopen(fn){\n\n        on.call(this , 'open' , fn) ;\n    }\n\n    set onmessage(fn){\n\n        on.call(this , 'message' , fn) ;\n    }\n\n    set onerror(fn){\n\n        on.call(this , 'error' , fn) ;\n    }\n\n    set onclose(fn){\n\n        on.call(this , 'close' , fn) ;\n    }\n\n    send(data){\n\n        this.socket.send({\n            data\n        }) ;\n    }\n\n    close(){\n\n        this.socket.close() ;\n    }\n\n }\n\n            var_class_1608956297972 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297972 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::miniprogram.socket' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297972 ;\n        \nvar_global_main_1608956297972 = main;\n\n            var_init_locked_1608956297972 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297972 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "miniprogram.socket"
  },
  "src::data.connection.socket.standard.normal": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.connection.socket.standard.normal()",
    "standard": true,
    "importNames": [
      "src::data.connection.socket.standard"
    ],
    "dependentModules": {
      "ws": "^7.1.2"
    },
    "data": "(() =>{\n\n                    let Connection;\n    \n                    let var_init_locked_1608956297975;\n    \n                    let var_class_1608956297975;\n    \n                    \n\n                    let var_global_main_1608956297975 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956297975){\n\n            Connection = include('src::data.connection.socket.standard')();\n\n            /**\n * \n * 基于标准 WebSocket 进行开发\n * \n * @import Connection from data.connection.socket.standard value\n * \n * @require ws\n * \n * @class\n * \n */\n\n const WebSocket = require('ws') ;\n\n class main extends Connection{\n\n    get WebSocket(){\n\n        return WebSocket ;\n    }\n\n    \n }\n\n            var_class_1608956297975 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956297975 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.connection.socket.standard.normal' ;\n                }\n\n            } ;\n\n            main = var_class_1608956297975 ;\n        \nvar_global_main_1608956297975 = main;\n\n            var_init_locked_1608956297975 = true ;\n        }\n        \n    \n                        return var_global_main_1608956297975 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.connection.socket.standard.normal"
  },
  "src::data.convert.boolean": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::data.convert.boolean(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.boolean",
      "src::is.string",
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isBoolean,isString,isNumber;\n    \n                    let var_init_locked_1608956297977;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 将指定数据转换成布尔型\n * \n * @import is.boolean\n * \n * @import is.string\n * \n * @import is.number\n *\n * @param {mixed} data 数据\n * \n * @return {boolean} 转换后的布尔型 \n * \n */\n\n if(isBoolean(data)){\n\n    return data ;\n \n }else if(isString(data)){\n\n    switch(data){\n\n        case 'true':\n\n            return true ;\n\n        case 'false':\n\n            return false ;\n    }\n    \n }else if(isNumber(data)){\n\n    return Boolean(data) ;\n }\n\n return data !== undefined && data !== null ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956297977){\n\n            isBoolean = include('src::is.boolean');\nisString = include('src::is.string');\nisNumber = include('src::is.number');\n\n            var_init_locked_1608956297977 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.convert.boolean"
  },
  "src::data.convert.date": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::data.convert.date(<mixed> data , {<string> format})",
    "standard": true,
    "importNames": [
      "src::is.number",
      "src::is.string",
      "src::date.parse"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isNumber,isString,parse;\n    \n                    let var_init_locked_1608956297980;\n    \n                    \n\n                    function main(data , {format}){\n\n        \n/**\n * \n * 将指定数据转换成日期对象\n * \n * @import is.number\n * \n * @import is.string\n * \n * @import parse from date.parse\n * \n * @param {mixed} data 数据\n * \n * @param {object} [config = {}] 配置\n * \n * @param {string} [config.format] 日期格式字符串\n * \n * @return {Date} 转换后的日期对象\n * \n */\n\n if(isNumber(data)){\n\n    return new Date(data) ;\n }\n\n if(isString(data)){\n\n    if(/^\\d+$/.test(data)){\n\n      return new Date(Number(data)) ;\n\n    }else if(/^\\d{4}\\-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:[\\d\\.]+Z$/.test(data)){\n\n      return new Date(data) ;\n    }\n\n    return parse(data , format) ;\n }\n\n return null ;\n\n    }\n    \n                    return function(data , {format} = {}){\n    \n                        \n        if(!var_init_locked_1608956297980){\n\n            isNumber = include('src::is.number');\nisString = include('src::is.string');\nparse = include('src::date.parse');\n\n            var_init_locked_1608956297980 = true ;\n        }\n        \n    \n                        return main.call(this , data , {format}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.convert.date"
  },
  "src::string.format": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::string.format(<string> format , <mixed> ...args)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    \n/**\n * \n * 字符串格式化\n * \n * @param {string} format 格式字符串\n * \n * @param {mixed} [...args] 格式参数\n * \n * @return {string} 格式化后的字符串 \n * \n */\n\n let formatRe = /\\{(\\d+)\\}/g ;\n\n function main(format , ...args){\n\n    return format.replace(formatRe , (match , index) => args[index]) ;\n }\n    \n                    return function(format , ...args){\n    \n                        \n    \n                        return main.call(this , format , ...args) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "string.format"
  },
  "src::date.parse": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::date.parse(<string> data , <string> format)",
    "standard": true,
    "importNames": [
      "src::string.format"
    ],
    "dependentModules": {
      "date-and-time": "^0.11.0"
    },
    "data": "(() =>{\n\n                    let doFormat;\n    \n                    let var_init_locked_1608956297986;\n    \n                    \n\n                    /**\n * \n * 将字符串转换成日期\n * \n * @import doFormat from string.format\n * \n * @param {string} data 字符串\n * \n * @param {string} [format = 'YYYY-MM-DD'] 日期格式\n * \n * @return {Date} 日期对象 \n * \n * @require date-and-time\n * \n */\n\nconst {\n   parse\n} = require('date-and-time') ;\n\nfunction main(data , format){\n\n   return parse(data , format) ;\n}\n\n \n    \n                    return function(data , format = 'YYYY-MM-DD'){\n    \n                        \n        if(!var_init_locked_1608956297986){\n\n            doFormat = include('src::string.format');\n\n            var_init_locked_1608956297986 = true ;\n        }\n        \n    \n                        return main.call(this , data , format) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.parse"
  },
  "src::data.convert.number": {
    "meta": "code.meta.script.function",
    "signature": "<number|string> src::data.convert.number(<mixed> data , {<number> digit , <string> keepMode , <boolean> keepDigitRightZero})",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.date",
      "src::math.round",
      "src::math.truncation",
      "src::math.digit",
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isDate,round,truncation,getDigit,isNumber;\n    \n                    let var_init_locked_1608956297991;\n    \n                    \n\n                    function main(data , {digit , keepMode , keepDigitRightZero}){\n\n        \n/**\n * \n * 将指定数据转换成数值\n * \n * @import is.string\n * \n * @import is.date\n * \n * @import round from math.round\n * \n * @import truncation from math.truncation\n * \n * @import getDigit from math.digit\n * \n * @import is.number\n * \n * @param {mixed} data 数据\n * \n * @param {object} [config = {}] 配置\n * \n * @param {number} [config.digit = 0] 保留的小数点位数\n * \n * @param {string} [config.keepMode = 'round'] 保留小数法\n * \n * @param {boolean} [config.keepDigitRightZero = false] 是否保留小数点左边的\n * \n * @return {number|string} 转换后的数值 \n * \n */\n\n if(isString(data)){\n\n    data = Number(data) ;\n }\n\n if(isDate(data)){\n\n    data = data.getTime() ;\n }\n\n if(isNumber(data)){\n\n    switch(keepMode){\n\n        case 'round':\n\n            data = round(data , digit) ;\n\n        case 'truncation':\n\n            data = truncation(data , digit) ;\n    }\n\n    if(keepDigitRightZero){\n\n      let realDigit = getDigit(data) ;\n\n      data = String(data) ;\n\n      if(realDigit < digit){\n\n         return data.padEnd(data.length + (digit - realDigit) , '0') ;\n      }\n\n      return data ;\n    }\n\n    return data ;\n\n }\n\n const {\n    NEGATIVE_INFINITY,\n    POSITIVE_INFINITY\n } = Number ;\n\n if(data === NEGATIVE_INFINITY || data === POSITIVE_INFINITY){\n\n    return data ;\n }\n\n return NaN ;\n\n \n\n \n\n    }\n    \n                    return function(data , {digit = 0 , keepMode = 'round' , keepDigitRightZero = false} = {}){\n    \n                        \n        if(!var_init_locked_1608956297991){\n\n            isString = include('src::is.string');\nisDate = include('src::is.date');\nround = include('src::math.round');\ntruncation = include('src::math.truncation');\ngetDigit = include('src::math.digit');\nisNumber = include('src::is.number');\n\n            var_init_locked_1608956297991 = true ;\n        }\n        \n    \n                        return main.call(this , data , {digit , keepMode , keepDigitRightZero}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.convert.number"
  },
  "src::math.round": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.round(<number> data , <number> digit)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , digit){\n\n        \n/**\n * \n * 实现四舍五入\n * \n * @param {number} data 数值\n * \n * @param {number} [digit = 0] 保留小数点位数\n * \n * @return {number} 四舍五入后的数值\n * \n */\n\n if(digit === 0){\n\n    return Math.round(data) ;\n }\n\n return Math.round(data * Math.pow(10 , digit)) / Math.pow(10 , digit);\n\n    }\n    \n                    return function(data , digit = 0){\n    \n                        \n    \n                        return main.call(this , data , digit) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.round"
  },
  "src::math.truncation": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.truncation(<number> data , <number> digit)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , digit){\n\n        \n/**\n * \n * 实现小数点后截断\n * \n * @param {number} data 数值\n * \n * @param {number} [digit = 0] 保留小数点位数\n * \n * @return {number} 截断后的数据\n * \n */\n\nif(digit === 0){\n\n    return Math.trunc(data) ;\n }\n\n return Math.trunc(data * Math.pow(10 , digit)) / Math.pow(10 , digit);\n\n    }\n    \n                    return function(data , digit = 0){\n    \n                        \n    \n                        return main.call(this , data , digit) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.truncation"
  },
  "src::math.digit": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.digit(<number> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        /*\n * \n * 获取数字的实际小数位数\n * \n * @param {number} data 数字\n * \n * @return {number} 小数位数\n * \n */\n\n/\\.(\\d+)$/.exec(String(data)) ;\n\nreturn RegExp.$1.length ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.digit"
  },
  "src::data.message.channel.concat": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.concat(<mixed> channels)",
    "standard": true,
    "importNames": [
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from;\n    \n                    let var_init_locked_1608956298003;\n    \n                    \n\n                    function main(channels){\n\n        \n/**\n * \n * 与其它消息通道完成互联\n * \n * @import from from array.from\n * \n * @param {mixed} channels 其它的对接的消息通道对象\n * \n */\n\n channels = from(channels) ;\n\n let me = this,\n {\n    concatenateChannels\n } = me ;\n\n for(let channel of channels){\n\n    if(!concatenateChannels.includes(channel)){\n\n      concatenateChannels.push(channel) ;\n\n      channel.concat(me) ;\n\n    }\n }\n\n    }\n    \n                    return function(channels){\n    \n                        \n        if(!var_init_locked_1608956298003){\n\n            from = include('src::array.from');\n\n            var_init_locked_1608956298003 = true ;\n        }\n        \n    \n                        return main.call(this , channels) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.concat"
  },
  "src::data.message.channel.connect": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.connect(<mixed> address , <mixed> params , <object> config)",
    "standard": true,
    "importNames": [
      "src::data.message.channel.send",
      "src::data.message.processive.connect"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956298005 = new Map();\n    \n                    return function(address , params , config = {}){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956298005.has(this)){\n\n            var_current_scope_1608956298005.set(this , (() => {\n                const send = include('src::data.message.channel.send').bind(this);\nconst connect = include('src::data.message.processive.connect').bind(this);\n\n                function main(address , params , config){\n\n        \n/**\n * \n * 连接\n * \n * @import send from .send scoped\n * \n * @import connect from data.message.processive.connect scoped\n * \n * @param {mixed} address 接收消息地址\n * \n * @param {mixed} params 发送的数据\n * \n * @param {object} [config = {}] 发送配置\n * \n */\n\nlet {\n    body,\n    promise\n} = send(address , params , {\n    ...config,\n    processive:true,\n    returnMessage:true\n}),\n{\n    id\n} = body;\n\nconnect(id) ;\n\nlet {\n    messages\n} = this ;\n\nif(messages[id].connectCount === 1){\n\n    return promise ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298005.get(this) ;\n\n        \n    \n                        return main.call(this , address , params , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.connect"
  },
  "src::promise.create": {
    "meta": "code.meta.script.function",
    "signature": "<Promise> src::promise.create(<function> onInit , <function> onCancel)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::promise.create.processive"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction,ProcessivePromise;\n    \n                    let var_init_locked_1608956298020;\n    \n                    \n\n                    function main(onInit , onCancel){\n\n        \n/**\n * \n * 创建 Promise 对象\n * \n * @import is.function\n * \n * @import ProcessivePromise from promise.create.processive value\n * \n * @param {function} onInit 实始化 Promise 引用\n * \n * @param {function} [onCancel] 取消 Promise 时调用\n * \n * @return {Promise} 创建后的 Promise\n * \n */\n\n if(isFunction(onCancel)){\n\n    return new ProcessivePromise(onInit , onCancel) ;\n }\n\n return new Promise(onInit) ;\n\n    }\n    \n                    return function(onInit , onCancel){\n    \n                        \n        if(!var_init_locked_1608956298020){\n\n            isFunction = include('src::is.function');\nProcessivePromise = include('src::promise.create.processive')();\n\n            var_init_locked_1608956298020 = true ;\n        }\n        \n    \n                        return main.call(this , onInit , onCancel) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "promise.create"
  },
  "src::data.message.create": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.create(<data.message.Channel> channel , <mixed> address , <mixed> params , {<boolean> reconnection , <string> fromAddress , <boolean> processive})",
    "standard": true,
    "importNames": [
      "src::id.generate",
      "src::promise.create",
      "src::event.listener.add",
      "src::event.listener.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let generate,createPromise,add,remove;\n    \n                    let var_init_locked_1608956298017;\n    \n                    \n\n                    function main(channel , address , params , {reconnection , fromAddress , processive}){\n\n        /**\n * \n * 创建一个消息\n * \n * @import generate from id.generate\n * \n * @import createPromise from promise.create\n * \n * @import add from event.listener.add\n * \n * @import remove from event.listener.remove\n * \n * @param {data.message.Channel} channel 消息通道对象\n * \n * @param {mixed} address 接收消息地址\n * \n * @param {mixed} params 发送的数据\n * \n * @param {object} [config = {}] 发送配置\n * \n * @param {boolean} [config.reconnection = false] 在发送失败后是否重发 \n * \n * @param {string} [config.fromAddress] 发送消息地址\n * \n * @param {boolean} [config.processive = false] 是否为持续消息\n * \n */\n\n let me = this,\n {\n    messages\n } = channel,\n id = generate('message-' , true);\n\n return messages[id] = {\n     ...(processive ? {\n        connectCount:0,\n        count:0\n     } : {}),\n     promise:createPromise((resolve , reject) =>{\n\n        if(processive){\n\n            let listeners = {\n                [`message-${id}`](channel , data){\n\n                    resolve(data) ;\n\n                },\n                [`messageerror-${id}`]:{\n                    fn(channel , message){\n\n                        reject(message) ;\n                        \n                    },\n                    once:true\n                }\n            } ;\n\n            add(channel , listeners) ;\n\n            return listeners ;\n        \n        }else{\n\n            let onMessageError = (channel , message) => {\n\n                reject(message) ;\n\n                remove(channel , `message-${id}` , onMessage) ;\n            \n            },\n            onMessage = (channel , data) =>{\n\n                resolve(data) ;\n\n                remove(channel , `messageerror-${id}` , onMessageError) ;\n                \n            };\n\n            add(channel , {\n                [`message-${id}`]:{\n                    fn:onMessage,\n                    once:true\n                },\n                [`messageerror-${id}`]:{\n                    fn:onMessageError,\n                    once:true\n                }\n            }) ;\n        }\n\n     } , processive ? async (listeners) => await channel.disconnect(address , params , {\n        reconnection,\n        fromAddress,\n        processive\n     }) : false),\n     body:{\n        id,\n        from:fromAddress,\n        to:address,\n        params,\n        reconnection,\n        processive\n    }\n } ;\n\n    }\n    \n                    return function(channel , address , params , {reconnection = false , fromAddress , processive = false} = {}){\n    \n                        \n        if(!var_init_locked_1608956298017){\n\n            generate = include('src::id.generate');\ncreatePromise = include('src::promise.create');\nadd = include('src::event.listener.add');\nremove = include('src::event.listener.remove');\n\n            var_init_locked_1608956298017 = true ;\n        }\n        \n    \n                        return main.call(this , channel , address , params , {reconnection , fromAddress , processive}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.create"
  },
  "src::object.copy": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::object.copy(<object> dest , <object> source , <string[]> fields)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(dest , source , fields){\n\n        \n/**\n * \n * 复制\n * \n * @param {object} dest 目标对象\n * \n * @param {object} source 来源对象\n * \n * @param {string[]} [fields = []] 拷贝字段集合 \n * \n * @return {object} 目标对象引用\n * \n */\n\n for(let field of fields){\n\n    dest[field] = source[field] ;\n }\n\n return dest ;\n\n    }\n    \n                    return function(dest , source , fields = []){\n    \n                        \n    \n                        return main.call(this , dest , source , fields) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.copy"
  },
  "src::data.message.get": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.get(<data.message.Channel> channel , <mixed> address , <mixed> params , {<boolean> reconnection , <string> fromAddress , <boolean> processive , <boolean> autoCreate})",
    "standard": true,
    "importNames": [
      "src::data.message.create",
      "src::data.equals",
      "src::is.object.simple",
      "src::object.copy",
      "src::is.promise.processive",
      "src::promise.create"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let equals,isObject,copy,isPromise,createPromise;\n    \n                    let var_init_locked_1608956298013;\n \n                    \n\n                    const var_current_scope_1608956298013 = new Map();\n    \n                    return function(channel , address , params , {reconnection = false , fromAddress , processive = false , autoCreate = true} = {}){\n    \n                        \n        if(!var_init_locked_1608956298013){\n\n            equals = include('src::data.equals');\nisObject = include('src::is.object.simple');\ncopy = include('src::object.copy');\nisPromise = include('src::is.promise.processive');\ncreatePromise = include('src::promise.create');\n\n            var_init_locked_1608956298013 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298013.has(this)){\n\n            var_current_scope_1608956298013.set(this , (() => {\n                const create = include('src::data.message.create').bind(this);\n\n                function main(channel , address , params , {reconnection , fromAddress , processive , autoCreate}){\n\n        \n/**\n * \n * 获取消息\n * \n * @import create from .create scoped\n * \n * @import equals from data.equals\n * \n * @import isObject from is.object.simple\n * \n * @import copy from object.copy\n * \n * @import isPromise from is.promise.processive\n * \n * @import createPromise from promise.create\n * \n * @param {data.message.Channel} channel 消息通道对象\n * \n * @param {mixed} address 接收消息地址\n * \n * @param {mixed} params 发送的数据\n * \n * @param {object} [config = {}] 发送配置\n * \n * @param {boolean} [config.reconnection = false] 在发送失败后是否重发 \n * \n * @param {string} [config.fromAddress] 发送消息地址\n * \n * @param {boolean} [config.processive = false] 是否为持续消息\n * \n * @param {boolean} [config.autoCreate = true] 当前 autoCreate 设置为 true 时，如果消息不存在时则创建\n * \n */\n\nlet me = this,\n{\n   rootAddress,\n   messages\n} = channel ;\n\nfromAddress = rootAddress ;\n\nmessages = Object.values(messages) ;\n\nfor(let message of messages){\n\n    let {\n        body,\n        promise\n    } = message,\n    {\n        from,\n        to,\n        params:messageParams,\n        processive:messageProcessive,\n        cancel\n    } = body ;\n\n    if(cancel === true){\n\n        continue ;\n    }\n\n    if(\n        from === fromAddress &&\n        to === address &&\n        equals(params , messageParams) &&\n        messageProcessive === processive\n    ){\n\n        return {\n            created:false,\n            promise,\n            body\n        } ;\n    }\n}\n\nif(autoCreate){\n\n    return {\n        ...create(channel , address , params , {\n            reconnection,\n            fromAddress,\n            processive\n        }),\n        created:true\n    } ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298013.get(this) ;\n\n        \n    \n                        return main.call(this , channel , address , params , {reconnection , fromAddress , processive , autoCreate}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.get"
  },
  "src::data.message.channel.send.body": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.send.body(<object> body)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(body){\n\n        \n/**\n * \n * 发送消息主体\n * \n * @param {object} body 消息主体\n * \n */\n\nlet me = this,\n{\n    proxy,\n    addresses,\n    rootAddress\n} = me,{\n    to\n} = body;\n\nif(addresses.hasOwnProperty(to)){\n\n   me.receive(body) ;\n\n}else{\n\n   proxy.call('doSend' , {\n       ...body,\n       channels:[\n           rootAddress\n        ]\n   }) ;\n}\n\n    }\n    \n                    return function(body){\n    \n                        \n    \n                        return main.call(this , body) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.send.body"
  },
  "src::data.message.channel.send": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.send(<mixed> address , <mixed> params , <object> config)",
    "standard": true,
    "importNames": [
      "src::data.message.get",
      "src::data.message.channel.send.body"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956298008;\n \n                    \n\n                    const var_current_scope_1608956298008 = new Map();\n    \n                    return function(address , params , config = {}){\n    \n                        \n        if(!var_init_locked_1608956298008){\n\n            get = include('src::data.message.get');\n\n            var_init_locked_1608956298008 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298008.has(this)){\n\n            var_current_scope_1608956298008.set(this , (() => {\n                const send = include('src::data.message.channel.send.body').bind(this);\n\n                function main(address , params , config){\n\n        \n/**\n * \n * 发送消息\n * \n * @import get from data.message.get\n * \n * @import send from .send.body scoped\n * \n * @param {mixed} address 接收消息地址\n * \n * @param {mixed} params 发送的参数\n * \n * @param {object} [config = {}] 发送配置\n * \n */\n\n let {\n   returnMessage = false\n } = config,\n message = get(this , address , params , config),\n {\n    promise,\n    body,\n    created\n } = message ;\n\n if(created){\n\n   send(body) ;\n \n }\n\n if(returnMessage === true){\n\n    return message ;\n }\n\n return promise ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298008.get(this) ;\n\n        \n    \n                        return main.call(this , address , params , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.send"
  },
  "src::data.message.processive.connect": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.processive.connect(<string> id)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(id){\n\n        \n/**\n * \n * 持续消息连接\n * \n * @param {string} id 消息编号\n * \n */\n\n let {\n    messages\n } = this ;\n\n if(messages.hasOwnProperty(id)){\n\n    messages[id].connectCount ++ ;\n }\n\n    }\n    \n                    return function(id){\n    \n                        \n    \n                        return main.call(this , id) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.processive.connect"
  },
  "src::data.message.channel.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.constructor({<boolean> reSendDelay , <string> rootAddress , <mixed> rootAddressConfig , <object> addresses , <function> initFn})",
    "standard": true,
    "importNames": [
      "src::object.proxy",
      "src::array.proxy",
      "src::id.generate",
      "src::function.empty"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let createProxy,createArrayProxy,generate,empty;\n    \n                    let var_init_locked_1608956298032;\n    \n                    \n\n                    function main({reSendDelay , rootAddress , rootAddressConfig , addresses , initFn}){\n\n        \n/**\n * \n * 初始化消息通道\n * \n * @param {object} [config = {}] 消息通道配置\n * \n * @param {boolean} [config.reSendDelay = 0] 重发消息延迟\n * \n * @param {string} [config.rootAddress] 根地址\n * \n * @param {mixed} [config.rootAddressConfig] 根地址配置\n * \n * @param {object} [config.addresses] 地址配置\n * \n * @param {function} [config.initFn] 初始化函数\n * \n * @import createProxy from object.proxy\n * \n * @import createArrayProxy from array.proxy\n * \n * @import generate from id.generate\n * \n * @import empty from function.empty value\n * \n */\n\n let me = this,\n    proxy = createProxy(me) ;\n\ninitFn = initFn || empty ;\n\nme.proxy = proxy ;\n\nme.addresses = {} ;\n\nme.register(me.rootAddress = rootAddress , rootAddressConfig) ;\n\nme.register(addresses) ;\n\nme.reSendDelay = reSendDelay ;\n\nme.concatenateChannels = createArrayProxy() ;\n\nme.processivePromises = {} ;\n\nme.messages = {} ;\n\ninitFn.call(me) ;\n\nproxy.call('doReceive' , me.receive.bind(me)) ;\n\n    }\n    \n                    return function({reSendDelay = 0 , rootAddress , rootAddressConfig , addresses , initFn} = {}){\n    \n                        \n        if(!var_init_locked_1608956298032){\n\n            createProxy = include('src::object.proxy');\ncreateArrayProxy = include('src::array.proxy');\ngenerate = include('src::id.generate');\nempty = include('src::function.empty')();\n\n            var_init_locked_1608956298032 = true ;\n        }\n        \n    \n                        return main.call(this , {reSendDelay , rootAddress , rootAddressConfig , addresses , initFn}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.constructor"
  },
  "src::data.message.channel.destroy": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.destroy()",
    "standard": true,
    "importNames": [
      "src::object.clear",
      "src::array.clear"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let clear1,clear2;\n    \n                    let var_init_locked_1608956298034;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 销毁消息通道\n * \n * @import clear1 from object.clear\n * \n * @import clear2 from array.clear\n * \n */\n\n let {\n    addresses,\n    concatenateChannels\n } = this ;\n\n clear1(addresses) ;\n\n clear2(concatenateChannels) ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298034){\n\n            clear1 = include('src::object.clear');\nclear2 = include('src::array.clear');\n\n            var_init_locked_1608956298034 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.destroy"
  },
  "src::object.clear": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.clear(<object> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 清除指定对象的所有键\n * \n * @param {object} data 对象数据\n * \n */\n\nlet keys = Object.keys(data) ;\n\nfor(let key of keys){\n\n    delete data[key] ;\n}\n\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.clear"
  },
  "src::data.message.channel.disconnect.all": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.disconnect.all()",
    "standard": true,
    "importNames": [
      "src::data.message.channel.disconnect"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956298039 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956298039.has(this)){\n\n            var_current_scope_1608956298039.set(this , (() => {\n                const disconnect = include('src::data.message.channel.disconnect').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 断开所有连接\n * \n * @import disconnect from ..disconnect scoped\n * \n */\n\n let {\n    messages\n } = this;\n\n messages = Object.values(messages) ;\n\n let results = [] ;\n\n for(let message of messages){\n\n    if(message.hasOwnProperty('connectCount')){\n\n        message.connectCount = 0 ;\n\n        results.push(disconnect(message)) ;\n    }\n }\n\n return Promise.all(results) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298039.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.disconnect.all"
  },
  "src::data.message.processive.disconnect": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.processive.disconnect(<string> id)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(id){\n\n        \n/**\n * \n * 持续消息断开\n * \n * @param {string} id 消息编号\n * \n */\n\nlet {\n    messages\n } = this ;\n\n if(messages.hasOwnProperty(id)){\n\n    let message = messages[id],\n    {\n        connectCount\n    } = message ;\n\n    if(connectCount > 0){\n\n        message.connectCount -- ;\n    }\n }\n\n    }\n    \n                    return function(id){\n    \n                        \n    \n                        return main.call(this , id) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.processive.disconnect"
  },
  "src::data.message.processive.disconnect.is": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::data.message.processive.disconnect.is(<string> id)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(id){\n\n        \n/**\n * \n * 判断持续消息是否可真实断开\n * \n * @param {string} id 消息编号\n * \n * @return {boolean} 如果持续消息可以断开则返回 true , 否则返回 false\n * \n */\n\nlet {\n    messages\n } = this ;\n\n if(messages.hasOwnProperty(id)){\n\n    let message = messages[id] ;\n\n    return message.connectCount === 0 && message.body.cancel !== true ;\n }\n\n return false ;\n\n    }\n    \n                    return function(id){\n    \n                        \n    \n                        return main.call(this , id) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.processive.disconnect.is"
  },
  "src::data.message.channel.disconnect": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.disconnect(<mixed> address , <mixed> params , <object> config)",
    "standard": true,
    "importNames": [
      "src::data.message.get",
      "src::data.message.channel.send.body",
      "src::event.listener.add",
      "src::event.listener.remove",
      "src::data.message.processive.disconnect",
      "src::data.message.processive.disconnect.is",
      "src::is.string",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,add,remove,isString,isObject;\n    \n                    let var_init_locked_1608956298048;\n \n                    \n\n                    const var_current_scope_1608956298048 = new Map();\n    \n                    return function(address , params , config = {}){\n    \n                        \n        if(!var_init_locked_1608956298048){\n\n            get = include('src::data.message.get');\nadd = include('src::event.listener.add');\nremove = include('src::event.listener.remove');\nisString = include('src::is.string');\nisObject = include('src::is.object.simple');\n\n            var_init_locked_1608956298048 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298048.has(this)){\n\n            var_current_scope_1608956298048.set(this , (() => {\n                const send = include('src::data.message.channel.send.body').bind(this);\nconst disconnect = include('src::data.message.processive.disconnect').bind(this);\nconst is = include('src::data.message.processive.disconnect.is').bind(this);\n\n                function main(address , params , config){\n\n        \n/**\n * \n * 连接\n * \n * @import get from data.message.get\n * \n * @import send from .send.body scoped\n * \n * @import add from event.listener.add\n * \n * @import remove from event.listener.remove\n * \n * @import disconnect from data.message.processive.disconnect scoped\n * \n * @import is from data.message.processive.disconnect.is scoped\n * \n * @import is.string\n * \n * @import isObject from is.object.simple\n * \n * @param {mixed} address 接收消息地址\n * \n * @param {mixed} params 发送的数据\n * \n * @param {object} [config = {}] 发送配置\n * \n */\n\nlet me = this,\n    message ;\n\nif(isString(address)){\n\n    message = get(me , address , params , {\n        ...config,\n        processive:true,\n        autoCreate:false\n    }) ;\n\n}else if(isObject(address)){\n\n    message = address ;\n}\n\nif(message){\n\n    let {\n        body\n    } = message,\n    {\n        id\n    } = body;\n\n    disconnect(id) ;\n\n    if(is(id)){\n\n        remove(me , [\n            `messagestart-${id}`,\n            `message-${id}`,\n            `messageend-${id}`,\n            `messageerror-${id}`,\n        ]) ;\n    \n        body.cancel = true ;\n    \n        send(body) ;\n    \n        return new Promise(resolve => add(me , `messageend-${id}` , resolve , {\n            once:true\n        })) ;\n        \n    }\n}\n\nreturn Promise.resolve() ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298048.get(this) ;\n\n        \n    \n                        return main.call(this , address , params , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.disconnect"
  },
  "src::data.message.channel.electron.main": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.electron.main(<object> config)",
    "standard": true,
    "importNames": [
      "src::array.from",
      "src::is.array",
      "src::is.message",
      "src::data.message.channel"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from,isArray,is,Channel;\n    \n                    let var_init_locked_1608956298058;\n    \n                    let var_class_1608956298058;\n    \n                    \n\n                    let var_global_main_1608956298058 ;\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298058){\n\n            from = include('src::array.from');\nisArray = include('src::is.array');\nis = include('src::is.message');\nChannel = include('src::data.message.channel')();\n\n            \n/**\n * \n * 消息通道 Electron 主进程版\n * \n * @import from from array.from\n * \n * @import is.array\n * \n * @import is from is.message\n * \n * @import Channel from data.message.channel value\n *\n * @param {object} config 配置 \n * \n */\n\n class main extends Channel{\n\n    constructor({\n        window,\n        ...options\n    }){\n\n        super({\n            ...options,\n            initFn(){\n\n                this.webContents = window.webContents ;\n            }\n        }) ;\n    }\n\n    doReceive(receive){\n\n        let {\n            webContents\n        } = this ;\n\n        webContents.on('ipc-message' , (event , id , message) => {\n\n            if(isArray(id)){\n\n                message = id[1] ;\n            }\n\n            if(is(message)){\n\n                receive(message) ;\n            }\n\n        }) ;\n    }\n\n    doSend(message){\n\n        let {\n            webContents\n        } = this;\n\n        if(!webContents.isDestroyed()){\n\n            webContents.send('ipc-message' , message) ;\n        }\n    }\n }\n\n            var_class_1608956298058 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298058 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.message.channel.electron.main' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298058 ;\n        \nvar_global_main_1608956298058 = main;\n\n            var_init_locked_1608956298058 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298058(config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.electron.main"
  },
  "src::is.message": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject;\n    \n                    let var_init_locked_1608956298061;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 是否为消息体\n * \n * @import isObject from is.object.simple\n * \n * @param {mixed} data 校验数据 \n * \n * @return {boolean} 如果是消息体则返回 true , 否则返回 false \n * \n */\n\n if(isObject(data)){\n\n    return data.hasOwnProperty('id') && data.hasOwnProperty('from') && data.hasOwnProperty('to') ;\n }\n \n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298061){\n\n            isObject = include('src::is.object.simple');\n\n            var_init_locked_1608956298061 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message"
  },
  "src::data.message.channel.fire": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.fire(<string> event , <data.Message> message , <mixed> ...args)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(event , message , ...args){\n\n        \n/**\n * \n * 触发事件\n * \n * @param {string} event 事件名称\n * \n * @param {data.Message} message 消息包\n * \n * @param {mixed} [...args] 事件参数\n * \n */\n\n let {\n     id\n } = message ;\n\n this.fireEvent(`${event}-${id}` , ...args , message) ;\n\n\n    }\n    \n                    return function(event , message , ...args){\n    \n                        \n    \n                        return main.call(this , event , message , ...args) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.fire"
  },
  "src::data.message.is.forwarded": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::data.message.is.forwarded(<object> message , <data.message.Channel> channel)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(message , channel){\n\n        \n/**\n * \n * 判断消息是否已经被指定消息通道转发过\n * \n * @param {object} message 消息\n * \n * @param {data.message.Channel} channel 消息通道\n * \n * @return {boolean} 如果消息是被消息通道转发过则返回 true , 否则返回 false \n * \n */\n\n let {\n    channels\n } = message,\n {\n    rootAddress\n } = channel;\n\n return channels.includes(rootAddress) ;\n\n    }\n    \n                    return function(message , channel){\n    \n                        \n    \n                        return main.call(this , message , channel) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.is.forwarded"
  },
  "src::data.message.forward": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.forward(<object> message , <data.message.Channel> channel)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(message , channel){\n\n        \n/**\n * \n * 消息登记转发消息通道\n * \n * @param {object} message 消息\n * \n * @param {data.message.Channel} channel 消息通道\n * \n */\n\nlet {\n    channels\n } = message,\n {\n    rootAddress\n } = channel;\n\n return channels.push(rootAddress) ;\n\n    }\n    \n                    return function(message , channel){\n    \n                        \n    \n                        return main.call(this , message , channel) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.forward"
  },
  "src::data.message.channel.forward": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::data.message.channel.forward(<data.Message> message)",
    "standard": true,
    "importNames": [
      "src::data.message.is.forwarded",
      "src::data.message.forward"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isForwarded,forward;\n    \n                    let var_init_locked_1608956298071;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 转发消息\n * \n * @import isForwarded from data.message.is.forwarded\n * \n * @import forward from data.message.forward\n * \n * @param {data.Message} message 消息体\n * \n * @return {boolean} 如果转发成功则返回 true , 否则返回 false\n * \n */\n\n\n let me = this,\n {\n    proxy\n } = me ;\n\n if(!isForwarded(message , me)){\n\n    forward(message , me) ;\n\n    proxy.call('doSend' , message) ;\n\n    return true ;\n }\n\n return false ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298071){\n\n            isForwarded = include('src::data.message.is.forwarded');\nforward = include('src::data.message.forward');\n\n            var_init_locked_1608956298071 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.forward"
  },
  "src::is.message.send": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message.send(<object> message)",
    "standard": true,
    "importNames": [
      "src::is.message"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298088;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 判断是否是发送消息\n * \n * @import is from ..message\n * \n * @param {object} message 消息 \n * \n * @return {boolean}  如果是发送消息，则返回 true , 否则返回 false\n * \n */\n\n return is(message) && !message.hasOwnProperty('received') ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298088){\n\n            is = include('src::is.message');\n\n            var_init_locked_1608956298088 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message.send"
  },
  "src::is.message.send.processive": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message.send.processive(<object> message)",
    "standard": true,
    "importNames": [
      "src::is.message.send"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298090;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 判断是否为发送持续消息\n * \n * @import is from ..send\n * \n * @param {object} message 参数说明\n * \n * @return {boolean} 如果为发送持续消息则返回 true , 否则返回 false \n * \n */\n\n return is(message) && message.processive === true ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298090){\n\n            is = include('src::is.message.send');\n\n            var_init_locked_1608956298090 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message.send.processive"
  },
  "src::is.message.send.processive.cancel": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message.send.processive.cancel(<object> message)",
    "standard": true,
    "importNames": [
      "src::is.message.send.processive"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298092;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 判断是否为发送取消持续消息\n * \n * @import is from ..processive\n * \n * @param {object} message 参数说明\n * \n * @return {boolean} 如果为发送持续消息则返回 true , 否则返回 false \n * \n */\n\nreturn is(message) && message.cancel === true ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298092){\n\n            is = include('src::is.message.send.processive');\n\n            var_init_locked_1608956298092 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message.send.processive.cancel"
  },
  "src::is.message.reply": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message.reply(<object> message)",
    "standard": true,
    "importNames": [
      "src::is.message"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298094;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 判断是否是回复消息\n * \n * @import is from ..message\n * \n * @param {object} message 消息 \n * \n * @return {boolean}  如果是回复消息，则返回 true , 否则返回 false\n * \n */\n\nreturn is(message) && message.hasOwnProperty('received') ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298094){\n\n            is = include('src::is.message');\n\n            var_init_locked_1608956298094 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message.reply"
  },
  "src::is.message.reply.success": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message.reply.success(<object> message)",
    "standard": true,
    "importNames": [
      "src::is.message.reply"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298097;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 判断是否是回复成功消息\n * \n * @import is from ..reply\n * \n * @param {object} message 消息 \n * \n * @return {boolean}  如果是回复成功消息，则返回 true , 否则返回 false\n * \n */\n\nreturn is(message) && message.received === true ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298097){\n\n            is = include('src::is.message.reply');\n\n            var_init_locked_1608956298097 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message.reply.success"
  },
  "src::is.message.reply.success.processive": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message.reply.success.processive(<object> message)",
    "standard": true,
    "importNames": [
      "src::is.message.reply.success"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298101;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 判断回复信息是否为持续信息\n * \n * @import is from ..success\n * \n * @param {object} message 消息\n * \n * @return {boolean} 如果回复信息是持续信息则返回 true , 否则返回 false \n * \n */\n\n return is(message) && message.processive === true ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298101){\n\n            is = include('src::is.message.reply.success');\n\n            var_init_locked_1608956298101 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message.reply.success.processive"
  },
  "src::is.message.reply.success.processive.cancel": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message.reply.success.processive.cancel(<object> message)",
    "standard": true,
    "importNames": [
      "src::is.message.reply.success.processive"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298099;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 判断回复信息为取消持续信息\n * \n * @import is from ..processive\n * \n * @param {object} message 消息\n * \n * @return {boolean} 如果回复信息是取消持续信息则返回 true , 否则返回 false \n * \n */\n\nreturn is(message) && message.cancel === true ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298099){\n\n            is = include('src::is.message.reply.success.processive');\n\n            var_init_locked_1608956298099 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message.reply.success.processive.cancel"
  },
  "src::is.message.reply.failure": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.message.reply.failure(<object> message)",
    "standard": true,
    "importNames": [
      "src::is.message.reply"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298102;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 判断是否是回复失败消息\n * \n * @import is from ..reply\n * \n * @param {object} message 消息 \n * \n * @return {boolean}  如果是回复失败消息，则返回 true , 否则返回 false\n * \n */\n\nreturn is(message) && message.received === false ;\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298102){\n\n            is = include('src::is.message.reply');\n\n            var_init_locked_1608956298102 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.message.reply.failure"
  },
  "src::data.message.channel.receive": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.receive(<data.Message> message)",
    "standard": true,
    "importNames": [
      "src::is.boolean",
      "src::is.defined",
      "src::is.message.send",
      "src::is.message.send.processive",
      "src::is.message.send.processive.cancel",
      "src::is.message.reply",
      "src::is.message.reply.success",
      "src::is.message.reply.success.processive.cancel",
      "src::is.message.reply.success.processive",
      "src::is.message.reply.failure",
      "src::is.promise",
      "src::is.promise.processive"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isBoolean,isDefined,isSendMessage,isSendProcessiveMessage,isSendCancelProcessiveMessage,isReplyMessage,isReplySuccessMessage,isReplySuccessCancelProcessiveMessage,isReplySuccessProcessiveMessage,isReplyFailureMessage,isPromise,isProcessivePromise;\n    \n                    let var_init_locked_1608956298084;\n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 接收消息\n * \n * @import is.boolean\n * \n * @import is.defined\n * \n * @import isSendMessage from is.message.send\n * \n * @import isSendProcessiveMessage from is.message.send.processive\n * \n * @import isSendCancelProcessiveMessage from is.message.send.processive.cancel\n * \n * @import isReplyMessage from is.message.reply\n * \n * @import isReplySuccessMessage from is.message.reply.success\n * \n * @import isReplySuccessCancelProcessiveMessage from is.message.reply.success.processive.cancel\n * \n * @import isReplySuccessProcessiveMessage from is.message.reply.success.processive\n * \n * @import isReplyFailureMessage from is.message.reply.failure\n * \n * @import is.promise\n * \n * @import isProcessivePromise from is.promise.processive\n * \n * @param {data.Message} message 消息对象\n * \n */\n\n let me = this,\n {\n     addresses,\n     reSendDelay,\n     concatenateChannels,\n     processivePromises,\n     messages,\n     rootAddress\n } = me,{\n    id,\n    from,\n    to\n} = message ;\n\nmessage.channels.push(rootAddress) ;\n\n if(isSendMessage(message)){\n\n    if(addresses.hasOwnProperty(to)){\n\n        if(isSendCancelProcessiveMessage(message)){\n\n            if(processivePromises.hasOwnProperty(id)){\n\n                processivePromises[id].cancel() ;\n\n                delete processivePromises[id] ;\n            }\n\n            me.replySuccess(message) ;\n\n        }else{\n\n            let result = addresses[to].receive(message.params , message) ;\n\n            if(isPromise(result)){\n\n                result.then(result => me.replySuccess(message , result)) ;\n\n                if(isProcessivePromise(result)){\n\n                    if(isSendProcessiveMessage(message)){\n\n                        processivePromises[id] =  result ;\n                    \n                    }else{\n\n                        result.then(() => result.cancel()) ;\n                    }\n                }\n\n            }else{\n\n                me.replySuccess(message , result) ;\n            }\n        }\n    \n    }else if(!concatenateChannels.call('forward' , message).includes(true)){\n\n        //me.replyFailure(message) ;\n    }\n \n }else if(isReplyMessage(message)){\n\n    if(isReplySuccessMessage(message)){\n\n        if(messages.hasOwnProperty(id)){\n\n            let result = addresses[from].reply(message.result , message);\n\n            if(!isReplySuccessProcessiveMessage(message)){\n\n                delete messages[id] ;\n            \n            }else{\n\n                if(message.count === 0){\n\n                    me.fire('messagestart' , message) ;\n                }\n\n                message.count ++ ;\n            }\n\n            if(isReplySuccessCancelProcessiveMessage(message)){\n\n                me.fire('messageend' , message) ;\n            \n            }else{\n\n                me.fire('message' , message , result) ;\n            }\n\n        }else{\n\n            concatenateChannels.call('forward' , message) ;\n        }\n\n    }else if(isReplyFailureMessage(message)){\n\n        if(messages.hasOwnProperty(id)){\n\n            let {\n                reconnection,\n                processive\n            } = message ;\n\n            if(reconnection){\n\n                let method = processive ? 'connect' : 'send' ;\n\n                setTimeout(() => me[method](message) , reSendDelay) ; \n            \n            }else{\n\n                delete messages[id] ;\n\n                me.fire('messageerror' , message) ;\n            }\n        \n        }else{\n\n            concatenateChannels.call('forward' , message) ;\n        }\n    }\n }\n\n    }\n    \n                    return function(message){\n    \n                        \n        if(!var_init_locked_1608956298084){\n\n            isBoolean = include('src::is.boolean');\nisDefined = include('src::is.defined');\nisSendMessage = include('src::is.message.send');\nisSendProcessiveMessage = include('src::is.message.send.processive');\nisSendCancelProcessiveMessage = include('src::is.message.send.processive.cancel');\nisReplyMessage = include('src::is.message.reply');\nisReplySuccessMessage = include('src::is.message.reply.success');\nisReplySuccessCancelProcessiveMessage = include('src::is.message.reply.success.processive.cancel');\nisReplySuccessProcessiveMessage = include('src::is.message.reply.success.processive');\nisReplyFailureMessage = include('src::is.message.reply.failure');\nisPromise = include('src::is.promise');\nisProcessivePromise = include('src::is.promise.processive');\n\n            var_init_locked_1608956298084 = true ;\n        }\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.receive"
  },
  "src::data.message.channel.register": {
    "meta": "code.meta.script.function",
    "signature": "<data.message.Address> src::data.message.channel.register(<string|object> address , <mixed> fn , <mixed> scope)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::is.function",
      "src::function.get",
      "src::is.string",
      "src::function.empty"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,isFunction,get,isString,emptyFn;\n    \n                    let var_init_locked_1608956298105;\n    \n                    \n\n                    \n/**\n * \n * 登记地址\n * \n * @import isObject from is.object.simple\n * \n * @import is.function\n * \n * @import get from function.get\n * \n * @import is.string\n * \n * @import isObject from is.object.simple\n * \n * @import emptyFn from function.empty value\n * \n * @param {string|object} address 地址\n * \n * @param {mixed} fn 地址所绑定的函数\n * \n * @param {mixed} scope 绑定函数的作用域\n * \n * @return {data.message.Address} 消息地址\n * \n */\n\n function main(address , fn , scope){\n\n    let me = this ;\n\n    if(isString(address)){\n\n        return register.call(me , address , fn , scope) ;\n    \n    }else if(isObject(address)){\n\n        let names = Object.keys(address),\n            result = {};\n\n        for(let name of names){\n\n            result[name] = register.call(me , name ,address[name]) ;\n        }\n\n        return result ;\n    }\n }\n\n function register(address , fn , scope){\n\n    let me = this,\n    {\n        addresses\n    } = me ;\n\n    if(!addresses.hasOwnProperty(address)){\n\n        let resignerConfig ;\n    \n        if(isObject(fn)){\n    \n            let config = fn ;\n    \n            {\n                let {\n                    receive = emptyFn,\n                    reply = result => result,\n                    scope\n                } = config ;\n    \n                resignerConfig = {\n                    receive:get(receive , scope),\n                    reply:get(reply , scope)\n                } ;\n            }\n    \n        }else if(isFunction(fn)){\n    \n            resignerConfig = {\n                receive:get(fn , scope),\n                reply:get(fn , scope) \n            } ;\n        \n        }else{\n    \n            resignerConfig = {\n                receive(){\n                },\n                reply(result){\n    \n                    return result ;\n                }\n            } ;\n        }\n    \n        addresses[address] = {\n            ...resignerConfig,\n            send(address , params , config = {}){\n    \n                return me.send(address , params , {\n                    ...config,\n                    fromAddress:address\n                }) ;\n            }\n        } ;\n     }\n\n     return addresses[address] ;\n}\n    \n                    return function(address , fn , scope){\n    \n                        \n        if(!var_init_locked_1608956298105){\n\n            isObject = include('src::is.object.simple');\nisFunction = include('src::is.function');\nget = include('src::function.get');\nisString = include('src::is.string');\nisObject = include('src::is.object.simple');\nemptyFn = include('src::function.empty')();\n\n            var_init_locked_1608956298105 = true ;\n        }\n        \n    \n                        return main.call(this , address , fn , scope) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.register"
  },
  "src::data.message.channel.unregister": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.unregister(<string|array> address)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(address){\n\n        \n/**\n * \n * 注销地址\n * \n * @param {string|array} address 地址\n * \n */\n\n let {\n    addresses\n } = this ;\n\n delete addresses[address] ;\n\n    }\n    \n                    return function(address){\n    \n                        \n    \n                        return main.call(this , address) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.unregister"
  },
  "src::data.message.channel.reply": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.reply(<data.Message> message)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(message){\n\n        \n/**\n * \n * 回复消息\n * \n * @param {data.Message} message 消息\n * \n */\n\n let me = this,\n    {\n        rootAddress\n    } = me;\n\n me.proxy.call('doSend' , {\n     ...message,\n     channels:[\n        rootAddress\n     ]\n }) ;\n\n    }\n    \n                    return function(message){\n    \n                        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.reply"
  },
  "src::data.message.channel.reply.success": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.reply.success(<data.Message> message , <mixed> result)",
    "standard": true,
    "importNames": [
      "src::data.message.channel.reply"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956298110 = new Map();\n    \n                    return function(message , result){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956298110.has(this)){\n\n            var_current_scope_1608956298110.set(this , (() => {\n                const reply = include('src::data.message.channel.reply').bind(this);\n\n                function main(message , result){\n\n        \n/**\n * \n * 回复消息发送成功\n * \n * @import reply from ..reply scoped\n * \n * @param {data.Message} message 消息\n * \n * @param {mixed} result 回复结果\n * \n */\n\n reply({\n     ...message,\n     received:true,\n     result\n }) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298110.get(this) ;\n\n        \n    \n                        return main.call(this , message , result) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.reply.success"
  },
  "src::data.message.channel.reply.failure": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.reply.failure(<data.Message> message)",
    "standard": true,
    "importNames": [
      "src::data.message.channel.reply"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956298115 = new Map();\n    \n                    return function(message){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956298115.has(this)){\n\n            var_current_scope_1608956298115.set(this , (() => {\n                const reply = include('src::data.message.channel.reply').bind(this);\n\n                function main(message){\n\n        \n/**\n * \n * 回复消息发送失败\n * \n * @import reply from ..reply scoped\n * \n * @param {data.Message} message 消息\n *\n */\n\nreply({\n    ...message,\n    received:false\n}) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298115.get(this) ;\n\n        \n    \n                        return main.call(this , message) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.reply.failure"
  },
  "src::data.message.channel": {
    "meta": "code.meta.class",
    "signature": "<void> src::data.message.channel()",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::class.empty",
      "src::data.message.channel.constructor",
      "src::data.message.channel.fire",
      "src::data.message.channel.forward",
      "src::data.message.channel.send",
      "src::data.message.channel.connect",
      "src::data.message.channel.disconnect",
      "src::data.message.channel.disconnect.all",
      "src::data.message.channel.receive",
      "src::data.message.channel.register",
      "src::data.message.channel.unregister",
      "src::data.message.channel.destroy",
      "src::data.message.channel.reply.success",
      "src::data.message.channel.reply.failure",
      "src::data.message.channel.concat",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let mixin_1608956298065__1,extend,constructor,method_fire,method_forward,method_send,method_connect,method_disconnect,method_disconnectAll,method_receive,method_register,method_unregister,method_destroy,method_replySuccess,method_replyFailure,method_concat,isObject;\n    \n                    let var_init_locked_1608956298065;\n    \n                    let var_class_1608956298065;\n    \n                    \n\n                    let var_global_main_1608956298065 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298065){\n\n            mixin_1608956298065__1 = include('src::mixin.observable');\nextend = include('src::class.empty')();\nconstructor = include('src::data.message.channel.constructor');\nmethod_fire = include('src::data.message.channel.fire');\nmethod_forward = include('src::data.message.channel.forward');\nmethod_send = include('src::data.message.channel.send');\nmethod_connect = include('src::data.message.channel.connect');\nmethod_disconnect = include('src::data.message.channel.disconnect');\nmethod_disconnectAll = include('src::data.message.channel.disconnect.all');\nmethod_receive = include('src::data.message.channel.receive');\nmethod_register = include('src::data.message.channel.register');\nmethod_unregister = include('src::data.message.channel.unregister');\nmethod_destroy = include('src::data.message.channel.destroy');\nmethod_replySuccess = include('src::data.message.channel.reply.success');\nmethod_replyFailure = include('src::data.message.channel.reply.failure');\nmethod_concat = include('src::data.message.channel.concat');\nisObject = include('src::is.object.simple');\n\n            class main extends mixins({extend , mixins:[include('mixin.observable')]}){\n\n            \n\n            \n\n            constructor(...args){\n\n            super(...args) ;\n\n            constructor.apply(this , args) ;\n\n        }\n\n            fire(...args){\n\n            return method_fire.apply(this , args) ;\n\n        }\nforward(...args){\n\n            return method_forward.apply(this , args) ;\n\n        }\nsend(...args){\n\n            return method_send.apply(this , args) ;\n\n        }\nconnect(...args){\n\n            return method_connect.apply(this , args) ;\n\n        }\ndisconnect(...args){\n\n            return method_disconnect.apply(this , args) ;\n\n        }\ndisconnectAll(...args){\n\n            return method_disconnectAll.apply(this , args) ;\n\n        }\nreceive(...args){\n\n            return method_receive.apply(this , args) ;\n\n        }\nregister(...args){\n\n            return method_register.apply(this , args) ;\n\n        }\nunregister(...args){\n\n            return method_unregister.apply(this , args) ;\n\n        }\ndestroy(...args){\n\n            return method_destroy.apply(this , args) ;\n\n        }\nreplySuccess(...args){\n\n            return method_replySuccess.apply(this , args) ;\n\n        }\nreplyFailure(...args){\n\n            return method_replyFailure.apply(this , args) ;\n\n        }\nconcat(...args){\n\n            return method_concat.apply(this , args) ;\n\n        }\n\n            \n\n        }\n\n            var_class_1608956298065 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298065 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.message.channel' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298065 ;\n        \nvar_global_main_1608956298065 = main;\n\n            var_init_locked_1608956298065 = true ;\n        }\n        \n    \n                        return var_global_main_1608956298065 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel"
  },
  "src::data.message.channel.electron.renderer.webview": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.electron.renderer.webview(<object> config)",
    "standard": true,
    "importNames": [
      "src::array.from",
      "src::is.array",
      "src::is.message",
      "src::data.message.channel",
      "src::event.listener.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from,isArray,is,Channel,add;\n    \n                    let var_init_locked_1608956298120;\n    \n                    let var_class_1608956298120;\n    \n                    \n\n                    let var_global_main_1608956298120 ;\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298120){\n\n            from = include('src::array.from');\nisArray = include('src::is.array');\nis = include('src::is.message');\nChannel = include('src::data.message.channel')();\nadd = include('src::event.listener.add');\n\n            \n/**\n * \n * 消息通道 Electron 渲染 WebView 版\n * \n * @import from from array.from\n * \n * @import is.array\n * \n * @import is from is.message\n * \n * @import Channel from data.message.channel value\n * \n * @import add from event.listener.add\n *\n * @param {object} config 配置 \n * \n * @require electron\n * \n */\nclass main extends Channel{\n\n    constructor({\n        webview,\n        ...options\n    }){\n\n        super({\n            ...options,\n            initFn(){\n\n                this.webview = webview ;\n            }\n        }) ;\n\n        this.isDestroyed = false ;\n    }\n\n    doReceive(receive){\n\n        let me = this,\n        {\n            webview\n        } = me ;\n\n        add(webview , 'ipc-message' , ({\n            channel,\n            args\n        }) => {\n\n            let message = args[0] ;\n\n            if(channel === 'ipc-message' && is(message)){\n\n                receive(message) ;\n            }\n        }) ;\n\n        add(webview , 'destroyed' , () => me.isDestroyed = true) ;\n    }\n\n    doSend(message){\n\n        let {\n            webview,\n            isDestroyed\n        } = this;\n\n        if(!isDestroyed){\n\n            webview.send('ipc-message' , message) ;\n        }\n    }\n }\n\n            var_class_1608956298120 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298120 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.message.channel.electron.renderer.webview' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298120 ;\n        \nvar_global_main_1608956298120 = main;\n\n            var_init_locked_1608956298120 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298120(config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.electron.renderer.webview"
  },
  "src::data.message.channel.electron.renderer": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.electron.renderer(<object> config)",
    "standard": true,
    "importNames": [
      "src::data.message.channel"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Channel;\n    \n                    let var_init_locked_1608956298126;\n    \n                    let var_class_1608956298126;\n    \n                    \n\n                    let var_global_main_1608956298126 ;\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298126){\n\n            Channel = include('src::data.message.channel')();\n\n            \n/**\n * \n * 消息通道Electron 渲染进程版\n * \n * @import Channel from data.message.channel value\n *\n * @param {object} config 配置 \n * \n */\n\n const {\n    ipcRenderer\n } = require('electron') ;\n\nclass main extends Channel{\n\n    constructor({\n        isWebview = false,\n        ...options\n    }){\n\n        super(options) ;\n\n        this.isWebview = isWebview ;\n    }\n\n    doReceive(receive){\n\n        ipcRenderer.on('ipc-message' , (event , message) => receive(message)) ;\n    }\n\n    doSend(message){\n\n        let {\n            isWebview\n        } = this ;\n\n        ipcRenderer[isWebview ? 'sendToHost' : 'send']('ipc-message' , message) ;\n    }\n }\n\n            var_class_1608956298126 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298126 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.message.channel.electron.renderer' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298126 ;\n        \nvar_global_main_1608956298126 = main;\n\n            var_init_locked_1608956298126 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298126(config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.electron.renderer"
  },
  "src::data.message.channel.process.child": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.process.child(<object> config)",
    "standard": true,
    "importNames": [
      "src::data.message.channel"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Channel;\n    \n                    let var_init_locked_1608956298130;\n    \n                    let var_class_1608956298130;\n    \n                    \n\n                    let var_global_main_1608956298130 ;\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298130){\n\n            Channel = include('src::data.message.channel')();\n\n            \n/**\n * \n * 消息通道子进程版\n * \n * @import Channel from data.message.channel value\n *\n * @param {object} config 配置 \n * \n */\n\n class main extends Channel{\n\n    doReceive(receive){\n\n        process.on('message' , receive) ;\n    }\n\n    doSend(message){\n\n        if(process.connected){\n\n            process.send(message) ;\n        }\n    }\n }\n\n            var_class_1608956298130 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298130 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.message.channel.process.child' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298130 ;\n        \nvar_global_main_1608956298130 = main;\n\n            var_init_locked_1608956298130 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298130(config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.process.child"
  },
  "src::data.message.channel.process.main": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.message.channel.process.main(<object> config)",
    "standard": true,
    "importNames": [
      "src::array.from",
      "src::is.object.simple",
      "src::data.message.channel"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from,isObject,Channel;\n    \n                    let var_init_locked_1608956298133;\n    \n                    let var_class_1608956298133;\n    \n                    \n\n                    let var_global_main_1608956298133 ;\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298133){\n\n            from = include('src::array.from');\nisObject = include('src::is.object.simple');\nChannel = include('src::data.message.channel')();\n\n            \n/**\n * \n * 消息通道主进程版\n * \n * @import from from array.from\n * \n * @import isObject from is.object.simple\n * \n * @import Channel from data.message.channel value\n *\n * @param {object} config 配置 \n * \n */\n\n const {\n    fork\n } = require('child_process') ;\n\n class main extends Channel{\n\n    constructor({\n        childProcess,\n        ...options\n    }){\n\n        super({\n            ...options,\n            initFn(){\n\n                if(isObject(childProcess)){\n\n                    let {\n                        path,\n                        args,\n                        ...options\n                    } = childProcess ;\n\n                    childProcess = fork(path , args , options) ;\n                }\n\n                this.childProcess = childProcess ;\n            }\n        }) ;\n    }\n\n    doReceive(receive){\n\n        let {\n            childProcess\n        } = this ;\n\n        childProcess.on('message' , message => receive(message)) ;\n    }\n\n    doSend(message){\n\n        let {\n            childProcess\n        } = this;\n\n        if(childProcess.connected){\n\n            childProcess.send(message) ;\n        }\n    }\n }\n\n            var_class_1608956298133 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298133 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.message.channel.process.main' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298133 ;\n        \nvar_global_main_1608956298133 = main;\n\n            var_init_locked_1608956298133 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298133(config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.message.channel.process.main"
  },
  "src::data.model": {
    "meta": "code.meta.script.function",
    "signature": "<data.Model> src::data.model(<object> model)",
    "standard": true,
    "importNames": [
      "src::data.reader.create"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let createReader;\n    \n                    let var_init_locked_1608956298135;\n    \n                    let var_class_1608956298135;\n    \n                    \n\n                    let var_global_main_1608956298135 ;\n    \n                    return function(model){\n    \n                        \n        if(!var_init_locked_1608956298135){\n\n            createReader = include('src::data.reader.create');\n\n            \n/**\n * \n * 数据模型类\n * \n * @import createReader from data.reader.create\n * \n * @param {object} model 数据模型定义\n * \n * @return {data.Model} 数据模型对象 \n * \n */\n\n class main{\n\n    constructor(model){\n\n        let me = this ;\n\n        me.reader = createReader(model) ;\n\n        me.data = {} ;\n    }\n\n    load(data){\n\n        let me = this,\n        {\n            reader\n        } = me ;\n\n        let result = reader.read(data) ;\n\n        if(result.length){\n\n            me.data = result[0] ;\n        }\n    }\n }\n\n            var_class_1608956298135 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298135 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.model' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298135 ;\n        \nvar_global_main_1608956298135 = main;\n\n            var_init_locked_1608956298135 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298135(model) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.model"
  },
  "src::data.observable": {
    "meta": "code.meta.script.function",
    "signature": "<data.Observable> src::data.observable()",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::object.property.inner.define",
      "src::object.property.inner.get",
      "src::object.property.inner.set",
      "src::is.data.item",
      "src::is.data.record",
      "src::is.data.recordset"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Observable,define,get,set,isItem,isRecord,isRecordset;\n    \n                    let var_init_locked_1608956298138;\n    \n                    let var_class_1608956298138;\n    \n                    \n\n                    let var_global_main_1608956298138 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298138){\n\n            Observable = include('src::mixin.observable');\ndefine = include('src::object.property.inner.define');\nget = include('src::object.property.inner.get');\nset = include('src::object.property.inner.set');\nisItem = include('src::is.data.item');\nisRecord = include('src::is.data.record');\nisRecordset = include('src::is.data.recordset');\n\n            \n/**\n * \n * 创建数据记录观察器\n * \n * @import Observable from mixin.observable\n * \n * @import define from object.property.inner.define\n * \n * @import get from object.property.inner.get\n * \n * @import set from object.property.inner.set\n * \n * @import isItem from is.data.item\n * \n * @import isRecord from is.data.record\n * \n * @import isRecordset from is.data.recordset\n * \n * @return {data.Observable} 数据观察者对象 \n * \n */\n\n class main extends mixins({\n     mixins:[\n        Observable\n     ]\n }){\n\n    constructor(){\n\n        super() ;\n\n        define(this , 'bubbleTarget') ;\n    }\n\n    get  belongToObservable(){\n\n        return  get(this , 'bubbleTarget') ;\n    }\n\n    belongTo(dataItem){\n\n        let me = this ;\n\n        if(me.isIndependent && isItem(dataItem)){\n\n            set(me , 'bubbleTarget' , get(dataItem , 'observable')) ;\n        }\n    }\n\n    get isIndependent(){\n\n        return !get(this , 'bubbleTarget') ;\n    }\n\n    independent(){\n\n        let me = this,\n        {\n            isIndependent\n        } = me ;\n\n        if(isIndependent){\n\n            return ;\n        }\n   \n        set(me , 'bubbleTarget' , null) ;\n    }\n }\n\n            var_class_1608956298138 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298138 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.observable' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298138 ;\n        \nvar_global_main_1608956298138 = main;\n\n            var_init_locked_1608956298138 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298138() ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.observable"
  },
  "src::is.data.item": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.data.item(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.object",
      "src::object.property.inner.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,get;\n    \n                    let var_init_locked_1608956298142;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断是否为数据项\n * \n * @import is.object\n * \n * @import get from object.property.inner.get\n * \n * @param {mixed} data 数据\n * \n * @return {boolean} 判断结果 \n * \n */\n\n return isObject(data) && get(data , 'DATA_RECORD') === true ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298142){\n\n            isObject = include('src::is.object');\nget = include('src::object.property.inner.get');\n\n            var_init_locked_1608956298142 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.data.item"
  },
  "src::is.data.record": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.data.record(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::is.data.item"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,is;\n    \n                    let var_init_locked_1608956298144;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判定指定数据是否为数据记录\n * \n * @import isObject from is.object.simple\n * \n * @import is from .item\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果为数据记录则返回 true , 否则返回 false \n * \n */\n\n return is(data) && isObject(data);\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298144){\n\n            isObject = include('src::is.object.simple');\nis = include('src::is.data.item');\n\n            var_init_locked_1608956298144 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.data.record"
  },
  "src::is.data.recordset": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.data.recordset(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.array",
      "src::is.data.item"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isArray,is;\n    \n                    let var_init_locked_1608956298147;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判定指定数据是否为数据记录集合\n * \n * @import is.array\n * \n * @import is from .item\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果为数据记录则返回 true , 否则返回 false \n * \n */\n\n return is(data) && isArray(data) ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298147){\n\n            isArray = include('src::is.array');\nis = include('src::is.data.item');\n\n            var_init_locked_1608956298147 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.data.recordset"
  },
  "src::data.proxy.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.proxy.constructor({<mixed> reader , <mixed> model})",
    "standard": true,
    "importNames": [
      "src::object.proxy",
      "src::data.reader.json"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let createProxy,createReader;\n    \n                    let var_init_locked_1608956298149;\n    \n                    \n\n                    function main({reader , model}){\n\n        \n/**\n * \n * 初始化数据代理\n * \n * @import createProxy from object.proxy\n * \n * @import createReader from data.reader.json\n * \n * @param {object} [options = {}] 配置\n * \n * @param {mixed} [options.reader = {}] 配置读取器\n * \n * @param {mixed} [options.model] 数据模型\n * \n */\n\n let me = this ;\n\n me.proxy = createProxy(me) ;\n\n me.reader = createReader({\n     ...reader,\n     model\n }) ;\n\n    }\n    \n                    return function({reader = {} , model} = {}){\n    \n                        \n        if(!var_init_locked_1608956298149){\n\n            createProxy = include('src::object.proxy');\ncreateReader = include('src::data.reader.json');\n\n            var_init_locked_1608956298149 = true ;\n        }\n        \n    \n                        return main.call(this , {reader , model}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.proxy.constructor"
  },
  "src::data.reader.fields": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::data.reader.fields(<mixed> fields)",
    "standard": true,
    "importNames": [
      "src::is.defined",
      "src::is.array",
      "src::is.object.simple",
      "src::is.string",
      "src::is.number",
      "src::function.empty",
      "src::is.function",
      "src::data.reader"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined,isArray,isObject,isString,isNumber,empty,isFunction,createReader;\n    \n                    let var_init_locked_1608956298161;\n    \n                    \n\n                    \n/**\n * \n * 数据读取器字段配置\n * \n * @import is.defined\n * \n * @import is.array\n * \n * @import isObject from is.object.simple\n * \n * @import is.string\n * \n * @import is.number\n * \n * @import empty from function.empty value\n * \n * @import is.function\n * \n * @import is.defined\n * \n * @import isObject from is.object.simple\n * \n * @import createReader from data.reader\n * \n * @param {mixed} fields 字段配置\n * \n * @return {mixed} 封装后的字段配置 \n * \n */\n\n function main(fields){\n\n    let result = [],\n        me = this;\n     \n    if(isObject(fields)){\n\n        let names = Object.keys(fields) ;\n\n        for(let name of names){\n\n            let config = fields[name] ;\n\n            if(isString(config)){\n\n                config = {\n                    name,\n                    mapping:config\n                }\n            \n            }else if(isFunction(config)){\n\n                config = {\n                    name,\n                    convert:config\n                } ;\n            }\n\n            if(isObject(config)){\n\n                result.push(getField.call(me , {\n                    ...config,\n                    name\n                })) ;\n            }\n        }\n\n    }else if(isArray(fields)){\n\n        for(let field of fields){\n\n            if(isString(field)){\n\n                field = {\n                    name:field,\n                    mapping:field\n                } ;\n            }\n\n            if(isObject(field)){\n\n                result.push(getField.call(me , field)) ;\n            }\n        }\n    }\n\n    return result ;\n }\n\n function processDefaultValue(defaultValue) {\n     \n    if(isFunction(defaultValue)){\n\n        return defaultValue ;\n    }\n\n    return () => defaultValue ;\n }\n\n function getField({\n    name,\n    type,\n    mapping,\n    convert,\n    local = false,\n    equals,\n    set,\n    afterSet,\n    get,\n    defaultValue,\n    reader,\n    mode = 'readonly',\n    ...options\n}) {\n\n   const me = this,\n   {\n       getData\n   } = me;\n\n   defaultValue = processDefaultValue(defaultValue) ;\n\n    let field = {\n        name,\n        mode,\n        equals,\n        get,\n        defaultValue,\n        afterSet\n    }  ;\n\n    if(isString(type) && !isFunction(set)){\n\n        field.set = value => include(`data.convert.${type}`)(value , options) ;\n    \n    }else{\n\n        field.set = set ;\n\n    }\n\n    if(!local){\n\n       field.convert = (raw , raws , index , data) =>{\n\n            if(isDefined(reader)){\n\n                if(isFunction(reader)){\n\n                    return me.read(data , data => reader(data , raw , raws , index)) ;\n                \n                }else if(isString(reader)){\n\n                    return me.read(data , reader) ;\n                \n                }else if(isObject(reader)){\n\n                    let {\n                        fields,\n                        root,\n                        addFields,\n                        ...options\n                    } = reader,\n                    rootProperty;\n\n                    if(isFunction(root)){\n\n                        rootProperty = data => root(data , raw , raws , index) ;\n                    \n                    }else{\n\n                        rootProperty = root ;\n                    }\n\n                    let readConfig = {\n                        root:rootProperty,\n                        ...options\n                    } ;\n\n                    if(fields){\n\n                        return createReader(fields , addFields).read(data , readConfig) ;\n                    }\n\n                    return me.read(data , readConfig) ;\n                }\n\n                return [] ;\n\n            }else if(isFunction(convert)){\n\n                raw = convert(raw , raws , index , data) ;\n            \n            }else{\n\n                if(isString(mapping)){\n\n                    raw = getData(raw , mapping) ;\n                \n                }else{\n\n                    raw = getData(raw , name) ;\n                }\n\n                if(isString(type)){\n\n                    raw = include(`data.convert.${type}`)(raw , options) ;\n                }\n\n            }\n\n            if(isDefined(raw)){\n\n                if(typeof raw === 'number' && isNaN(raw)){\n\n                    return defaultValue() ;\n                }\n\n                return raw ;\n            }\n\n            return defaultValue() ;\n\n        } ;\n    \n    }else{\n\n        field.convert = () => defaultValue() ;\n    }\n\n    return field ;\n}\n    \n                    return function(fields){\n    \n                        \n        if(!var_init_locked_1608956298161){\n\n            isDefined = include('src::is.defined');\nisArray = include('src::is.array');\nisObject = include('src::is.object.simple');\nisString = include('src::is.string');\nisNumber = include('src::is.number');\nempty = include('src::function.empty')();\nisFunction = include('src::is.function');\nisDefined = include('src::is.defined');\nisObject = include('src::is.object.simple');\ncreateReader = include('src::data.reader');\n\n            var_init_locked_1608956298161 = true ;\n        }\n        \n    \n                        return main.call(this , fields) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.reader.fields"
  },
  "src::object.property.inner.has": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::object.property.inner.has(<object> target , <string> name)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let innerName;\n    \n                    let var_init_locked_1608956298175;\n    \n                    \n\n                    function main(target , name){\n\n        \n/**\n * \n * 判断是否拥有内置属性\n * \n *  @import innerName from .name\n * \n * @param {object} target  定义内部属性的宿主\n * \n * @param {string} name 内部属性名称\n * \n * @return {boolean} 如果拥有指定内部属性则返回 true , 否则返回 false\n * \n */\n\n return target.hasOwnProperty(innerName(name)) ;\n\n    }\n    \n                    return function(target , name){\n    \n                        \n        if(!var_init_locked_1608956298175){\n\n            innerName = include('src::object.property.inner.name');\n\n            var_init_locked_1608956298175 = true ;\n        }\n        \n    \n                        return main.call(this , target , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.inner.has"
  },
  "src::object.property.define.set": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.property.define.set(<string> name , <function> onSet , <function> onAfterSet , <function> isEquals)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::data.equals",
      "src::object.property.inner.get",
      "src::object.property.inner.set",
      "src::object.property.inner.has"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction,equals,get,set,has;\n    \n                    let var_init_locked_1608956298173;\n    \n                    \n\n                    function main(name , onSet , onAfterSet , isEquals){\n\n        \n/**\n * \n * 设置属性\n * \n * @import is.function\n * \n * @import equals from data.equals\n * \n * @import get from ..inner.get\n * \n * @import set from ..inner.set\n * \n * @import has from ..inner.has\n * \n * @param {string} name 属性名称\n * \n * @param {function} [onSet] 设置属性值\n * \n * @param {function} [onAfterSet] 设置属性值之后调用\n * \n * @param {function} [isEquals] 属性值判断是否相等，只在启动改变属性事件有效\n * \n */\n \n isEquals = isEquals || equals ;\n\n return function(value){\n\n    let me = this,\n        oldValue = get(me , name) ;\n\n    if(!isEquals.call(me , value , oldValue)){\n\n        if(isFunction(onSet)){\n\n            value = onSet.call(me , value , oldValue) ;\n        }\n\n        set(me , name , value) ;\n\n        if(isFunction(onAfterSet)){\n\n            value = onAfterSet.call(me , value) ;\n        }\n    }\n} ;\n\n    }\n    \n                    return function(name , onSet , onAfterSet , isEquals){\n    \n                        \n        if(!var_init_locked_1608956298173){\n\n            isFunction = include('src::is.function');\nequals = include('src::data.equals');\nget = include('src::object.property.inner.get');\nset = include('src::object.property.inner.set');\nhas = include('src::object.property.inner.has');\n\n            var_init_locked_1608956298173 = true ;\n        }\n        \n    \n                        return main.call(this , name , onSet , onAfterSet , isEquals) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.define.set"
  },
  "src::object.property.define.get": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.property.define.get(<string> name , <function> onGet)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::object.property.inner.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction,get;\n    \n                    let var_init_locked_1608956298177;\n    \n                    \n\n                    function main(name , onGet){\n\n        \n/**\n * \n * 获取属性\n * \n * @import is.function\n * \n * @import get from ..inner.get\n * \n * @param {string} name 属性名称\n * \n * @param {function} onGet 获取属性值\n * \n */\n \nreturn function(){\n\n   let me = this,\n       value = get(me , name) ;\n\n   if(isFunction(onGet)){\n\n       return onGet.call(me , value) ;\n   }\n\n   return value ;\n} ;\n\n    }\n    \n                    return function(name , onGet){\n    \n                        \n        if(!var_init_locked_1608956298177){\n\n            isFunction = include('src::is.function');\nget = include('src::object.property.inner.get');\n\n            var_init_locked_1608956298177 = true ;\n        }\n        \n    \n                        return main.call(this , name , onGet) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.define.get"
  },
  "src::object.property.define": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.property.define(<object> target , <string|object> name , {<boolean> mode , <string> value , <boolean> equals , <function> set , <function> afterSet , <function> get})",
    "standard": true,
    "importNames": [
      "src::object.property.inner.define",
      "src::is.function",
      "src::object.property.define.set",
      "src::object.property.define.get",
      "src::is.object.simple",
      "src::object.property.define"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let innerDefine,isFunction,doSet,doGet,isObject,define;\n    \n                    let var_init_locked_1608956298170;\n    \n                    \n\n                    function main(target , name , {mode , value , equals , set , afterSet , get}){\n\n        /**\n * \n * 定义一个缓存属性\n * \n * @import innerDefine from .inner.define\n * \n * @import is.function\n * \n * @import doSet from .define.set\n * \n * @import doGet from .define.get\n * \n * @import isObject from is.object.simple\n * \n * @import define from .define\n * \n * @param {object} target 目标对象\n * \n * @param {string|object} name 属性名称\n * \n * @param {object} [options = {}] 属性配置\n * \n * @param {boolean} options.mode 读写模式\n * \n * @param {string} [options.value] 属性初始始化值\n * \n * @param {boolean} [options.equals] 判断属性值是否相等\n * \n * @param {function} [options.set] 设置值\n * \n * @param {function} [options.afterSet] 设置值之后调用\n * \n * @param {function} [options.get] 获取值\n * \n */\n\n if(isObject(name)){\n\n    let properties = name ;\n\n    let names = Object.keys(properties) ;\n\n    for(let name of names){\n\n        define(target , name , properties[name]) ;\n    }\n\n }else{\n\n    switch(mode){\n    \n        case 'readonly':\n    \n            if(isFunction(get)){\n    \n                Object.defineProperty(target , name , {\n                    get:doGet(name , get),\n                    configurable:true,\n                    enumerable:true\n                }) ;\n    \n                innerDefine(target , name , value) ;\n    \n            }else{\n    \n                Object.defineProperty(target , name , {\n                    value,\n                    configurable:true,\n                    enumerable:true\n                }) ;\n            }\n    \n            break ;\n    \n        case 'writeonly':\n    \n            Object.defineProperty(target , name , {\n                set:doSet(name , set , afterSet , equals),\n                configurable:true,\n                enumerable:true\n            }) ;\n    \n            innerDefine(target , name , value) ;\n    \n            break ;\n    \n        case 'readwrite':\n\n            Object.defineProperty(target , name , {\n                set:doSet(name , set , afterSet , equals),\n                get:doGet(name , get),\n                configurable:true,\n                enumerable:true\n            }) ;\n    \n            innerDefine(target , name , value) ;\n    \n    }\n }\n\n    }\n    \n                    return function(target , name , {mode , value , equals , set , afterSet , get} = {}){\n    \n                        \n        if(!var_init_locked_1608956298170){\n\n            innerDefine = include('src::object.property.inner.define');\nisFunction = include('src::is.function');\ndoSet = include('src::object.property.define.set');\ndoGet = include('src::object.property.define.get');\nisObject = include('src::is.object.simple');\ndefine = include('src::object.property.define');\n\n            var_init_locked_1608956298170 = true ;\n        }\n        \n    \n                        return main.call(this , target , name , {mode , value , equals , set , afterSet , get}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.define"
  },
  "src::data.reader.record": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.reader.record(<mixed> record , <mixed> raw , <array> raws , <number> index , <mixed> data , <function> addFields)",
    "standard": true,
    "importNames": [
      "src::id.generate",
      "src::object.property.define",
      "src::object.property.inner.define",
      "src::is.data.item",
      "src::is.defined",
      "src::is.array",
      "src::data.reader.fields"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let generate,define,innerDefine,is,isDefined,isArray,getFields;\n    \n                    let var_init_locked_1608956298165;\n    \n                    \n\n                    \n/**\n * \n * 根据获取原始数据转换后正式数据\n * \n * @import generate from id.generate\n * \n * @import define from object.property.define\n * \n * @import innerDefine from object.property.inner.define\n * \n * @import is from is.data.item\n * \n * @import is.defined\n * \n * @import is.array\n * \n * @import getFields from .fields\n * \n * @param {mixed} record 数据记录 \n * \n * @param {mixed} raw 行级原始数据\n * \n * @param {array} raws 一组行级原始数据\n * \n * @param {number} index 原始数据下标\n * \n * @param {mixed} data 原始数据\n * \n * @param {function} [addFields = () => {}] 自定义数据记录\n * \n * @return {object} 正式数据\n * \n */\n\n function main(record , raw , raws , index , data , addFields){\n\n    let me = this,\n    {\n        fields\n    } = me,\n    isConvert = isDefined(raw) && isDefined(raws) && isDefined(index) && isDefined(data) ;\n\n    record = record || {} ;\n\n    innerDefine(record , 'DATA_RECORD' , true) ;\n\n    processFields(isConvert , record , fields , raw , raws , index , data) ;\n\n    let additionalFields = addFields(record) ;\n\n    if(isDefined(additionalFields)){\n\n        additionalFields = getFields.call(me , additionalFields) ;\n\n        processFields(isConvert , record , additionalFields , raw , raws , index , data) ;\n    }\n    \n    return record ;\n }\n\n function processFields(isConvert , record , fields , raw , raws , index , data){\n\n    for(let {\n        name,\n        convert,\n        mode,\n        equals,\n        set,\n        afterSet,\n        get,\n        defaultValue\n    } of fields){\n\n        if(record.hasOwnProperty(name)){\n\n            continue ;\n        }\n    \n        if(isConvert){\n    \n            let value = convert(raw , raws , index , data) ;\n    \n            define(record , name , {\n                mode,\n                equals,\n                set,\n                afterSet,\n                get,\n                value\n            }) ;\n        \n        }else{\n\n            let config = {\n                mode,\n                equals,\n                set,\n                afterSet,\n                get\n            } ;\n\n            if(raw){\n\n                let value = raw[name] ;\n\n                config.value = isDefined(value) ? value : defaultValue() ;\n            \n            }else{\n\n                config.value = defaultValue() ;\n            }\n    \n            define(record , name , config) ;\n        }\n    }\n }\n    \n                    return function(record , raw , raws , index , data , addFields = () => {}){\n    \n                        \n        if(!var_init_locked_1608956298165){\n\n            generate = include('src::id.generate');\ndefine = include('src::object.property.define');\ninnerDefine = include('src::object.property.inner.define');\nis = include('src::is.data.item');\nisDefined = include('src::is.defined');\nisArray = include('src::is.array');\ngetFields = include('src::data.reader.fields');\n\n            var_init_locked_1608956298165 = true ;\n        }\n        \n    \n                        return main.call(this , record , raw , raws , index , data , addFields) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.reader.record"
  },
  "src::data.reader.raws": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::data.reader.raws(<mixed> data , <string> root)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction,from;\n    \n                    let var_init_locked_1608956298180;\n    \n                    \n\n                    function main(data , root){\n\n        \n/**\n * \n * 获取一组原始数据用来解析数据记录\n * \n * @import is.function\n * \n * @import from from array.from\n * \n * @param {mixed} data 原始数据\n * \n * @param {string} root 根遍历路径\n * \n * @return {array} 一组原始数据 \n * \n */\n\nlet {\n    getData\n} = this,\nraws;\n\nif(isFunction(root)){\n\n    raws = root(data) ;\n\n}else{\n\n    raws = getData(data , root) ;\n}\n\nreturn from(raws) ;\n\n    }\n    \n                    return function(data , root){\n    \n                        \n        if(!var_init_locked_1608956298180){\n\n            isFunction = include('src::is.function');\nfrom = include('src::array.from');\n\n            var_init_locked_1608956298180 = true ;\n        }\n        \n    \n                        return main.call(this , data , root) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.reader.raws"
  },
  "src::data.reader.names": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.reader.names(<array> fields)",
    "standard": true,
    "importNames": [
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1608956298185;\n    \n                    \n\n                    function main(fields){\n\n        \n/**\n * \n * 根据字段定义获取相关字段名称信息\n * \n * @import is.function\n * \n * @param {array} fields 字段集合\n * \n * @return {object} 名称集合\n * \n */\n\n let names = [] ;\n\nfor(let {\n    name\n} of fields){\n\n    names.push(name) ;\n}\n\nreturn names ;\n\n    }\n    \n                    return function(fields){\n    \n                        \n        if(!var_init_locked_1608956298185){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1608956298185 = true ;\n        }\n        \n    \n                        return main.call(this , fields) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.reader.names"
  },
  "src::data.reader.data": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::data.reader.data(<data.Record> record , <object> options)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.define",
      "src::object.property.inner.get",
      "src::object.clear",
      "src::data.clone",
      "src::is.function",
      "src::data.reader.fields",
      "src::is.defined",
      "src::data.reader.names"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let define,get,clear,clone,isFunction,getFields,isDefined,getNames;\n    \n                    let var_init_locked_1608956298182;\n    \n                    \n\n                    \n/**\n * \n * 基于数据记录生成一个与之对应的只读数据对象\n * \n * @import define from object.property.inner.define\n * \n * @import get from object.property.inner.get\n * \n * @import clear from object.clear\n * \n * @import clone from data.clone\n * \n * @import is.function\n * \n * @import getFields from .fields\n * \n * @import is.defined\n * \n * @import getNames from .names\n * \n * @param {data.Record} record 数据记录\n * \n * @param {object} [options = {}] 配置\n * \n * @return {object} 数据对象\n * \n */\n\n const {\n    defineProperty\n } = Object ;\n\n function main(record , {\n    ignoreFields = [],\n    fields = {}\n }){\n\n    let me = this,\n    {\n        names\n    } = me,\n    addNames = getNames(me.getAddFields(record));\n\n    names = [\n        ...names,\n        ...addNames,\n        ...Object.keys(fields)\n    ] ;\n\n    names = Array.from(new Set(names)) ;\n\n    let data = {},\n        cache = {};\n\n    for(let name of names){\n\n        if(ignoreFields.includes(name)){\n\n            continue ;\n        }\n\n        defineProperty(data , name , {\n            get(){\n\n                if(cache.hasOwnProperty(name)){\n\n                    return cache[name] ;\n                }\n\n                if(fields.hasOwnProperty(name)){\n\n                    return cache[name] = clone(fields[name](record)) ;\n                }\n\n                return cache[name] = clone(record[name]) ;\n            },\n            enumerable:true\n        }) ;\n    }\n\n    return data ;\n }\n    \n                    return function(record , options = {}){\n    \n                        \n        if(!var_init_locked_1608956298182){\n\n            define = include('src::object.property.inner.define');\nget = include('src::object.property.inner.get');\nclear = include('src::object.clear');\nclone = include('src::data.clone');\nisFunction = include('src::is.function');\ngetFields = include('src::data.reader.fields');\nisDefined = include('src::is.defined');\ngetNames = include('src::data.reader.names');\n\n            var_init_locked_1608956298182 = true ;\n        }\n        \n    \n                        return main.call(this , record , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.reader.data"
  },
  "src::data.reader": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.reader()",
    "standard": true,
    "importNames": [
      "src::data.reader.fields",
      "src::data.reader.record",
      "src::data.reader.raws",
      "src::is.object.simple",
      "src::data.reader.data",
      "src::data.reader.names",
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getFields,getRecord,getRaws,isObject,createData,getNames,isDefined;\n    \n                    let var_init_locked_1608956298154;\n    \n                    let var_class_1608956298154;\n    \n                    \n\n                    let var_global_main_1608956298154 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298154){\n\n            getFields = include('src::data.reader.fields');\ngetRecord = include('src::data.reader.record');\ngetRaws = include('src::data.reader.raws');\nisObject = include('src::is.object.simple');\ncreateData = include('src::data.reader.data');\ngetNames = include('src::data.reader.names');\nisDefined = include('src::is.defined');\n\n            /**\n * \n * 数据读取器\n * \n * @import getFields from .reader.fields\n * \n * @import getRecord from .reader.record\n * \n * @import getRaws from .reader.raws\n * \n * @import isObject from is.object.simple\n * \n * @import createData from .reader.data\n * \n * @import getNames from .reader.names\n * \n * @import is.defined\n * \n * @class\n * \n */\n\n class main {\n\n    constructor(fields = [] , addFields){\n\n        let me = this ;\n\n        fields = getFields.call(me , fields) ;\n\n        me.addFields = addFields ;\n\n        let names = getNames(fields) ;\n\n        me.names = names ;\n\n        me.fields = fields ;\n    }\n\n    data(record , options){\n\n        return createData.call(this , record , options) ;\n    }\n\n    getAddFieldNames(record){\n\n        let {\n            names\n        } = this.getAddFields(record) ;\n\n        return names ;\n    }\n\n    getAddFields(record){\n\n        let me = this,\n        {\n            addFields\n        } = me,\n        additionalFields = addFields(record);\n    \n        if(isDefined(additionalFields)){\n    \n            return getFields.call(me , additionalFields) ;\n        }\n    \n        return [] ;\n    }\n\n    create(data){\n\n        let me = this,\n        {\n            addFields\n        } = me ;\n\n        return getRecord.call(me , undefined , data , undefined , undefined , undefined , addFields) ;\n    }\n\n    read(data , root = '.'){\n\n        let config = {\n            root:'.',\n            multi:true\n        } ;\n\n        if(isObject(root)){\n\n            Object.assign(config , root) ;\n        \n        }else{\n\n            config.root = root ;\n        }\n\n        root = config.root ;\n\n        let {\n            multi\n        } = config,\n        me = this,\n        {\n            addFields\n        } = me,\n        raws = getRaws.call(me , data , root),\n        records = [],\n        count = 0;\n\n        if(multi === false && raws.length){\n\n            return getRecord.call(me , null , raws[0] , raws , count , data , addFields) ;\n        }\n\n        for(let raw of raws){\n\n            records.push(getRecord.call(me , null , raw , raws , count ++ , data , addFields)) ;\n        }\n\n        return records ;\n    }\n }\n\n            var_class_1608956298154 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298154 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.reader' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298154 ;\n        \nvar_global_main_1608956298154 = main;\n\n            var_init_locked_1608956298154 = true ;\n        }\n        \n    \n                        return var_global_main_1608956298154 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.reader"
  },
  "src::string.split": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::string.split(<String> target , <RegEx> splitRe)",
    "standard": true,
    "importNames": [
      "src::is.empty"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isEmpty;\n    \n                    let var_init_locked_1608956298190;\n    \n                    \n\n                    \n/**\n * \n * 将字符串通过间隔符分隔成数组\n * \n * @import is.empty\n * \n * @param {String} target 字符串\n * \n * @param {RegEx} splitRe 字符串分隔符\n * \n * @scoped\n * \n */\n\nfunction main(target , splitRe){\n\n    return target.split(splitRe).filter(filter) ;\n }\n\n function filter(target){\n\n    return !isEmpty(target) ;\n }\n    \n                    return function(target , splitRe){\n    \n                        \n        if(!var_init_locked_1608956298190){\n\n            isEmpty = include('src::is.empty');\n\n            var_init_locked_1608956298190 = true ;\n        }\n        \n    \n                        return main.call(this , target , splitRe) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "string.split"
  },
  "src::object.value.get": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::object.value.get(<object> data , <string> key)",
    "standard": true,
    "importNames": [
      "src::string.split",
      "src::is.object",
      "src::is.array"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let split,isObject,isArray;\n    \n                    let var_init_locked_1608956298188;\n    \n                    \n\n                    function main(data , key){\n\n        \n/**\n * \n * 获得一个对象的键值\n * \n * @import split from string.split\n * \n * @import is.object\n * \n * @import is.array\n * \n * @param {object} data 对象数据\n * \n * @param {string} [key = '.'] 对象键值\n * \n * @return {mixed} 对应对象数据的键值的数据 \n * \n */\n\nif(key === '.'){\n\n    return data ;\n}\n\nconst arrayItemRe1 = /^(\\w+)\\[(\\d+)\\]$/,\n      arrayItemRe2 = /^\\[(\\d+)\\]$/;\n\nif(isObject(data) || isArray(data)){\n\n    let keys = split(key , /\\./),\n        result;\n\n    for(let key of keys){\n\n        if(arrayItemRe1.test(key) || arrayItemRe2.test(key)){\n\n            {\n                let keyMatch = key.match(arrayItemRe1) ;\n    \n                if(keyMatch){\n    \n                    result = data[keyMatch[1]][Number(keyMatch[2])] ;\n                \n                }\n            }\n    \n            {\n                let keyMatch = key.match(arrayItemRe2) ;\n    \n                if(keyMatch){\n    \n                    result = data[Number(keyMatch[1])] ;\n                \n                }\n            }\n        \n        }else{\n\n            result = data[key] ;\n        }\n\n        if(isObject(result) || isArray(result)){\n\n            data = result ;\n        \n        }else{\n\n            break ;\n        }\n    }\n\n    return result ;\n}\n\n    }\n    \n                    return function(data , key = '.'){\n    \n                        \n        if(!var_init_locked_1608956298188){\n\n            split = include('src::string.split');\nisObject = include('src::is.object');\nisArray = include('src::is.array');\n\n            var_init_locked_1608956298188 = true ;\n        }\n        \n    \n                        return main.call(this , data , key) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.value.get"
  },
  "src::data.reader.json": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.reader.json(<object> fields , <function> addFields)",
    "standard": true,
    "importNames": [
      "src::data.reader",
      "src::object.value.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Reader,get;\n    \n                    let var_init_locked_1608956298151;\n    \n                    let var_class_1608956298151;\n    \n                    \n\n                    let var_global_main_1608956298151 ;\n    \n                    return function(fields , addFields){\n    \n                        \n        if(!var_init_locked_1608956298151){\n\n            Reader = include('src::data.reader')();\nget = include('src::object.value.get');\n\n            /**\n * \n * JSON 数据读取器\n * \n * @import Reader from data.reader value\n * \n * @import get from object.value.get\n * \n * @param {object} fields 字段配置\n * \n * @param {function} addFields 附加字段配置\n * \n */\n\n class main extends Reader{\n\n   getData(data , path){\n\n      return get(data , path) ;\n   }\n   \n }\n\n            var_class_1608956298151 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298151 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.reader.json' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298151 ;\n        \nvar_global_main_1608956298151 = main;\n\n            var_init_locked_1608956298151 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298151(fields , addFields) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.reader.json"
  },
  "src::data.proxy.create": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::data.proxy.create(<mixed> proxy)",
    "standard": true,
    "importNames": [
      "src::class.create.option"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let create;\n    \n                    let var_init_locked_1608956298192;\n    \n                    \n\n                    function main(proxy){\n\n        \n/**\n * \n * 创建新的代理\n * \n * @import create from class.create.option\n * \n * @param {mixed} [proxy = 'memory'] 数据代理\n * \n * @return {mixed} 数据代理 \n * \n */\n\n return create('data.proxy' , proxy) ;\n\n    }\n    \n                    return function(proxy = 'memory'){\n    \n                        \n        if(!var_init_locked_1608956298192){\n\n            create = include('src::class.create.option');\n\n            var_init_locked_1608956298192 = true ;\n        }\n        \n    \n                        return main.call(this , proxy) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.proxy.create"
  },
  "src::class.create.option": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::class.create.option(<string> namespace , <mixed> option)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.object.simple",
      "src::is.class",
      "src::class.create",
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isObject,isClass,create,isDefined;\n    \n                    let var_init_locked_1608956298194;\n    \n                    \n\n                    function main(namespace , option){\n\n        /**\n * \n * 基于配置的实例\n * \n * @import is.string\n * \n * @import isObject from is.object.simple\n * \n * @import is.class\n * \n * @import create from class.create\n * \n * @import is.defined\n * \n * @param {string} namespace 命名空间\n * \n * @param {mixed}  [option] 配置\n * \n * @return {mixed} 类实例\n * \n */\n\n if(isString(option)){\n\n    return create(`${namespace}.${option}`) ;\n\n }else if(isObject(option)){\n\n    let {\n        type,\n        ...currentOptions\n    } = option,\n    name;\n\n    if(type){\n\n        name = `${namespace}.${type}` ;\n    \n    }else{\n\n        name = namespace ;\n    }\n\n    return create(name , currentOptions) ;\n \n}else if(!isDefined(options)){\n\n    return create(namespace) ;\n}\n\n    }\n    \n                    return function(namespace , option){\n    \n                        \n        if(!var_init_locked_1608956298194){\n\n            isString = include('src::is.string');\nisObject = include('src::is.object.simple');\nisClass = include('src::is.class');\ncreate = include('src::class.create');\nisDefined = include('src::is.defined');\n\n            var_init_locked_1608956298194 = true ;\n        }\n        \n    \n                        return main.call(this , namespace , option) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "class.create.option"
  },
  "src::data.proxy.memory": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.proxy.memory(<object> options)",
    "standard": true,
    "importNames": [
      "src::data.proxy"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Proxy;\n    \n                    let var_init_locked_1608956298196;\n    \n                    let var_class_1608956298196;\n    \n                    \n\n                    let var_global_main_1608956298196 ;\n    \n                    return function(options){\n    \n                        \n        if(!var_init_locked_1608956298196){\n\n            Proxy = include('src::data.proxy')();\n\n            \n/**\n * \n * 内存数据代理\n * \n * @param {object} options 配置\n * \n * @import Proxy from data.proxy value\n * \n */\n\n class main extends Proxy{\n\n    get proxyType(){\n\n        return 'memory' ;\n    }\n\n    doRead(data){\n\n        return data; \n    }\n }\n\n            var_class_1608956298196 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298196 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.proxy.memory' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298196 ;\n        \nvar_global_main_1608956298196 = main;\n\n            var_init_locked_1608956298196 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298196(options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.proxy.memory"
  },
  "src::data.proxy.read": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.proxy.read(<mixed> options)",
    "standard": true,
    "importNames": [
      "src::is.promise"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isPromise;\n    \n                    let var_init_locked_1608956298202;\n    \n                    \n\n                    \n/**\n * \n * 读取数据\n * \n * @import is.promise\n * \n * @param {mixed} options 读取数据配置\n * \n */\n\nfunction fireReadEvent(data){\n\n    let me = this,\n    {\n        reader\n    } = me ;\n\n    me.fireEvent('read' , reader(data)) ;\n}\n\nfunction main(options){\n\n    let me = this,\n    {\n        proxy\n    } = me,\n    data = proxy.call('doRead' , options);\n   \n    if(isPromise(data)){\n   \n       data.then(data => fireReadEvent.call(me , data)) ;\n    \n    }else{\n\n        fireReadEvent.call(me , data) ;\n    }\n}\n\n\n\n    \n                    return function(options){\n    \n                        \n        if(!var_init_locked_1608956298202){\n\n            isPromise = include('src::is.promise');\n\n            var_init_locked_1608956298202 = true ;\n        }\n        \n    \n                        return main.call(this , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.proxy.read"
  },
  "src::data.proxy": {
    "meta": "code.meta.class",
    "signature": "<void> src::data.proxy()",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::class.empty",
      "src::data.proxy.constructor",
      "src::data.proxy.read",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let mixin_1608956298199__1,extend,constructor,method_read,isObject;\n    \n                    let var_init_locked_1608956298200;\n    \n                    let var_class_1608956298200;\n    \n                    \n\n                    let var_global_main_1608956298200 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298200){\n\n            mixin_1608956298199__1 = include('src::mixin.observable');\nextend = include('src::class.empty')();\nconstructor = include('src::data.proxy.constructor');\nmethod_read = include('src::data.proxy.read');\nisObject = include('src::is.object.simple');\n\n            class main extends mixins({extend , mixins:[include('mixin.observable')]}){\n\n            \n\n            \n\n            constructor(...args){\n\n            super(...args) ;\n\n            constructor.apply(this , args) ;\n\n        }\n\n            read(...args){\n\n            return method_read.apply(this , args) ;\n\n        }\n\n            \n\n        }\n\n            var_class_1608956298200 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298200 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.proxy' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298200 ;\n        \nvar_global_main_1608956298200 = main;\n\n            var_init_locked_1608956298200 = true ;\n        }\n        \n    \n                        return var_global_main_1608956298200 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.proxy"
  },
  "src::data.recordset": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::data.recordset(<data.Reader> reader , <array> records)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.define",
      "src::object.property.inner.get",
      "src::data.observable",
      "src::is.data.record",
      "src::is.array",
      "src::is.class"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let define,get,createObservable,is,isArray,isClass;\n    \n                    let var_init_locked_1608956298207;\n    \n                    \n\n                    \n/**\n * \n * 创建一个专有于数据读取器的数组\n * \n * @import define from object.property.inner.define\n * \n * @import get from object.property.inner.get\n * \n * @import createObservable from .observable\n * \n * @import is from is.data.record\n * \n * @import is.array\n * \n * @import is.class\n * \n * @param {data.Reader} reader 数据读取器\n * \n * @param {array} records 数据记录数组\n * \n * @return {array} 数组\n * \n */\n\nconst {\n    push\n} = Array.prototype ;\n\nfunction main(reader , records){\n\n    let recordset = new Recordset() ;\n\n    define(recordset , 'reader' , reader) ;\n\n    define(recordset , 'observable' , createObservable()) ;\n\n    push.call(recordset , ...createRecords.call(recordset , records)) ;\n\n    return recordset ;\n\n}\n\nclass Recordset extends Array{\n\n    push(...raws){  \n\n        return super.push(...createRecords.call(this , raws)) ;\n    }\n\n    unshift(...raws){\n\n        return super.unshift(...createRecords.call(this , raws)) ;\n    }\n\n    splice(index , howMany , ...raws){\n\n        let me = this,\n        {\n            length\n        } = me;\n\n        for(let i = 0 ; i < howMany ; i ++){\n\n            let itemIndex = index + i ;\n\n            if(itemIndex < length){\n\n                get(me[itemIndex] , 'observable').independent() ;\n            }\n        }\n\n        return super.splice(index , howMany , ...createRecords.call(me , raws)) ;\n    }\n\n    pop(){\n\n        let me = this,\n        {\n            length\n        } = me;\n\n        if(length){\n\n            get(me[length - 1] , 'observable').independent() ;\n        }\n\n        return super.pop() ;\n    }\n\n    shift(){\n\n        let me = this,\n        {\n            length\n        } = me;\n\n        if(length){\n\n            get(me[0] , 'observable').independent() ;\n        }\n\n        return super.shift() ;\n    }\n }\n\n function createRecords(raws){\n\n    let records = [],\n        readRaws = [],\n        me = this;\n\n    for(let raw of raws){\n\n        if(is(raw)){\n\n            let observable = get(raw , 'observable');\n\n            if(observable.isIndependent){\n\n                observable.belongTo(me) ;\n\n                records.push(raw) ;\n            }\n\n        }else{\n\n            readRaws.push(raw) ;\n        }\n    }\n\n    let recordset = get(me , 'reader').read(readRaws , {\n        isRecordset:false\n    }) ;\n\n    for(let record of recordset){\n\n        get(record , 'observable').belongTo(me) ;\n\n        records.push(record) ;\n\n    }\n\n    return records ;\n }\n    \n                    return function(reader , records){\n    \n                        \n        if(!var_init_locked_1608956298207){\n\n            define = include('src::object.property.inner.define');\nget = include('src::object.property.inner.get');\ncreateObservable = include('src::data.observable');\nis = include('src::is.data.record');\nisArray = include('src::is.array');\nisClass = include('src::is.class');\n\n            var_init_locked_1608956298207 = true ;\n        }\n        \n    \n                        return main.call(this , reader , records) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.recordset"
  },
  "src::data.store.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.add(<mixed> records , <boolean> isFireEvent)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(records , isFireEvent){\n\n        /**\n * \n * 插入记录\n * \n * @param {mixed} records 数据记录\n * \n * @param {boolean} [isFireEvent = true] 是否触发插入事件\n * \n */\n\nlet me = this,\n {\n   recordset\n } = me ;\n\n records = recordset.add(records) ;\n\n if(records.length){\n\n    if(isFireEvent){\n\n      me.fireEvent('add' , records) ;\n    }\n }\n\n return records ;\n\n    }\n    \n                    return function(records , isFireEvent = true){\n    \n                        \n    \n                        return main.call(this , records , isFireEvent) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.add"
  },
  "src::data.store.base": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.base()",
    "standard": true,
    "importNames": [
      "src::data.model.get",
      "src::data.model.create",
      "src::object.assign",
      "src::data.proxy.create",
      "src::is.proxy.memory",
      "src::data.reader.json"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,create,assign,createProxy,isMemoryProxy,createReader;\n    \n                    let var_init_locked_1608956298214;\n    \n                    let var_class_1608956298214;\n    \n                    \n\n                    let var_global_main_1608956298214 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298214){\n\n            get = include('src::data.model.get');\ncreate = include('src::data.model.create');\nassign = include('src::object.assign');\ncreateProxy = include('src::data.proxy.create');\nisMemoryProxy = include('src::is.proxy.memory');\ncreateReader = include('src::data.reader.json');\n\n            \n/**\n * \n * 数据存储器\n * \n * @import get from data.model.get\n * \n * @import create from data.model.create\n * \n * @import assign from object.assign\n * \n * @import createProxy from data.proxy.create\n * \n * @import isMemoryProxy from is.proxy.memory\n * \n * @import createReader from data.reader.json\n * \n * @class\n * \n */\n\nclass main{\n\n    createRecord(data){\n\n        let records = this.reader(data) ;\n\n        if(records.length){\n\n            return records[0] ;\n        }\n    }\n\n    onProxyRead(proxy , records){\n\n        let me = this,\n        {\n            recordset\n        } = me;\n\n        recordset.add(records) ;\n\n        me.fireEvent('load' , records) ;\n    }\n}\n\n \n\n            var_class_1608956298214 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298214 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.store.base' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298214 ;\n        \nvar_global_main_1608956298214 = main;\n\n            var_init_locked_1608956298214 = true ;\n        }\n        \n    \n                        return var_global_main_1608956298214 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.base"
  },
  "src::is.proxy.memory": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.proxy.memory(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::data.proxy"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Proxy;\n    \n                    let var_init_locked_1608956298219;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断是否内存代理\n * \n * @import Proxy from data.proxy value\n * \n * @param {mixed} data 测试数据\n * \n * @return {boolean} 如果为内存代理则返回 true , 否则返回 false\n * \n */\n\n\n return data instanceof Proxy && data.proxyType === 'memory' ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298219){\n\n            Proxy = include('src::data.proxy')();\n\n            var_init_locked_1608956298219 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.proxy.memory"
  },
  "src::data.store.clear": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.clear()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 清理\n * \n * \n */\n\nlet me = this,\n    {\n        recordset\n    } = me ;\n\nrecordset.clear() ;\n\nme.fireEvent('clear') ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.clear"
  },
  "src::data.store.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.constructor({<object> proxy , <mixed> data , <boolean> autoLoad , <array> fields , <data.Model> model})",
    "standard": true,
    "importNames": [
      "src::data.model.create",
      "src::data.model.get",
      "src::object.assign",
      "src::data.proxy.create",
      "src::is.proxy.memory",
      "src::data.reader.json",
      "src::data.recordset",
      "src::object.link"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let create,get,assign,createProxy,isMemoryProxy,createReader,createRecordset,link;\n    \n                    let var_init_locked_1608956298224;\n    \n                    \n\n                    function main({proxy , data , autoLoad , fields , model}){\n\n        \n/**\n * \n * 初始化数据存储器\n * \n * @import create from data.model.create\n * \n * @import get from data.model.get\n * \n * @import assign from object.assign\n * \n * @import createProxy from data.proxy.create\n * \n * @import isMemoryProxy from is.proxy.memory\n * \n * @import createReader from data.reader.json\n * \n * @import createRecordset from data.recordset\n * \n * @import link from object.link\n * \n * @param {object} config 配置\n * \n * @param {object} [config.proxy = {}] 数据代理\n * \n * @param {mixed} [config.data] 初始数据\n * \n * @param {boolean} [config.autoLoad = false] 自动加载\n * \n * @param {array} [config.fields] 数据字段定义\n * \n * @param {data.Model} [config.model] 数据模型\n * \n * \n */\n\nif(fields){\n\n    model = create({\n        fields\n    }) ;\n\n}\n\nif(model){\n\n    model = get(model) ;\n\n}\n\nlet me = this ;\n\nme.proxy = createProxy(assign({\n    type:'memory',\n    model,\n    reader:{\n        type:'json'\n    },\n    listeners:{\n        read:'onProxyRead',\n        scope:me\n    }\n} , proxy)) ;\n\nlet recordset = me.recordset = createRecordset(me) ;\n\nif(data){\n\n    let {\n        proxy\n    } = me ;\n\n    if(isMemoryProxy(proxy)){\n\n        proxy.read(data)\n    }\n\n}else if(autoLoad){\n\n    me.load() ;\n}\n\nme.reader = createReader({\n    model\n}) ;\n\nlink(me , recordset , [\n    'indexOf',\n    'findRecords',\n    'getById'\n]) ;\n\n    }\n    \n                    return function({proxy = {} , data , autoLoad = false , fields , model}){\n    \n                        \n        if(!var_init_locked_1608956298224){\n\n            create = include('src::data.model.create');\nget = include('src::data.model.get');\nassign = include('src::object.assign');\ncreateProxy = include('src::data.proxy.create');\nisMemoryProxy = include('src::is.proxy.memory');\ncreateReader = include('src::data.reader.json');\ncreateRecordset = include('src::data.recordset');\nlink = include('src::object.link');\n\n            var_init_locked_1608956298224 = true ;\n        }\n        \n    \n                        return main.call(this , {proxy , data , autoLoad , fields , model}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.constructor"
  },
  "src::object.link": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.link(<mixed> dest , <mixed> source , <array> names)",
    "standard": true,
    "importNames": [
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1608956298227;\n    \n                    \n\n                    function main(dest , source , names){\n\n        /**\n * \n * 将对象的方法或者属性进行链接\n * \n * @import is.function\n * \n * @param {mixed} dest 目标对象\n * \n * @param {mixed} source 来源对象\n * \n * @param {array} names 字段名称集合\n * \n */\n\n for(let name of names){\n\n    let value = source[name] ;\n\n    if(isFunction(value)){\n\n        dest[name] = (...args) => source[name](...args) ;\n    \n    }else{\n\n        Object.defineProperty(dest , name , {\n\n            set:value => source[name] = value,\n\n            get:() => source[name]\n\n        }) ;\n    }\n }\n\n    }\n    \n                    return function(dest , source , names){\n    \n                        \n        if(!var_init_locked_1608956298227){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1608956298227 = true ;\n        }\n        \n    \n                        return main.call(this , dest , source , names) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.link"
  },
  "src::data.store.create": {
    "meta": "code.meta.script.function",
    "signature": "<data.Store> src::data.store.create(<object> model)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(model){\n\n        \n/**\n * \n * 创建新的数据存储器\n * \n * @param {object} model 数据模型定义\n * \n * @return {data.Store} 创建后的数据存储器\n * \n */\n\n    }\n    \n                    return function(model){\n    \n                        \n    \n                        return main.call(this , model) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.create"
  },
  "src::data.store.destroy": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.destroy()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 销毁数据存储器\n * \n */\n\n let me = this,\n {\n   records,\n   recordMap\n } = me ;\n\n for(let record of records){\n\n   record.destroy() ;\n\n   delete recordMap[record.id] ;\n }\n\n records.length = 0 ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.destroy"
  },
  "src::data.store.find.records": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::data.store.find.records(<mixed> property , <mixed> value)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isFunction;\n    \n                    let var_init_locked_1608956298234;\n    \n                    \n\n                    function main(property , value){\n\n        \n/**\n * \n * 寻找符合查询条件的记录\n * \n * @import is.string\n * \n * @import is.function\n * \n * @param {mixed} property 属性名称\n * \n * @param {mixed} value 属性值\n * \n * @return {array} 查询出来的数据记录\n * \n */\n\n let {\n    recordset\n } = this ;\n\n return recordset.findRecords(property , value) ;\n\n    }\n    \n                    return function(property , value){\n    \n                        \n        if(!var_init_locked_1608956298234){\n\n            isString = include('src::is.string');\nisFunction = include('src::is.function');\n\n            var_init_locked_1608956298234 = true ;\n        }\n        \n    \n                        return main.call(this , property , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.find.records"
  },
  "src::data.store.get.id": {
    "meta": "code.meta.script.function",
    "signature": "<data.Model> src::data.store.get.id(<mixed> id)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(id){\n\n        \n/**\n * \n * 根据编号获取记录\n * \n * @param {mixed} id 记录编号\n * \n * @return {data.Model} 数据记录 \n * \n */\n\n let {\n    recordset\n } = this ;\n\n return recordset.getById(id) ;\n\n    }\n    \n                    return function(id){\n    \n                        \n    \n                        return main.call(this , id) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.get.id"
  },
  "src::data.store.insert": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.insert(<number> index , <mixed> records , <boolean> isFireEvent)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(index , records , isFireEvent){\n\n        \n/**\n * \n * 插入记录\n * \n * @param {number} index 插入位置\n * \n * @param {mixed} records 数据记录\n * \n * @param {boolean} [isFireEvent = true] 是否触发插入事件\n * \n */\n\n let me = this,\n {\n   recordset\n } = me ;\n\n records = recordset.insert(index , records) ;\n\n if(records.length){\n\n    if(isFireEvent){\n\n      me.fireEvent('insert' , index , records) ;\n    }\n }\n\n return records ;\n\n    }\n    \n                    return function(index , records , isFireEvent = true){\n    \n                        \n    \n                        return main.call(this , index , records , isFireEvent) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.insert"
  },
  "src::data.store.load": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.load(<mixed> options , <boolean> isClear)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(options , isClear){\n\n        \n/**\n * \n * 加载数据\n * \n * @param {mixed} options 数据或者配置\n * \n * @param {boolean} [isClear = true] 是否在加载前清除\n * \n */\n\nlet me = this,\n{\n    proxy\n} = me;\n\nif(isClear){\n\n    me.clear() ;\n}\n\nproxy.read(options) ;\n\n    }\n    \n                    return function(options , isClear = true){\n    \n                        \n    \n                        return main.call(this , options , isClear) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.load"
  },
  "src::data.store.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.remove(<mixed> records , <boolean> isFireEvent)",
    "standard": true,
    "importNames": [
      "src::array.remove",
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let remove,from;\n    \n                    let var_init_locked_1608956298246;\n    \n                    \n\n                    function main(records , isFireEvent){\n\n        \n/**\n * \n * 删除记录\n * \n * @import remove from array.remove\n * \n * @import from from array.from\n * \n * @param {mixed} records 数据记录\n * \n * @param {boolean} [isFireEvent = true] 是否触发删除事件\n * \n */\n\n let me = this,\n {\n    recordset\n } = me;\n\n records = recordset.remove(records) ;\n\n if(records.length && isFireEvent){\n\n   me.fireEvent('remove' , records) ;\n }\n\n return records ;\n\n\n\n\n\n\n    }\n    \n                    return function(records , isFireEvent = true){\n    \n                        \n        if(!var_init_locked_1608956298246){\n\n            remove = include('src::array.remove');\nfrom = include('src::array.from');\n\n            var_init_locked_1608956298246 = true ;\n        }\n        \n    \n                        return main.call(this , records , isFireEvent) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.remove"
  },
  "src::data.store.tree.base": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.tree.base()",
    "standard": true,
    "importNames": [
      "src::data.store",
      "src::data.model.node.tree.mind",
      "src::class.define",
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Store,Model,define,from;\n    \n                    let var_init_locked_1608956298250;\n    \n                    let var_class_1608956298250;\n    \n                    \n\n                    let var_global_main_1608956298250 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298250){\n\n            Store = include('src::data.store')();\nModel = include('src::data.model.node.tree.mind')();\ndefine = include('src::class.define');\nfrom = include('src::array.from');\n\n            \n/**\n * \n * 树型数据存储器\n * \n * @import Store from data.store value\n * \n * @import Model from data.model.node.tree.mind value\n * \n * @import define from class.define\n * \n * @import from from array.from\n * \n * @class\n * \n * \n */\n\n class main extends Store{\n\n    constructor({\n        fields,\n        rootConfig,\n        synchronize,\n        listeners = {},\n        ...options\n    }){\n\n        let currentModel ;\n\n        if(fields){\n\n            currentModel = define(class extends Model{\n\n                static get fieldConfigurations(){\n\n                    return [\n                        ...super.fieldConfigurations,\n                        ...fields\n                    ];\n                }\n            }) ;\n\n        }\n\n        super({\n            ...options,\n            model:currentModel,\n            listeners:[{\n                load:'onLoad',\n                expand:'onExpand',\n                collapse:'onCollapse'\n            } , listeners]\n        }) ;\n\n        let me = this ;\n\n        me.rootConfig = rootConfig || {} ;\n\n        me.synchronize = synchronize || (() => []) ;\n    }\n\n    onExpand(){\n\n        this.layout() ;\n\n    }\n\n    onCollapse(){\n\n        this.layout() ;\n    }\n\n    onLoad(store , nodes){\n\n        for(let node of nodes){\n\n            if(!node.isBindStore){\n\n                continue ;\n            }\n\n            let {\n                parentNode\n            } = node ;\n\n            if(!parentNode){\n                \n                let me = this,\n                {\n                    rootConfig\n                } = me ;\n\n                me.rootNode = node ;\n\n                node.set(rootConfig) ;\n\n                doReorder(node) ;\n\n                node.suspendEvents() ;\n\n                me.fireEvent('root' , node) ;\n\n                node.resumeEvents() ;\n\n                break ;\n            }\n        }\n    }\n }\n\n\n function doReorder(node){\n\n    let {\n        store,\n        childNodes\n    } = node ;\n\n    store.insert(store.indexOf(node) + 1 , childNodes) ;\n\n }\n\n            var_class_1608956298250 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298250 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.store.tree.base' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298250 ;\n        \nvar_global_main_1608956298250 = main;\n\n            var_init_locked_1608956298250 = true ;\n        }\n        \n    \n                        return var_global_main_1608956298250 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.tree.base"
  },
  "src::object.clone": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::object.clone(<object> target)",
    "standard": true,
    "importNames": [
      "src::object.assign"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let assign;\n    \n                    let var_init_locked_1608956298270;\n    \n                    \n\n                    function main(target){\n\n        \n/**\n * \n * 拷贝对象\n * \n * @import assign from .assign\n * \n * @param {object} target 目标数据\n * \n * @return {object} 拷贝后的对象\n * \n */\n\n return assign({} , target) ;\n\n    }\n    \n                    return function(target){\n    \n                        \n        if(!var_init_locked_1608956298270){\n\n            assign = include('src::object.assign');\n\n            var_init_locked_1608956298270 = true ;\n        }\n        \n    \n                        return main.call(this , target) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.clone"
  },
  "src::data.store": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store(<object> config)",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::array.clear",
      "src::object.clear",
      "src::array.clone",
      "src::object.clone",
      "src::array.from",
      "src::is.object.simple",
      "src::is.function",
      "src::is.number",
      "src::function.empty",
      "src::event.listener.add",
      "src::event.listener.remove",
      "src::id.generate",
      "src::is.empty",
      "src::is.string",
      "src::array.insert",
      "src::data.convert.number",
      "src::data.reader.json"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Observable,aclear,oclear,aClone,oClone,from,isObject,isFunction,isNumber,empty,add,remove,generate,isEmpty,isString,insert,toNumber,createReader;\n    \n                    let var_init_locked_1608956298264;\n    \n                    let var_class_1608956298264;\n    \n                    \n\n                    let var_global_main_1608956298264 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298264){\n\n            Observable = include('src::mixin.observable');\naclear = include('src::array.clear');\noclear = include('src::object.clear');\naClone = include('src::array.clone');\noClone = include('src::object.clone');\nfrom = include('src::array.from');\nisObject = include('src::is.object.simple');\nisFunction = include('src::is.function');\nisNumber = include('src::is.number');\nempty = include('src::function.empty')();\nadd = include('src::event.listener.add');\nremove = include('src::event.listener.remove');\ngenerate = include('src::id.generate');\nisEmpty = include('src::is.empty');\nisObject = include('src::is.object.simple');\nisFunction = include('src::is.function');\nisString = include('src::is.string');\ninsert = include('src::array.insert');\ntoNumber = include('src::data.convert.number');\ncreateReader = include('src::data.reader.json');\n\n            /**\n * \n * 数据存储器类\n * \n * @import Observable from mixin.observable\n * \n * @import aclear from array.clear\n * \n * @import oclear from object.clear\n * \n * @import aClone from array.clone\n * \n * @import oClone from object.clone\n * \n * @import from from array.from\n * \n * @import isObject from is.object.simple\n * \n * @import is.function\n * \n * @import is.number\n * \n * @import empty from function.empty value\n * \n * @import add from event.listener.add\n * \n * @import remove from event.listener.remove\n * \n * @import generate from id.generate\n * \n * @import is.empty\n * \n * @import isObject from is.object.simple\n * \n * @import is.function\n * \n * @import is.string\n * \n * @import insert from array.insert\n * \n * @import toNumber from data.convert.number\n * \n * @import createReader from data.reader.json\n * \n * @param {object} config 配置\n * \n * @class\n * \n */\n\nfunction defaultRecordId(record , me){\n\n    let {\n        idField\n    } = me ;\n\n    if(!record.hasOwnProperty(idField)){\n\n        Object.defineProperty(record , idField , {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value:generate('record-')\n        }) ;\n    }\n\n    return record[idField] ;\n}\n\nfunction defaultRecordMerge(record){\n\n    return record ;\n}\n\nfunction defaultRecordValid(){\n\n    return true ;\n}\n\nfunction createFixedRecordPositions(sorts){\n\n    let results = [] ;\n\n    for(let sort of sorts){\n\n        if(isString(sort)){\n\n            sort = {\n                field:sort\n            } ;\n        }\n\n        if(isObject(sort)){\n\n            let {\n                field,\n                direction = 'asc'\n            } = sort;\n\n            switch(direction){\n\n                case 'asc':\n\n                    sort = (record , appendRecord) => toNumber(record[field]) <= toNumber(appendRecord[field]) ;\n\n                    break ;\n\n                case 'desc':\n\n                    sort = (record , appendRecord) => toNumber(record[field]) >= toNumber(appendRecord[field]) ;\n            }            \n        }\n        \n        if(isFunction(sort)){\n\n            results.push(sort) ;\n        }\n    }\n\n    return results ;\n}\n\nclass main extends mixins({\n    mixins:[\n        Observable\n    ]\n}){\n\n    constructor({\n        idField = '_id',\n        id = defaultRecordId,\n        merge = defaultRecordMerge,\n        valid = defaultRecordValid,\n        reader = {},\n        sorts = [],\n        properties = {},\n        isEmpty = false,\n        ...options\n    } = {}){\n\n        super(options) ;\n\n        if(isEmpty === true){\n\n            return ;\n        }\n\n        let me = this ;\n\n        me.idField = idField ;\n\n        me.doRecordMerge = merge ;\n\n        me.doRecordId = id ;\n\n        me.doRecordValid = valid ;\n\n        me.data = [] ;\n\n        me.ids = {} ;\n\n        me.reader = createReader(reader) ;\n\n        let names = Object.keys(properties),\n            orginProperties = {},\n            store = this;\n\n        for(let name of names){\n\n            let property = properties[name] ;\n\n            if(isFunction(property)){\n\n                orginProperties[name] = {\n                    enumerable:true,\n                    get(){\n\n                        return property(this , store) ;\n                    }\n                } ;\n\n            }else if(isObject(property)){\n\n                let {\n                    set = empty,\n                    get = empty\n                } = property ;\n\n                orginProperties[name] = {\n                    enumerable:true,\n                    get(){\n\n                        return get(this , store) ;\n                    },\n\n                    set(value){\n\n                        set(value , this , store) ;\n                    }\n                } ;\n            }\n        }\n\n        me.properties = orginProperties ;\n\n        me.fixedRecordPositions = createFixedRecordPositions(sorts) ;\n    }\n\n    clone(){\n\n        let target = new main({\n            isEmpty:true\n        }),\n        {\n            doRecordMerge,\n            doRecordId,\n            doRecordValid,\n            data,\n            ids,\n            reader,\n            properties,\n            fixedRecordPositions\n        } = this;\n\n        target.doRecordMerge = doRecordMerge ;\n\n        target.doRecordId = doRecordId ;\n\n        target.doRecordValid = doRecordValid ;\n\n        target.data = aClone(data) ;\n\n        target.ids = oClone(ids) ;\n\n        target.reader = reader ;\n\n        target.properties = properties ;\n\n        target.fixedRecordPositions = fixedRecordPositions ;\n\n        return target ;\n    }\n\n    get isEmpty(){\n\n        return this.data.length === 0 ;\n    }\n\n    pipe(store){\n\n        let me = this ;\n\n        me.pipeStore = store ;\n\n        let onPipeStoreLoad = () => {\n\n            let {\n                pipeData\n            } = this ;\n\n            if(!isEmpty(pipeData)){\n\n                store.load(pipeData) ;\n            }\n\n        },\n            onPipeStoreChange = () => {\n\n                let {\n                    pipeData\n                } = this ;\n    \n                if(!isEmpty(pipeData)){\n    \n                    store.append(pipeData) ;\n                }\n    \n            };\n\n        add(me , {\n            load:onPipeStoreLoad,\n            change:onPipeStoreChange\n        });\n\n        me.onPipeStoreLoad = onPipeStoreLoad ;\n\n        me.onPipeStoreChange = onPipeStoreChange ; \n\n        return store ;\n    }\n\n    unpipe(){\n\n        let me = this,\n        {\n            pipeStore,\n            onPipeStoreLoad,\n            onPipeStoreChange\n        } = me ;\n\n        if(pipeStore){\n\n            remove(me , {\n                load:onPipeStoreLoad,\n                change:onPipeStoreChange\n            }) ;\n\n            delete me.pipeStore ;\n\n            delete me.onPipeStoreLoad ;\n\n            delete me.onPipeStoreChange ;\n        }\n    }\n\n    getRecordById(id){\n\n        let me = this,\n        {\n            ids,\n            data\n        } = me ;\n\n        if(ids.hasOwnProperty(id)){\n\n            return data[ids[id]] ;\n        }\n    }\n\n    indexOf(record){\n\n        let me = this,\n        {\n            doRecordId,\n            ids\n        } = me,\n        index = ids[doRecordId(record , me)];\n\n        return isNumber(index) ? index : -1 ;\n    }\n\n    getPreviousRecord(record){\n\n        let me = this,\n        {\n            data\n        } = me,\n        index = me.indexOf(record);\n\n        if(index > 0){\n\n            return data[index - 1] ;\n        }\n    }\n\n    get last(){\n\n        let {\n            data,\n            isEmpty\n        } = this ;\n\n        if(!isEmpty){\n\n            return data[data.length - 1] ;\n        }\n    }\n\n    append(data , isFireEvent = true){\n\n        let me = this,\n        {\n            data:records,\n            doRecordMerge,\n            doRecordValid,\n            doRecordId,\n            reader,\n            properties\n        } = me ;\n\n        data = reader.read(data) ;\n\n        let updates = [],\n            appends = [],\n            all = [];\n\n        for(let record of data){\n\n            if(!doRecordValid(record , me)){\n\n                continue ;\n            }\n\n            if(properties){\n\n                Object.defineProperties(record , properties) ;\n            }\n\n            let id = doRecordId(record , me),\n                oldRecord = me.getRecordById(id) ;\n\n            if(oldRecord){\n\n                record = records[me.indexOf(oldRecord)] = doRecordMerge(record , oldRecord , me) ;\n\n                updates.push(record) ;\n\n                all.push(record) ;\n\n            }else{\n\n                me.doAppend(record) ;\n\n                appends.push(record) ;\n\n                all.push(record) ;\n                \n            }\n        }\n\n        if(appends.length && isFireEvent){\n\n            me.fireEvent('append' , appends) ;\n\n        }\n\n        if(updates.length && isFireEvent){\n\n            me.fireEvent('update' , updates) ;\n        }\n\n        if(all.length && isFireEvent){\n\n            me.fireEvent('change' , all) ;\n\n            me.fireEvent('pipedata' , all) ;\n        }\n        \n        return {\n            updates,\n            appends,\n            all\n        } ;\n    }\n\n    getAppendRecordIndex(record){\n\n        let me = this,\n        {\n            data,\n            fixedRecordPositions\n        } = me,\n        {\n            length:len\n        } = data,\n        fixedRecordPosition = 0,\n        fixedRecordPositionIndex = 0;\n\n        for(let i = len - 1 ; i >= 0 ; i --){\n\n            let item = data[i],\n                j = 0 ;\n\n            for(let doFixedRecordPosition of fixedRecordPositions){\n\n                if(j > fixedRecordPositionIndex){\n\n                    break ;\n                }\n\n                if(!doFixedRecordPosition(item , record , me)){\n\n                    break ;\n                }\n\n                j ++ ;\n            }\n\n            \n            if(j > fixedRecordPositionIndex){\n\n                fixedRecordPositionIndex ++ ;\n\n                fixedRecordPosition = i + 1 ;\n            \n            }else if(fixedRecordPositionIndex !== 0){\n\n                break ;\n            }\n        }\n        \n        if(fixedRecordPositions.length){\n\n            return fixedRecordPosition ;\n        }\n\n        return len ;\n    }\n\n    doAppend(record){\n\n        let me = this,\n        {\n            data,\n            ids,\n            doRecordId\n        } = me,\n        id = doRecordId(record , me),\n        index = me.getAppendRecordIndex(record);\n\n        insert(data , index , record) ;\n\n        ids[id] = index;\n    }\n\n    load(data){\n\n        let me = this ;\n\n        me.clear() ;\n\n        me.append(data , false) ;\n\n        let {\n            data:realData\n        } = me ;\n\n        me.fireEvent('load' , realData) ;\n\n        me.fireEvent('pipedata' , realData) ;\n    }\n\n    refresh(){\n\n        let me = this,\n        {\n            ids,\n            doRecordId,\n            data\n        } = me ;\n\n        let count = 0 ;\n\n        for(let record of data){\n\n            ids[doRecordId(record , me)] = count ++;\n        }\n\n    }\n\n    clear(){\n\n        let me = this,\n        {\n            data,\n            ids\n        } = me ;\n\n        aclear(data) ;\n\n        oclear(ids) ;\n\n        me.fireEvent('clear') ;\n    }\n\n    get pipeData(){\n\n        return this.data ;\n    }\n}\n\n            var_class_1608956298264 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298264 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.store' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298264 ;\n        \nvar_global_main_1608956298264 = main;\n\n            var_init_locked_1608956298264 = true ;\n        }\n        \n    \n                        return var_global_main_1608956298264 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store"
  },
  "src::data.store.tree.insert": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.tree.insert(<number> index , <mixed> nodes)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(index , nodes){\n\n        \n/**\n * \n * 插入节点\n * \n * @param {number} index 插入位置\n * \n * @param {mixed} nodes 节点数据\n * \n * \n */\n\nlet me = this,\n{\n    recordset\n} = me,\ninsertNodes = [];\n\nnodes = recordset.add(nodes) ;\n\nfor(let node of nodes){\n\n    insertNodes.push(node) ;\n\n    insertNodes.push(...node.descendantNodes) ;\n}\n\nrecordset.insert(index , insertNodes) ;\n\nme.fireEvent('insert' , insertNodes) ;\n\nreturn nodes ;\n\n    }\n    \n                    return function(index , nodes){\n    \n                        \n    \n                        return main.call(this , index , nodes) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.tree.insert"
  },
  "src::data.store.tree.mind": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.tree.mind(<object> options)",
    "standard": true,
    "importNames": [
      "src::data.store.tree"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Store;\n    \n                    let var_init_locked_1608956298279;\n    \n                    let var_class_1608956298279;\n    \n                    \n\n                    let var_global_main_1608956298279 ;\n    \n                    return function(options){\n    \n                        \n        if(!var_init_locked_1608956298279){\n\n            Store = include('src::data.store.tree')();\n\n            \n/**\n * \n * 获取脑图实例\n * \n * @import Store from data.store.tree value\n * \n * @param {object} options 脑图配置\n * \n */\n\n class main extends Store{\n\n    constructor({\n        margin = {},\n        lineOffsetX = 0,\n        ...options\n    }){\n\n        super(options) ;\n\n        let me = this,\n        {\n            bottom:marginBottom = 0,\n            right:marginRight = 0\n        } = margin ;\n\n        me.marginBottom = marginBottom ;\n\n        me.marginRight = marginRight ;\n\n        me.lineOffsetX = lineOffsetX ;\n    }\n\n    get region(){\n\n        let {\n            rootNode\n        } = this,\n        {\n            x,\n            y,\n            firstDescendantNodes,\n            lastDescendantNodes,\n            leafNodes\n        } = rootNode;\n\n        for(let node of firstDescendantNodes){\n        \n            let {\n                y:nodeY\n            } = node.getAnchorXY('tr') ;\n        \n            if(y > nodeY){\n        \n                y = nodeY ;\n            }\n        }\n        \n        let bottom = y ;\n        \n        for(let node of lastDescendantNodes){\n        \n            let {\n                y:nodeY\n            } = node.getAnchorXY('br') ;\n        \n            if(bottom < nodeY){\n        \n                bottom = nodeY ;\n            }\n        }\n        \n        let {\n            x:right\n        } = rootNode.getAnchorXY('r') ;\n        \n        for(let leafNode of leafNodes){\n        \n            let {\n                x\n            } = leafNode.getAnchorXY('r') ;\n        \n            if(right < x){\n        \n                right = x ;\n            }\n        }\n        \n        const {\n            min,\n            abs\n        } = Math ;\n        \n        x = min(x , 0),\n        y = min(y , 0) ;\n        \n        return {\n            x:abs(x),\n            y:abs(y),\n            width:right,\n            height:bottom\n        } ;\n    }\n\n    layout(){\n\n        let me = this,\n        {\n            rootNode,\n            recordset\n        } = me,\n        records = recordset.findRecords('hidden' , false);\n\n        if(rootNode){\n\n            rootNode.layout() ;\n\n            let {\n                region,\n                lineOffsetX\n            } = me ;\n\n            me.fireEvent('layout' , records , lines(records , region , lineOffsetX)) ;\n        }\n    }\n\n    get columns(){\n\n        let {\n            leafNodes\n        } = this.rootNode;\n\n        return Math.max(...leafNodes.map(node => node.depth)) + 1 ;\n    }\n\n    get rows(){\n\n        let {\n            leafNodes\n        } = this.rootNode;\n\n        return leafNodes.length ;\n    }\n }\n\nfunction lines(nodes , {\n    x,\n    y\n} , lineOffsetX){\n\n   let lines = [];\n\n   for(let node of nodes){\n\n        if(node.hidden){\n\n            continue ;\n        }\n\n       let {\n           x:startX,\n           y:startY\n       } = node.getAnchorXY('r'),\n       {\n           children\n       } = node;\n\n       startX += lineOffsetX ;\n\n       for(let childNode of children){\n\n            if(!nodes.includes(childNode)){\n\n                continue ;\n            }\n\n           let {\n               x:endX,\n               y:endY\n           } = childNode.getAnchorXY('l'),\n           points = [\n            startX + x,\n            startY + y,\n            startX + x,\n            endY + y,\n            startX + x,\n            endY + y,\n            endX + x,\n            endY + y\n           ];\n\n           lines.push({\n               start:node,\n               end:childNode,\n               points\n           }) ;\n       }\n   }\n\n   return lines ;\n}\n\n            var_class_1608956298279 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298279 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.store.tree.mind' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298279 ;\n        \nvar_global_main_1608956298279 = main;\n\n            var_init_locked_1608956298279 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298279(options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.tree.mind"
  },
  "src::data.store.tree.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::data.store.tree.remove(<mixed> nodes)",
    "standard": true,
    "importNames": [
      "src::array.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from;\n    \n                    let var_init_locked_1608956298285;\n    \n                    \n\n                    function main(nodes){\n\n        \n/**\n * \n * 去除节点\n * \n * @import from from array.from\n * \n * @param {mixed} nodes 节点数据\n * \n */\n\nnodes = from(nodes) ;\n\nlet me = this,\n    {\n        recordset\n    } = me,\n    removeNodes = [] ;\n\nfor(let node of nodes){\n\n    let {\n        descendantNodes\n    } = node ;\n\n    removeNodes.push(...recordset.remove([\n        node,\n        ...descendantNodes\n    ])) ;\n}\n\nme.fireEvent('remove' , removeNodes) ;\n\n    }\n    \n                    return function(nodes){\n    \n                        \n        if(!var_init_locked_1608956298285){\n\n            from = include('src::array.from');\n\n            var_init_locked_1608956298285 = true ;\n        }\n        \n    \n                        return main.call(this , nodes) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.tree.remove"
  },
  "src::data.store.tree": {
    "meta": "code.meta.class",
    "signature": "<void> src::data.store.tree()",
    "standard": true,
    "importNames": [
      "src::data.store.tree.base",
      "src::data.store.tree.insert",
      "src::data.store.tree.remove",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let extend,method_insert,method_remove,isObject;\n    \n                    let var_init_locked_1608956298282;\n    \n                    let var_class_1608956298282;\n    \n                    \n\n                    let var_global_main_1608956298282 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298282){\n\n            extend = include('src::data.store.tree.base')();\nmethod_insert = include('src::data.store.tree.insert');\nmethod_remove = include('src::data.store.tree.remove');\nisObject = include('src::is.object.simple');\n\n            class main extends mixins({extend , mixins:[]}){\n\n            \n\n            \n\n            \n\n            insert(...args){\n\n            return method_insert.apply(this , args) ;\n\n        }\nremove(...args){\n\n            return method_remove.apply(this , args) ;\n\n        }\n\n            \n\n        }\n\n            var_class_1608956298282 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298282 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::data.store.tree' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298282 ;\n        \nvar_global_main_1608956298282 = main;\n\n            var_init_locked_1608956298282 = true ;\n        }\n        \n    \n                        return var_global_main_1608956298282 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "data.store.tree"
  },
  "src::is.browser.support.pointer": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.browser.support.pointer()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956298294;\n\n                    function main(){\n\n        \n/**\n * \n * 判断当前浏览器是否支持点触\n * \n * @return {boolean} 如果是支持点触则返回 true ，否则返回 false \n * \n * @once\n * \n */\n\nreturn global.hasOwnProperty('onpointerdown');\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956298294){\n\n            return var_once_value_1608956298294 ;\n\n        }\n        return var_once_value_1608956298294 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.browser.support.pointer"
  },
  "src::is.browser.support.touch": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.browser.support.touch()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956298296;\n\n                    function main(){\n\n        \n/**\n * \n * 判断当前浏览器是否支持触摸\n * \n * @return {boolean} 如果是支持触摸则返回 true ，否则返回 false \n * \n * @once\n * \n */\n\nreturn global.hasOwnProperty('ontouchstart');\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956298296){\n\n            return var_once_value_1608956298296 ;\n\n        }\n        return var_once_value_1608956298296 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.browser.support.touch"
  },
  "src::is.class.from": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.class.from(<mixed> data , <mixed> baseClass)",
    "standard": true,
    "importNames": [
      "src::is.class",
      "src::is.string"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isClass,isString;\n    \n                    let var_init_locked_1608956298298;\n    \n                    \n\n                    function main(data , baseClass){\n\n        \n/**\n * \n * 判定数据是否为指定类\n * \n * @import is.class\n * \n * @import is.string\n * \n * @param {mixed} data 测试数据\n * \n * @param {mixed} baseClass 基准类\n * \n * @return {boolean} 如果数据为基准类时则返回 true ,  否则返回 false\n * \n */\n\n if(isString(baseClass)){\n\n    baseClass = include(baseClass)() ;\n }\n\n return isClass(data) && isClass(baseClass) && (data === baseClass || data.prototype instanceof baseClass) ;\n\n    }\n    \n                    return function(data , baseClass){\n    \n                        \n        if(!var_init_locked_1608956298298){\n\n            isClass = include('src::is.class');\nisString = include('src::is.string');\n\n            var_init_locked_1608956298298 = true ;\n        }\n        \n    \n                        return main.call(this , data , baseClass) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.class.from"
  },
  "src::is.data.model.class": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.data.model.class(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::data.model",
      "src::is.class.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let dataModel,isClass;\n    \n                    let var_init_locked_1608956298300;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断是否为数据模型类\n * \n * \n * @import data.model\n * \n * @import isClass from is.class.from\n * \n * @param {mixed} data 参照数据\n * \n * @return {boolean} 如果是数据模型类则返回 true , 否则返回 false \n * \n */\n\n return isClass(data , 'data.model') ;\n\n\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298300){\n\n            dataModel = include('src::data.model');\nisClass = include('src::is.class.from');\n\n            var_init_locked_1608956298300 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.data.model.class"
  },
  "src::is.data.model": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.data.model(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::data.model"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Model;\n    \n                    let var_init_locked_1608956298302;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判定数据是否为数据模型对象\n * \n * @import Model from data.model value\n * \n * @param {mixed} data 检测数据\n * \n * @return {boolean} 如果检测为数据模型则返回 true , 否则返回 false \n * \n */\n\n return data instanceof Model ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298302){\n\n            Model = include('src::data.model')();\n\n            var_init_locked_1608956298302 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.data.model"
  },
  "src::is.data.record.empty": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.data.record.empty(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.data.record"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isRecord;\n    \n                    let var_init_locked_1608956298304;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判定指定数据是否为数据记录\n * \n * @import isRecord from is.data.record\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果为数据记录则返回 true , 否则返回 false \n * \n */\n\nif(isRecord(data)){\n\n    return !data.hasOwnProperty('__ZBEE_DATA_ID__') ;\n }\n\n return false ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298304){\n\n            isRecord = include('src::is.data.record');\n\n            var_init_locked_1608956298304 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.data.record.empty"
  },
  "src::is.data.store": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.data.store(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::data.store"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Store;\n    \n                    let var_init_locked_1608956298306;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判定数据是否为数据存储器对象\n * \n * @import Store from data.store value\n * \n * @param {mixed} data 检测数据\n * \n * @return {boolean} 如果检测为数据存储器则返回 true , 否则返回 false \n * \n */\n\nreturn data instanceof Store ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298306){\n\n            Store = include('src::data.store')();\n\n            var_init_locked_1608956298306 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.data.store"
  },
  "src::is.directory": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.directory(<string> path)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(path){\n\n        \n/**\n * \n * 判断路径是否为文件夹路径\n * \n * @param {string} path 路径\n * \n * @return {boolean} 路径是文件夹则返回 true , 否则返回 false\n * \n */\n\nconst {\n    stat\n} = require('fs') ;\n\nreturn new Promise(resolve => stat(path , (error , stats) => error ? resolve(false) : resolve(stats.isDirectory())))  ;\n\n\n    }\n    \n                    return function(path){\n    \n                        \n    \n                        return main.call(this , path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.directory"
  },
  "src::is.file": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.file(<string> path)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(path){\n\n        \n/**\n * \n * 判断路径是否为文件路径\n * \n * @param {string} path 路径\n * \n * @return {boolean} 路径是文件则返回 true , 否则返回 false\n * \n */\n\nconst {\n    stat\n} = require('fs') ;\n\nreturn new Promise(resolve => stat(path , (error , stats) => error ? resolve(false) : resolve(stats.isFile())))  ;\n\n\n    }\n    \n                    return function(path){\n    \n                        \n    \n                        return main.call(this , path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.file"
  },
  "src::is.html.iframe": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.html.iframe(<mixed> el)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el){\n\n        /**\n * \n * 判断给定元素引用是否为 iframe 元素\n * \n * @param {mixed} el\n * \n * @return {boolean} 如果元素为 iframe 元素，则返回 true , 否则返回 false\n * \n */\n\nreturn el instanceof HTMLIFrameElement ;\n\n    }\n    \n                    return function(el){\n    \n                        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.html.iframe"
  },
  "src::is.model.data": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.model.data(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::model",
      "src::is.class"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let model,isClass;\n    \n                    let var_init_locked_1608956298317;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断当前数据是否为数据模型\n * \n * @import model\n * \n * @import is.class\n * \n * @param {mixed} data 检测数据\n * \n * @return {boolean} 如果检测数据为数据模型则返回 true , 否则返回 false \n * \n */\n\nreturn isClass(data , 'model') ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298317){\n\n            model = include('src::model');\nisClass = include('src::is.class');\n\n            var_init_locked_1608956298317 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.model.data"
  },
  "src::is.null": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.null(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.type"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isType;\n    \n                    let var_init_locked_1608956298320;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判断给定数据是否定义\n * \n * @import is.type\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果数据定义则返回 true , 否则返回 false\n * \n */\n\nreturn data === null ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298320){\n\n            isType = include('src::is.type');\n\n            var_init_locked_1608956298320 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.null"
  },
  "src::is.numeric": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.numeric(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为数值类型\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为数值类型则返回 true , 否则返回 false \n * \n */\n\nreturn !isNaN(parseFloat(data)) && isFinite(data);\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.numeric"
  },
  "src::is.object.empty": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.object.empty(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断对象是否没有字段\n * \n * @param {mixed} data 检测数据\n * \n * @return {boolean} 如果没有字段则返回 true , 否则返回 false\n * \n */\n\n return Object.keys(data).length === 0 ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.object.empty"
  },
  "src::is.object.method": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.object.method(<mixed> target , <string> name)",
    "standard": true,
    "importNames": [
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1608956298326;\n    \n                    \n\n                    function main(target , name){\n\n        \n/**\n * \n * 是否对象方法\n * \n * @import is.function\n * \n * @param {mixed} target 对象\n * \n * @param {string} name 字段名称\n * \n * @return {boolean} 如果指定字段是函数的话则返回 true , 否则返回 false \n * \n */\n\nlet {\n    value\n} = Object.getOwnPropertyDescriptor(target , name) ;\n\nreturn isFunction(value) ;\n\n    }\n    \n                    return function(target , name){\n    \n                        \n        if(!var_init_locked_1608956298326){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1608956298326 = true ;\n        }\n        \n    \n                        return main.call(this , target , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.object.method"
  },
  "src::is.object.property": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.object.property(<mixed> target , <string> name)",
    "standard": true,
    "importNames": [
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1608956298329;\n    \n                    \n\n                    function main(target , name){\n\n        \n/**\n * \n * 是否对象属性\n * \n * @import is.function\n * \n * @param {mixed} target 对象\n * \n * @param {string} name 字段名称\n * \n * @return {boolean} 如果指定字段是函数的话则返回 true , 否则返回 false \n * \n */\n\nlet {\n    set,\n    get,\n    value\n} = Object.getOwnPropertyDescriptor(target , name) ;\n\nreturn isFunction(set) || isFunction(get) || !isFunction(value);\n\n    }\n    \n                    return function(target , name){\n    \n                        \n        if(!var_init_locked_1608956298329){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1608956298329 = true ;\n        }\n        \n    \n                        return main.call(this , target , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.object.property"
  },
  "src::is.pc": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.pc()",
    "standard": true,
    "importNames": [
      "src::os.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let name;\n    \n                    let var_init_locked_1608956298332;\n    \n                    let var_once_value_1608956298332;\n\n                    function main(){\n\n        \n/**\n * \n * 判断当前环境是否是电脑\n * \n * @import name from os.name\n * \n * @once\n * \n * @return {boolean} 如果是电脑则返回 true , 否则返回 false \n * \n */\n\nswitch(name()){\n\n    case 'MacOS':\n    case 'Windows':\n    case 'Linux':\n\n        return true ;\n}\n\nreturn false ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298332){\n\n            name = include('src::os.name');\n\n            var_init_locked_1608956298332 = true ;\n        }\n        \n    \n                        \n        if(var_once_value_1608956298332){\n\n            return var_once_value_1608956298332 ;\n\n        }\n        return var_once_value_1608956298332 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.pc"
  },
  "src::os.name": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::os.name()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956298336;\n\n                    function main(){\n\n        /**\n * \n * 返回当前操作系统的名称\n * \n * @once\n * \n * @return {string} 操作系统的名称\n * \n */\n\nconst NAMES = {\n    iphone: 'iOS',\n    android:'Android',\n    mac: 'MacOS',\n    win: 'Windows',\n    linux: 'Linux',\n    other: 'Other'\n};\n\nlet userAgent = navigator.userAgent.toLowerCase(),\n    name = NAMES[(userAgent.match(/mac|win|linux/) || ['other'])[0]];\n\nswitch(name){\n\n    case 'MacOS':\n    case 'Linux':\n\n        {\n\n            let name = NAMES[(userAgent.match(/iphone|android/) || ['other'])[0]] ;\n\n            if(name !== 'Other'){\n\n                return name ;\n            }\n        }\n}\n\nreturn name ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956298336){\n\n            return var_once_value_1608956298336 ;\n\n        }\n        return var_once_value_1608956298336 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "os.name"
  },
  "src::is.primitive": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.primitive(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.number",
      "src::is.boolean",
      "src::is.string"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isNumber,isBoolean,isString;\n    \n                    let var_init_locked_1608956298338;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 判定数据是否为原始类型\n * \n * @import is.number\n * \n * @import is.boolean\n * \n * @import is.string\n * \n * @param {mixed} data 检验数据\n * \n * @return {boolean} 如果给定值为原始类型则返回 true , 否则返回 false \n * \n */\n\nreturn isNumber(data) || isBoolean(data) || isString(data) ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298338){\n\n            isNumber = include('src::is.number');\nisBoolean = include('src::is.boolean');\nisString = include('src::is.string');\n\n            var_init_locked_1608956298338 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.primitive"
  },
  "src::is.store.data": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.store.data(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::store",
      "src::is.class"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let store,isClass;\n    \n                    let var_init_locked_1608956298341;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 判断当前数据是否为数据存储器\n * \n * @import store\n * \n * @import is.class\n * \n * @param {mixed} data 检测数据\n * \n * @return {boolean} 如果检测数据为数据存储器则返回 true , 否则返回 false \n * \n */\n\nreturn isClass(data , 'store') ;\n \n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298341){\n\n            store = include('src::store');\nisClass = include('src::is.class');\n\n            var_init_locked_1608956298341 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.store.data"
  },
  "src::is.week.day.first": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.week.day.first(<Date> date , <number> weekStartDay)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(date , weekStartDay){\n\n        \n/**\n * \n * 判断指定日期是否为一周的第一天\n * \n * @param {Date} date 校验日期\n * \n * @param {number} [weekStartDay = 1] 确认一周是从周几算起\n *  \n * @return {boolean} 如果是第一天的话，则返回 true , 否则返回 false\n * \n */\n\n return date.getDay() === weekStartDay ;\n\n \n\n    }\n    \n                    return function(date , weekStartDay = 1){\n    \n                        \n    \n                        return main.call(this , date , weekStartDay) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.week.day.first"
  },
  "src::is.week.day.last": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::is.week.day.last(<Date> date , <number> weekStartDay)",
    "standard": true,
    "importNames": [
      "src::week.days"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getDays;\n    \n                    let var_init_locked_1608956298346;\n    \n                    \n\n                    function main(date , weekStartDay){\n\n        \n/**\n * \n * 判断指定日期是否为一周的最后一天\n * \n * @import getDays from week.days\n * \n * @param {Date} date 校验日期\n * \n * @param {number} [weekStartDay = 1] 确认一周是从周几算起\n *  \n * @return {boolean} 如果是最后一天的话，则返回 true , 否则返回 false\n * \n */\n\nlet days = getDays(weekStartDay) ;\n\nreturn date.getDay() === days[days.length - 1] ;\n\n    }\n    \n                    return function(date , weekStartDay = 1){\n    \n                        \n        if(!var_init_locked_1608956298346){\n\n            getDays = include('src::week.days');\n\n            var_init_locked_1608956298346 = true ;\n        }\n        \n    \n                        return main.call(this , date , weekStartDay) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "is.week.day.last"
  },
  "src::week.days": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::week.days(<number> startDay)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(startDay){\n\n        \n/**\n * \n * 获得一周周期排列\n * \n * @param {number} [startDay = 0] 确定起始周几\n * \n * @return {array} 一周周期排列数字集合\n * \n */\n\n let result = [\n     startDay\n ];\n\nwhile(result.length < 7){\n\n    startDay ++ ;\n\n    if(startDay <= 6){\n\n        result.push(startDay) ;\n    \n    }else{\n\n        result.push(startDay = 0) ;\n    }\n}\n\nreturn result ;\n\n\n    }\n    \n                    return function(startDay = 0){\n    \n                        \n    \n                        return main.call(this , startDay) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "week.days"
  },
  "src::directory.copy": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::directory.copy(<string> src , <string> dest , <boolean> isCopySrcFolder , <fuction> fn)",
    "standard": true,
    "importNames": [
      "src::is.directory",
      "src::directory.paths.file.all",
      "src::directory.create",
      "src::function.empty"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDirectory,getAllFilePaths,createDirectory,emptyFn;\n    \n                    let var_init_locked_1608956298352;\n    \n                    \n\n                    function main(src , dest , isCopySrcFolder , fn){\n\n        \n/**\n * \n * 拷贝文件夹\n * \n * @import is.directory\n * \n * @import getAllFilePaths from .paths.file.all\n * \n * @import createDirectory from directory.create\n * \n * @import emptyFn from function.empty value\n * \n * @param {string} src 拷贝的源文件夹目录\n * \n * @param {string} dest 目标文件夹目录\n * \n * @param {boolean} [isCopySrcFolder = true] 是否不拷贝源文件夹目录\n * \n * @param {fuction} [fn] 回调函数 \n * \n */\n\n const {\n    copyFileSync\n } = require('fs'),\n {\n    dirname\n } = require('path'),\n destPaths = [];\n\n fn = fn || emptyFn ;\n\n if(isDirectory(src)){\n\n    let paths = getAllFilePaths(src);\n\n    for(let path of paths){\n\n        let destPath = path.replace(isCopySrcFolder ? dirname(src) : src , dest) ;\n\n        createDirectory(dirname(destPath)) ;\n\n        copyFileSync(path , destPath) ;\n\n        fn(path , destPath) ;\n\n        destPaths.push(destPath) ;\n    }\n }\n\n return destPaths ;\n\n    }\n    \n                    return function(src , dest , isCopySrcFolder = true , fn){\n    \n                        \n        if(!var_init_locked_1608956298352){\n\n            isDirectory = include('src::is.directory');\ngetAllFilePaths = include('src::directory.paths.file.all');\ncreateDirectory = include('src::directory.create');\nemptyFn = include('src::function.empty')();\n\n            var_init_locked_1608956298352 = true ;\n        }\n        \n    \n                        return main.call(this , src , dest , isCopySrcFolder , fn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "directory.copy"
  },
  "src::directory.paths.file.all": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::directory.paths.file.all(<string> path , <RegExp> testRe)",
    "standard": true,
    "importNames": [
      "src::is.directory",
      "src::is.file"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDirectory,isFile;\n    \n                    let var_init_locked_1608956298354;\n    \n                    \n\n                    \n/**\n * \n * 读取目录下所有文件的路径\n * \n * @import is.directory\n * \n * @import is.file\n * \n * @param {string} path 文件夹目录路径\n * \n * @param {RegExp} [testRe] 路径匹配正则表达式\n * \n * @return {array} 多个文件路径\n * \n */\n\nfunction main(path , testRe){\n\n    if(isDirectory(path)){\n\n        const {\n            readdirSync\n        } = require('fs'),\n        {\n            join\n        } = require('path');\n    \n        let names = readdirSync(path),\n            paths = [];\n    \n        for(let name of names){\n    \n            let targetPath = join(path , name) ;\n    \n            if(isFile(targetPath)){\n\n                if(testRe && !testRe.test(targetPath)){\n\n                    continue ;\n                }\n    \n                paths.push(targetPath) ;\n            \n            }else{\n    \n                paths.push(...main(targetPath , testRe)) ;\n            }\n        }\n    \n        return paths ;\n    }\n    \n    return [] ;\n}\n    \n                    return function(path , testRe){\n    \n                        \n        if(!var_init_locked_1608956298354){\n\n            isDirectory = include('src::is.directory');\nisFile = include('src::is.file');\n\n            var_init_locked_1608956298354 = true ;\n        }\n        \n    \n                        return main.call(this , path , testRe) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "directory.paths.file.all"
  },
  "src::directory.create": {
    "meta": "code.meta.script.function",
    "signature": "async <mixed> src::directory.create(<string> path)",
    "standard": true,
    "importNames": [
      "src::is.directory"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDirectory;\n    \n                    let var_init_locked_1608956298357;\n    \n                    \n\n                    \n/**\n * \n * 创建不存在的目录，如果存在的话，则维持现状\n * \n * @import is.directory\n * \n * @param {string} path 目录路径\n * \n * @return {mixed} 返回说明 \n * \n * @scoped\n * \n */\n\nconst {\n    mkdir\n} = require('fs'),\nfolderRe = /(?:^\\/)|(?:[^\\/\\\\]+(?:[\\/\\\\]|$))/g;\n\nasync function main(path){\n\n    let folderNames = path.match(folderRe),\n        folderPath = '';\n\n    for(let folderName of folderNames){\n\n        folderPath += folderName ;\n\n        if(folderName !== '/' && !await isDirectory(folderPath)){\n\n            await new Promise((resolve , reject) => mkdir(folderPath , error => error ? reject(error) : resolve())) ;\n        }\n    }\n}\n\n    \n                    return async function(path){\n    \n                        \n        if(!var_init_locked_1608956298357){\n\n            isDirectory = include('src::is.directory');\n\n            var_init_locked_1608956298357 = true ;\n        }\n        \n    \n                        return await main.call(this , path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "directory.create"
  },
  "src::directory.includes": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::directory.includes(<string> path , {<mixed> includes , <mixed> excludes , <mixed> suffixes})",
    "standard": true,
    "importNames": [
      "src::array.from",
      "src::is.file",
      "src::is.directory",
      "src::directory.paths.file.all",
      "src::path.ext"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from,isFile,isDirectory,getFilePaths,ext;\n    \n                    let var_init_locked_1608956298360;\n    \n                    \n\n                    \n/**\n * \n * 在指定目录下包含下符合包含、排除规则的所有文件\n * \n * @import from from array.from\n * \n * @import is.file\n * \n * @import is.directory\n * \n * @import getFilePaths from .paths.file.all\n * \n * @import ext from path.ext\n * \n * @param {string} path 指定目录路径\n * \n * @param {object} options 配置\n * \n * @param {mixed} options.includes 包含资源\n * \n * @param {mixed} [options.excludes] 排除资源\n * \n * @param {mixed} [options.suffixes] 文件后缀名\n * \n * @return {array} 所有符合规则的文件\n * \n */\n\nconst {\n    join\n} = require('path');\n\nfunction main(path , {\n    includes,\n    excludes,\n    suffixes\n}){\n\n    let includeFilePaths = getPaths(path , includes),\n        excludeFilePaths = getPaths(path , excludes);\n\n    if(suffixes){\n\n        suffixes = from(suffixes) ;\n    }\n    \n    return includeFilePaths.filter(path => {\n\n        if(!excludeFilePaths.includes(path)){\n\n            if(suffixes && !suffixes.includes(ext(path))){\n\n                return false ;\n            }\n\n            return true ;\n        }\n\n        return false ;\n\n    }) ;\n}\n\nfunction getPaths(path , resources){\n\n    resources = from(resources) ;\n\n    let resourcePaths = [] ;\n\n    for(let resource of resources){\n\n        let resourcePath = join(path , resource) ;\n    \n        if(isFile(resourcePath)){\n    \n            resourcePaths.push(resourcePath) ;\n    \n        }else if(isDirectory(resourcePath)){\n    \n            resourcePaths.push(...getFilePaths(resourcePath)) ;\n        }\n    }\n\n    return resourcePaths ;\n    \n}\n\n\n\n\n\n    \n                    return function(path , {includes , excludes , suffixes}){\n    \n                        \n        if(!var_init_locked_1608956298360){\n\n            from = include('src::array.from');\nisFile = include('src::is.file');\nisDirectory = include('src::is.directory');\ngetFilePaths = include('src::directory.paths.file.all');\next = include('src::path.ext');\n\n            var_init_locked_1608956298360 = true ;\n        }\n        \n    \n                        return main.call(this , path , {includes , excludes , suffixes}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "directory.includes"
  },
  "src::path.ext": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::path.ext(<string> path)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    \n/**\n * \n * 获得路径的后缀名\n * \n * @param {string} path 路径\n * \n * @return {string} 后缀名\n * \n */\n\nconst extRe = /\\.[^\\/\\\\]+$/ ;\n\nfunction main(path){\n\n    let result = path.match(extRe) ;\n\n    if(result){\n\n        return result[0] ;\n    }\n}\n    \n                    return function(path){\n    \n                        \n    \n                        return main.call(this , path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "path.ext"
  },
  "src::directory.paths.directory": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::directory.paths.directory(<string> path)",
    "standard": true,
    "importNames": [
      "src::is.directory"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDirectory;\n    \n                    let var_init_locked_1608956298366;\n    \n                    \n\n                    function main(path){\n\n        \n/**\n * \n * 读取目录下所有的直接文件夹路径\n * \n * @import is.directory\n * \n * @param {string} path 文件夹目录路径\n * \n * @return {array} 多个文件夹路径\n * \n */\n\nif(isDirectory(path)){\n\n    const {\n        readdirSync\n    } = require('fs'),\n    {\n        join\n    } = require('path');\n\n    let names = readdirSync(path),\n        paths = [];\n\n    for(let name of names){\n\n        let targetPath = join(path , name) ;\n\n        if(isDirectory(targetPath)){\n\n            paths.push(targetPath) ;\n        }\n    }\n\n    return paths ;\n}\n\nreturn [] ;\n\n    }\n    \n                    return function(path){\n    \n                        \n        if(!var_init_locked_1608956298366){\n\n            isDirectory = include('src::is.directory');\n\n            var_init_locked_1608956298366 = true ;\n        }\n        \n    \n                        return main.call(this , path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "directory.paths.directory"
  },
  "src::directory.paths.file": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::directory.paths.file(<string> path)",
    "standard": true,
    "importNames": [
      "src::is.directory",
      "src::is.file"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDirectory,isFile;\n    \n                    let var_init_locked_1608956298371;\n    \n                    \n\n                    function main(path){\n\n        \n/**\n * \n * 读取目录下所有的直接文件路径\n * \n * @import is.directory\n * \n * @import is.file\n * \n * @param {string} path 文件夹目录路径\n * \n * @return {array} 多个文件路径\n * \n */\n\nif(isDirectory(path)){\n\n    const {\n        readdirSync\n    } = require('fs'),\n    {\n        join\n    } = require('path');\n\n    let names = readdirSync(path),\n        paths = [];\n\n    for(let name of names){\n\n        let targetPath = join(path , name) ;\n\n        if(isFile(targetPath)){\n\n            paths.push(targetPath) ;\n        }\n    }\n\n    return paths ;\n}\n\nreturn [] ;\n\n    }\n    \n                    return function(path){\n    \n                        \n        if(!var_init_locked_1608956298371){\n\n            isDirectory = include('src::is.directory');\nisFile = include('src::is.file');\n\n            var_init_locked_1608956298371 = true ;\n        }\n        \n    \n                        return main.call(this , path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "directory.paths.file"
  },
  "src::directory.readFilePaths": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::directory.readFilePaths(<string> path)",
    "standard": true,
    "importNames": [
      "src::is.directory",
      "src::is.file"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDirectory,isFile;\n    \n                    let var_init_locked_1608956298373;\n    \n                    \n\n                    function main(path){\n\n        \n/**\n * \n * 读取目录下所有的直接文件路径\n * \n * @import is.directory\n * \n * @import is.file\n * \n * @param {string} path 文件夹目录路径\n * \n * @return {array} 多个文件路径\n * \n */\n\nif(isDirectory(path)){\n\n    const {\n        readdirSync\n    } = require('fs'),\n    {\n        join\n    } = require('path');\n\n    let names = readdirSync(path),\n        paths = [];\n\n    for(let name of names){\n\n        let targetPath = join(path , name) ;\n\n        if(isFile(targetPath)){\n\n            paths.push(targetPath) ;\n        }\n    }\n\n    return paths ;\n}\n\nreturn [] ;\n\n\n\n\n    }\n    \n                    return function(path){\n    \n                        \n        if(!var_init_locked_1608956298373){\n\n            isDirectory = include('src::is.directory');\nisFile = include('src::is.file');\n\n            var_init_locked_1608956298373 = true ;\n        }\n        \n    \n                        return main.call(this , path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "directory.readFilePaths"
  },
  "src::browser.animationFrame.clear": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.animationFrame.clear(<number> animationFrameId)",
    "standard": true,
    "importNames": [
      "src::browser.animationFrame.stop",
      "src::browser.animationFrame.map"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let stop,getMap;\n    \n                    let var_init_locked_1608956298381;\n    \n                    \n\n                    function main(animationFrameId){\n\n        \n/**\n * \n * 清除一个连续动画帧\n * \n * @import stop from browser.animationFrame.stop\n * \n * @import getMap from browser.animationFrame.map\n * \n * @alias clearAnimationFrame\n * \n * @param {number} animationFrameId 动画帧编号\n * \n * @return {mixed} 返回说明 \n * \n */\n\nstop(animationFrameId) ;\n\ngetMap().delete(animationFrameId) ;\n\n\n    }\n    \n                    return function(animationFrameId){\n    \n                        \n        if(!var_init_locked_1608956298381){\n\n            stop = include('src::browser.animationFrame.stop');\ngetMap = include('src::browser.animationFrame.map');\n\n            var_init_locked_1608956298381 = true ;\n        }\n        \n    \n                        return main.call(this , animationFrameId) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.animationFrame.clear"
  },
  "src::browser.animationFrame.map": {
    "meta": "code.meta.script.function",
    "signature": "<Map> src::browser.animationFrame.map()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956298385;\n\n                    function main(){\n\n        \n/**\n * \n * 构建一个持久 Map 对象\n * \n * @return {Map} 动画帧维护集合\n * \n * @once\n * \n */\n\nreturn new Map() ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956298385){\n\n            return var_once_value_1608956298385 ;\n\n        }\n        return var_once_value_1608956298385 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.animationFrame.map"
  },
  "src::browser.animationFrame.stop": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.animationFrame.stop(<number> animationFrameId)",
    "standard": true,
    "importNames": [
      "src::browser.animationFrame.map"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getMap;\n    \n                    let var_init_locked_1608956298383;\n    \n                    \n\n                    function main(animationFrameId){\n\n        \n/**\n * \n * 清除一个连续动画帧\n * \n * @import getMap from browser.animationFrame.map\n * \n * @alias stopAnimationFrame\n * \n * @param {number} animationFrameId 动画帧编号\n * \n * @return {mixed} 返回说明 \n * \n */\n\nlet map = getMap() ;\n\nif(map.has(animationFrameId)){\n\n    map.get(animationFrameId).stop() ;\n}\n\n\n    }\n    \n                    return function(animationFrameId){\n    \n                        \n        if(!var_init_locked_1608956298383){\n\n            getMap = include('src::browser.animationFrame.map');\n\n            var_init_locked_1608956298383 = true ;\n        }\n        \n    \n                        return main.call(this , animationFrameId) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.animationFrame.stop"
  },
  "src::browser.animationFrame.set": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::browser.animationFrame.set(<function> fn , <mixed> scope)",
    "standard": true,
    "importNames": [
      "src::browser.animationFrame.map"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getMap;\n    \n                    let var_init_locked_1608956298387;\n    \n                    \n\n                    \n/**\n * \n * 创建一个连续动画帧\n * \n * @import getMap from browser.animationFrame.map\n * \n * @alias setAnimationFrame\n * \n * @param {function} fn 动画帧回调函数\n * \n * @param {mixed} scope 动画帧回调函数作用域\n * \n * @return {number} 动画帧编号\n * \n * @scoped\n * \n */\n\nlet count = 0 ;\n\nfunction main(fn , scope){\n\n    count ++ ;\n\n    let map = getMap(),\n        animationFrame = new AnimationFrame(fn , scope);\n\n    map.set(count , animationFrame) ;\n\n    animationFrame.start() ;\n\n    return count ;\n}\n\nclass AnimationFrame{\n\n    constructor(fn , scope){\n\n        let me = this ;\n\n        me.fn = fn ;\n\n        me.scope = scope ;\n    }\n\n    start(){\n\n        let me = this,\n            {\n                fn,\n                scope\n            } = me,\n            animationFrame = time =>{\n\n                fn.call(scope , time) ;\n\n                me.animationFrameId = requestAnimationFrame(animationFrame) ;\n                \n            } ;\n\n        me.animationFrameId = requestAnimationFrame(animationFrame) ;\n    }\n\n    stop(){\n\n        cancelAnimationFrame(this.animationFrameId) ;\n    }\n}\n    \n                    return function(fn , scope){\n    \n                        \n        if(!var_init_locked_1608956298387){\n\n            getMap = include('src::browser.animationFrame.map');\n\n            var_init_locked_1608956298387 = true ;\n        }\n        \n    \n                        return main.call(this , fn , scope) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.animationFrame.set"
  },
  "src::browser.animationFrame.start": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.animationFrame.start(<number> animationFrameId)",
    "standard": true,
    "importNames": [
      "src::browser.animationFrame.map"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getMap;\n    \n                    let var_init_locked_1608956298390;\n    \n                    \n\n                    function main(animationFrameId){\n\n        \n/**\n * \n * 清除一个连续动画帧\n * \n * @import getMap from browser.animationFrame.map\n * \n * @alias startAnimationFrame\n * \n * @param {number} animationFrameId 动画帧编号\n * \n * @return {mixed} 返回说明 \n * \n */\n\nlet map = getMap() ;\n\nif(map.has(animationFrameId)){\n\n    map.get(animationFrameId).start() ;\n}\n\n\n    }\n    \n                    return function(animationFrameId){\n    \n                        \n        if(!var_init_locked_1608956298390){\n\n            getMap = include('src::browser.animationFrame.map');\n\n            var_init_locked_1608956298390 = true ;\n        }\n        \n    \n                        return main.call(this , animationFrameId) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.animationFrame.start"
  },
  "src::browser.canvas.begin": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.begin(<canvas.Context> context , <boolean> independent)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(context , independent){\n\n        \n/**\n * \n * 图形开始\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {boolean} [independent = true] 是否为独立图形\n * \n */\n\nif(independent){\n\n    context.beginPath();\n }\n\n    }\n    \n                    return function(context , independent = true){\n    \n                        \n    \n                        return main.call(this , context , independent) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.begin"
  },
  "src::browser.canvas.clear": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.clear(<canvas.Context> context , {<number> x , <number> y , <number> width , <number> height})",
    "standard": true,
    "importNames": [
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isNumber;\n    \n                    let var_init_locked_1608956298394;\n    \n                    \n\n                    function main(context , {x , y , width , height}){\n\n        \n/**\n * \n * 清空画板\n * \n * @import is.number\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {object} [config = {}] 画线配置\n * \n * @param {number} [config.x = 0] 清空起始横坐标 \n * \n * @param {number} [config.y = 0] 清空起始纵坐标\n * \n * @param {number} config.width 清空宽度\n * \n * @param {number} config.height 清空高度\n * \n */\n\n let {\n    canvas\n } = context ;\n\n if(!isNumber(width)){\n\n    width = canvas.width ;\n }\n\n if(!isNumber(height)){\n\n    height = canvas.height ;\n }\n\n context.clearRect(x , y , width , height) ;\n\n    }\n    \n                    return function(context , {x = 0 , y = 0 , width , height} = {}){\n    \n                        \n        if(!var_init_locked_1608956298394){\n\n            isNumber = include('src::is.number');\n\n            var_init_locked_1608956298394 = true ;\n        }\n        \n    \n                        return main.call(this , context , {x , y , width , height}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.clear"
  },
  "src::browser.canvas.data.get": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.data.get(<canvas.Context> context , {<number> x , <number> y , <number> width , <number> height})",
    "standard": true,
    "importNames": [
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isNumber;\n    \n                    let var_init_locked_1608956298397;\n    \n                    \n\n                    function main(context , {x , y , width , height}){\n\n        \n/**\n * \n * 获取画布数据\n * \n * @import is.number\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {object} [config = {}] 绘制配置\n * \n * @param {number} [config.x = 0] 截图横坐标\n * \n * @param {number} [config.y = 0] 截图纵坐标\n * \n * @param {number} [config.width] 截图横坐标\n * \n * @param {number} [config.height] 截图纵坐标\n * \n * \n */\n\nlet {\n    canvas\n } = context ;\n\n if(!isNumber(width)){\n\n    width = canvas.width ;\n }\n\n if(!isNumber(height)){\n\n    height = canvas.height ;\n }\n\n return context.getImageData(x , y , width , height) ;\n\n    }\n    \n                    return function(context , {x = 0 , y = 0 , width , height} = {}){\n    \n                        \n        if(!var_init_locked_1608956298397){\n\n            isNumber = include('src::is.number');\n\n            var_init_locked_1608956298397 = true ;\n        }\n        \n    \n                        return main.call(this , context , {x , y , width , height}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.data.get"
  },
  "src::browser.canvas.data.insert": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.data.insert(<canvas.Context> context , {<ImageData> data , <number> x , <number> y})",
    "standard": true,
    "importNames": [
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isNumber;\n    \n                    let var_init_locked_1608956298399;\n    \n                    \n\n                    function main(context , {data , x , y}){\n\n        \n/**\n * \n * 函数实现说明\n * \n * @import is.number\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {object} [config = {}] 绘制配置\n * \n * @param {ImageData} config.data 截图数据\n * \n * @param {number} [config.x = 0] 截图横坐标\n * \n * @param {number} [config.y = 0] 截图纵坐标\n * \n */\n\ncontext.putImageData(data , x , y) ;\n\n    }\n    \n                    return function(context , {data , x = 0 , y = 0} = {}){\n    \n                        \n        if(!var_init_locked_1608956298399){\n\n            isNumber = include('src::is.number');\n\n            var_init_locked_1608956298399 = true ;\n        }\n        \n    \n                        return main.call(this , context , {data , x , y}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.data.insert"
  },
  "src::browser.canvas.data.set": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.data.set(<canvas.Context> context , {<ImageData> data})",
    "standard": true,
    "importNames": [
      "src::browser.canvas.clear",
      "src::browser.canvas.data.insert"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let clear,insert;\n    \n                    let var_init_locked_1608956298400;\n    \n                    \n\n                    function main(context , {data}){\n\n        \n/**\n * \n * 设置画布数据\n * \n * @import clear from browser.canvas.clear\n * \n * @import insert from browser.canvas.data.insert\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {object} [config = {}] 绘制配置\n * \n * @param {ImageData} config.data 截图数据\n * \n * \n */\n\nclear(context) ;\n\ninsert(context , {\n    data\n}) ;\n\n    }\n    \n                    return function(context , {data} = {}){\n    \n                        \n        if(!var_init_locked_1608956298400){\n\n            clear = include('src::browser.canvas.clear');\ninsert = include('src::browser.canvas.data.insert');\n\n            var_init_locked_1608956298400 = true ;\n        }\n        \n    \n                        return main.call(this , context , {data}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.data.set"
  },
  "src::browser.canvas.draw.line.arc": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.draw.line.arc(<canvas.Context> context , {<number> x , <number> y , <number> r , <number> start , <number> end , <number> counterclockwise , <boolean> independent , <boolean> clip , <object> ...styles})",
    "standard": true,
    "importNames": [
      "src::object.assign",
      "src::math.degree2radian",
      "src::browser.canvas.begin",
      "src::browser.canvas.end"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let assign,degree2radian,doBegin,doEnd;\n    \n                    let var_init_locked_1608956298402;\n    \n                    \n\n                    function main(context , {x , y , r , start , end , counterclockwise , independent , clip , ...styles}){\n\n        \n/**\n * \n * 绘制弧线\n * \n * @import assign from object.assign\n * \n * @import degree2radian from math.degree2radian\n * \n * @import doBegin from browser.canvas.begin\n * \n * @import doEnd from browser.canvas.end\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {object} [config = {}] 画线配置\n * \n * @param {number} config.x 圆中心点横坐标\n * \n * @param {number} config.y 圆中心点纵坐标\n * \n * @param {number} config.r 圆的半径\n * \n * @param {number} [config.start = -90] 圆起始角度\n * \n * @param {number} config.end 圆终止角度\n * \n * @param {number} [config.counterclockwise = false] 如果为 false 则为顺时针，反之为逆时针\n * \n * @param {boolean} [config.independent = true] 是否为独立图形\n * \n * @param {boolean} [config.clip = false] 是否为剪切路径\n * \n * @param {object} [...config.styles] 画线样式\n * \n */\n\ndoBegin(context , independent) ;\n\nassign(context , styles) ;\n\ncontext.arc(x * scale , y , r , degree2radian(start) , degree2radian(end) , counterclockwise) ;\n\ndoEnd(context , clip) ;\n\n    }\n    \n                    return function(context , {x , y , r , start = -90 , end , counterclockwise = false , independent = true , clip = false , ...styles} = {}){\n    \n                        \n        if(!var_init_locked_1608956298402){\n\n            assign = include('src::object.assign');\ndegree2radian = include('src::math.degree2radian');\ndoBegin = include('src::browser.canvas.begin');\ndoEnd = include('src::browser.canvas.end');\n\n            var_init_locked_1608956298402 = true ;\n        }\n        \n    \n                        return main.call(this , context , {x , y , r , start , end , counterclockwise , independent , clip , ...styles}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.draw.line.arc"
  },
  "src::math.degree2radian": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.degree2radian(<number> degree)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(degree){\n\n        \n/**\n * \n * 将角度转换成弧度\n * \n * @param {number} degree 角度\n * \n * @return {number} 弧度 \n * \n */\n\nreturn Math.PI / 180 * degree ;\n\n\n    }\n    \n                    return function(degree){\n    \n                        \n    \n                        return main.call(this , degree) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.degree2radian"
  },
  "src::browser.canvas.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.end(<canvas.Context> context , <boolean> clip)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(context , clip){\n\n        /**\n * \n * 图形结束\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {boolean} [clip = false] 是否为剪切路径\n * \n * \n */\n\n if(clip){\n\n    context.clip() ;\n \n }else{\n\n    context.stroke();\n }\n\n    }\n    \n                    return function(context , clip = false){\n    \n                        \n    \n                        return main.call(this , context , clip) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.end"
  },
  "src::browser.canvas.draw.line.bezierCurve": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.draw.line.bezierCurve(<canvas.Context> context , {<array> lineDash , <array> points , <object> ...styles})",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(context , {lineDash , points , ...styles}){\n\n        \n/**\n * \n * 绘制贝赛尔曲线\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {object} [config = {}] 画线配置\n * \n * @param {array} [config.lineDash = []] 虚线设置\n * \n * @param {array} [config.points = []] 画线点集合\n * \n * @param {object} [...config.styles] 画线样式\n * \n */\n\n if(points.length === 8){\n\n    context.beginPath();\n\n    Object.assign(context , styles) ;\n\n    context.setLineDash(lineDash) ;\n\n    context.moveTo(...points.slice(0 , 2));\n    \n    context.bezierCurveTo(...points.slice(2));\n    \n    context.stroke();\n }\n\n    }\n    \n                    return function(context , {lineDash = [] , points = [] , ...styles} = {}){\n    \n                        \n    \n                        return main.call(this , context , {lineDash , points , ...styles}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.draw.line.bezierCurve"
  },
  "src::browser.canvas.draw.line": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.draw.line(<canvas.Context> context , {<array> points , <array> lineDash , <boolean> independent , <boolean> clip , <object> ...styles})",
    "standard": true,
    "importNames": [
      "src::browser.canvas.begin",
      "src::browser.canvas.end"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let doBegin,doEnd;\n    \n                    let var_init_locked_1608956298410;\n    \n                    \n\n                    function main(context , {points , lineDash , independent , clip , ...styles}){\n\n        \n/**\n * \n * 绘制直线\n * \n * @import doBegin from browser.canvas.begin\n * \n * @import doEnd from browser.canvas.end\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {object} [config = {}] 画线配置\n * \n * @param {array} [config.points = []] 画线点集合\n * \n * @param {array} [config.lineDash = []] 虚线设置\n * \n * @param {boolean} [config.independent = true] 是否为独立图形\n * \n * @param {boolean} [config.clip = false] 是否为剪切路径\n * \n * @param {object} [...config.styles] 画线样式\n * \n */\n\n if(points.length === 4){\n\n    doBegin(context , independent) ;\n\n    Object.assign(context , styles) ;\n\n    context.setLineDash(lineDash) ;\n\n    context.moveTo(...points.slice(0 , 2));\n    \n    context.lineTo(...points.slice(2));\n    \n    doEnd(context , clip) ;\n }\n\n    }\n    \n                    return function(context , {points = [] , lineDash = [] , independent = true , clip = false , ...styles} = {}){\n    \n                        \n        if(!var_init_locked_1608956298410){\n\n            doBegin = include('src::browser.canvas.begin');\ndoEnd = include('src::browser.canvas.end');\n\n            var_init_locked_1608956298410 = true ;\n        }\n        \n    \n                        return main.call(this , context , {points , lineDash , independent , clip , ...styles}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.draw.line"
  },
  "src::browser.canvas.draw.word": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.draw.word(<canvas.Context> context , {<string> text , <number> x , <number> y , <object> ...styles})",
    "standard": true,
    "importNames": [
      "src::object.assign",
      "src::browser.scale"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let assign,scale;\n    \n                    let var_init_locked_1608956298416;\n    \n                    \n\n                    function main(context , {text , x , y , ...styles}){\n\n        \n/**\n * \n * 绘制文本\n * \n * @import assign from object.assign\n * \n * @import scale from browser.scale value\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {object} config = {} 绘制配置\n * \n * @param {string} config.text 绘制文本 \n * \n * @param {number} config.x 画线横坐标\n * \n * @param {number} config.y 画线纵坐标\n * \n * @param {object} [...config.styles] 文本样式\n * \n */\n\nassign(context , styles) ;\n\ncontext.fillText(text , x * scale , y * scale) ;\n\n    }\n    \n                    return function(context , {text , x , y , ...styles}){\n    \n                        \n        if(!var_init_locked_1608956298416){\n\n            assign = include('src::object.assign');\nscale = include('src::browser.scale')();\n\n            var_init_locked_1608956298416 = true ;\n        }\n        \n    \n                        return main.call(this , context , {text , x , y , ...styles}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.draw.word"
  },
  "src::browser.scale": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::browser.scale()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956298418;\n\n                    function main(){\n\n        /**\n * \n * 获得当前浏览器的缩放比率\n * \n * @return {number} 缩放比率\n * \n * @once\n * \n */\n\nreturn window.devicePixelRatio ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956298418){\n\n            return var_once_value_1608956298418 ;\n\n        }\n        return var_once_value_1608956298418 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.scale"
  },
  "src::browser.canvas.init": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.init(<HTMLElement> canvas , <number> scale)",
    "standard": true,
    "importNames": [
      "src::browser.scale",
      "src::os.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let browserScale,OS;\n    \n                    let var_init_locked_1613308339794;\n    \n                    \n\n                    function main(canvas , scale){\n\n        \n/**\n * \n * 初始化画板\n * \n * @import browserScale from browser.scale value\n * \n * @import OS from os.name value\n * \n * @param {HTMLElement} canvas 画板元素\n * \n * @param {number} [scale = 1] 外部传入缩放比例\n * \n * \n */\n\n let {\n    clientWidth,\n    clientHeight\n } = canvas ;\n\n scale *= browserScale ;\n\n /*switch(OS){\n\n   case 'Android':\n   case 'iOS':\n\n      scale = 1 ;\n }*/\n\n canvas.width = clientWidth * scale;\n\n canvas.height = clientHeight * scale;\n\n canvas.getContext('2d').scale(scale , scale) ;\n\n    }\n    \n                    return function(canvas , scale = 1){\n    \n                        \n        if(!var_init_locked_1613308339794){\n\n            browserScale = include('src::browser.scale')();\nOS = include('src::os.name')();\n\n            var_init_locked_1613308339794 = true ;\n        }\n        \n    \n                        return main.call(this , canvas , scale) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.init"
  },
  "src::browser.canvas.player.engine": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.player.engine(<browser.canvas.Player> player)",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::is.number",
      "src::event.listener.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Observable,isNumber,add;\n    \n                    let var_init_locked_1608956298422;\n    \n                    let var_class_1608956298422;\n    \n                    \n\n                    let var_global_main_1608956298422 ;\n    \n                    return function(player){\n    \n                        \n        if(!var_init_locked_1608956298422){\n\n            Observable = include('src::mixin.observable');\nisNumber = include('src::is.number');\nadd = include('src::event.listener.add');\n\n            \n/**\n * \n * 播放器引擎\n * \n * @import Observable from mixin.observable\n * \n * @import is.number\n * \n * @import add from event.listener.add\n * \n * @param {browser.canvas.Player} player 播放器\n * \n * \n */\n\n class main extends mixins({\n    mixins:[\n       Observable\n    ]\n}){\n\n    constructor({\n        player,\n        ...options\n    }){\n\n        super(options) ;\n\n        let me = this ;\n\n        me.player = player ;\n\n        add(player , 'add' , 'onPlayerAdd' , {\n            scope:me\n        }) ;\n    }\n\n    onPlayerAdd(player , user){\n\n        this.start(user) ;\n    }\n\n    get isRunning(){\n\n        return this.hasOwnProperty('runId') ;\n    }\n\n    start(user){\n\n        let me = this,\n        {\n            isRunning,\n            player\n        } = me ;\n\n        if(!isRunning){\n\n            user = user || player.activeUser ;\n\n            if(user){\n\n                launch.call(me , user) ;\n            }\n        }\n    }\n\n    end(){\n\n        let me = this,\n        {\n            runId\n        }= me ;\n\n        if(isNumber(runId)){\n\n            clearTimeout(runId) ;\n        }\n\n        delete me.runId ;\n    }\n }\n\n function launch(user) {\n     \n    let me = this,\n    {\n        player\n    } = me,\n    {\n        cursor,\n        records\n    } = user;\n\n    let record = records[cursor];\n\n    if(record){\n        \n        let {\n            api,\n            params,\n            delay\n        } = record ;\n\n        user.cursor = cursor + 1;\n\n        if(isNumber(delay)){\n\n            me.runId = setTimeout(() => {\n\n                include(`browser.canvas.record.api.${api}`).call(player , params) ;\n    \n                launch.call(me , user) ;\n    \n            } , delay) ;\n        \n        }else{\n\n            me.runId = null ;\n\n            include(`browser.canvas.record.api.${api}`).call(player , params) ;\n    \n            launch.call(me , user) ;\n        }\n    \n    }else{\n\n        me.end() ;\n\n        me.start() ;\n    }\n }\n\n            var_class_1608956298422 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298422 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::browser.canvas.player.engine' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298422 ;\n        \nvar_global_main_1608956298422 = main;\n\n            var_init_locked_1608956298422 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298422(player) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.player.engine"
  },
  "src::browser.canvas.player": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.player(<canvas.Context> context)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::is.string",
      "src::is.function",
      "src::mixin.observable",
      "src::browser.canvas.data.get",
      "src::browser.canvas.data.set",
      "src::browser.canvas.player.engine",
      "src::array.remove.all"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,isString,isFunction,Observable,getData,setData,createEngine,removeAll;\n    \n                    let var_init_locked_1608956298428;\n    \n                    let var_class_1608956298428;\n    \n                    \n\n                    let var_global_main_1608956298428 ;\n    \n                    return function(context){\n    \n                        \n        if(!var_init_locked_1608956298428){\n\n            isObject = include('src::is.object.simple');\nisString = include('src::is.string');\nisFunction = include('src::is.function');\nObservable = include('src::mixin.observable');\ngetData = include('src::browser.canvas.data.get');\nsetData = include('src::browser.canvas.data.set');\ncreateEngine = include('src::browser.canvas.player.engine');\nremoveAll = include('src::array.remove.all');\n\n            /**\n * \n * 画板播放机\n * \n * @import isObject from is.object.simple\n * \n * @import is.string\n * \n * @import is.function\n * \n * @import Observable from mixin.observable\n * \n * @import getData from browser.canvas.data.get\n * \n * @import setData from browser.canvas.data.set\n * \n * @import createEngine from .player.engine\n * \n * @import removeAll from array.remove.all\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n */\n\n const {\n    keys\n } = Object ;\n\n \nclass main extends mixins({\n    mixins:[\n       Observable\n    ]\n}){\n\n    constructor({\n        context,\n        user,\n        ...options\n    }){\n\n        super(options) ;\n\n        let me = this ;\n\n        me.context = context ;\n\n        me.users = {};\n\n        tryCreateUser.call(me , {\n            [user]({\n                delay,\n                ...params\n            }){\n\n                return params ;\n            }\n        }) ;\n\n        me.engine = createEngine({\n            player:me\n        }) ;\n\n        me.activeUsers = [] ;\n        \n    }\n\n    saveData(){\n\n        let me = this,\n        {\n            context\n        } = me ;\n\n        me.data = getData(context) ;\n    }\n\n    redrawData(){\n\n        let {\n            data,\n            context\n        } = this ;\n\n        setData(context , {\n            data\n        }) ;\n    }\n\n    get activeUser(){\n\n        let {\n            activeUsers\n        } = this,\n        [\n            user\n        ] = activeUsers;\n\n        if(user){\n\n            removeAll(activeUsers , user) ;\n\n            return user ;\n        }\n    }\n\n    add({\n        user,\n        ...record\n    }){\n\n        let me = this,\n        {\n            users,\n            activeUsers\n        } = me;\n\n        tryCreateUser.call(me , user) ;\n\n        user = users[user] ;\n\n        let {\n            records,\n            convert\n        } = user;\n\n        records.push(convert(record)) ;\n\n        activeUsers.push(user) ;\n\n        me.fireEvent('add' , user , record) ;\n    }\n }\n\n function tryCreateUser(user){\n\n    let {\n        users\n    } = this ;\n\n    if(isString(user)){\n\n        user = {\n            [user]:{\n                covnert:record => record\n            }\n        } ;\n    }\n\n    console.log(user) ;\n\n    if(isObject(user)){\n\n        let names = keys(user) ;\n\n        for(let name of names){\n\n            if(!users.hasOwnProperty(name)){\n\n                let config = user[name] ;\n\n                if(isFunction(config)){\n\n                    config = {\n                        convert:config\n                    } ;\n                }\n\n                if(isObject(config)){\n\n                    users[name] = {\n                        ...config,\n                        cursor:0,\n                        records:[]\n                    } ;\n                }\n            }\n        }\n    }\n }\n\n\n            var_class_1608956298428 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298428 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::browser.canvas.player' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298428 ;\n        \nvar_global_main_1608956298428 = main;\n\n            var_init_locked_1608956298428 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298428(context) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.player"
  },
  "src::browser.canvas.record.api.brush.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.brush.end(<object> config)",
    "standard": true,
    "importNames": [
      "src::browser.canvas.record.api.brush.move"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956298432 = new Map();\n    \n                    return function(config){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956298432.has(this)){\n\n            var_current_scope_1608956298432.set(this , (() => {\n                const move = include('src::browser.canvas.record.api.brush.move').bind(this);\n\n                function main(config){\n\n        \n/**\n * \n * 画笔终止\n * \n * @import move from .move scoped\n * \n * @param {object} [config] 画线配置\n * \n */\n\n move(config) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298432.get(this) ;\n\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.brush.end"
  },
  "src::browser.canvas.record.api.brush.move": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.brush.move({<number> x , <number> y , <object> ...styles})",
    "standard": true,
    "importNames": [
      "src::object.assign",
      "src::browser.scale"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let assign,scale;\n    \n                    let var_init_locked_1608956298434;\n    \n                    \n\n                    function main({x , y , ...styles}){\n\n        \n/**\n * \n * 画笔移动\n * \n * @import assign from object.assign\n * \n * @import scale from browser.scale value\n * \n * @param {object} [config = {}] 画线配置\n * \n * @param {number} config.x 画线横坐标\n * \n * @param {number} config.y 画线纵坐标\n * \n * @param {object} [...config.styles] 画线样式\n * \n */\n\n let {\n    context\n } = this ;\n\nassign(context , styles) ;\n\ncontext.lineTo(x * scale , y * scale);\n\ncontext.stroke();\n\n    }\n    \n                    return function({x , y , ...styles} = {}){\n    \n                        \n        if(!var_init_locked_1608956298434){\n\n            assign = include('src::object.assign');\nscale = include('src::browser.scale')();\n\n            var_init_locked_1608956298434 = true ;\n        }\n        \n    \n                        return main.call(this , {x , y , ...styles}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.brush.move"
  },
  "src::browser.canvas.record.api.brush.start": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.brush.start({<number> x , <number> y , <object> ...styles})",
    "standard": true,
    "importNames": [
      "src::object.assign",
      "src::browser.scale"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let assign,scale;\n    \n                    let var_init_locked_1608956298436;\n    \n                    \n\n                    function main({x , y , ...styles}){\n\n        \n/**\n * \n * 画笔开始\n * \n * @import assign from object.assign\n * \n * @import scale from browser.scale value\n * \n * @param {object} [config = {}] 画线配置\n * \n * @param {number} config.x 画笔开始横坐标\n * \n * @param {number} config.y 画笔开始纵坐标\n * \n * @param {object} [...config.styles] 画线样式\n * \n */\n\n let {\n    context\n } = this ;\n\ncontext.beginPath();\n\nassign(context , styles) ;\n\ncontext.moveTo(x * scale , y * scale);\n\n    }\n    \n                    return function({x , y , ...styles} = {}){\n    \n                        \n        if(!var_init_locked_1608956298436){\n\n            assign = include('src::object.assign');\nscale = include('src::browser.scale')();\n\n            var_init_locked_1608956298436 = true ;\n        }\n        \n    \n                        return main.call(this , {x , y , ...styles}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.brush.start"
  },
  "src::browser.canvas.record.api.brush": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.brush(<object> config)",
    "standard": true,
    "importNames": [
      "src::browser.canvas.draw.line",
      "src::browser.scale"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let draw,scale;\n    \n                    let var_init_locked_1608956298438;\n    \n                    \n\n                    function main(config){\n\n        \n/**\n * \n * 画笔\n * \n * @import draw from browser.canvas.draw.line\n * \n * @import scale from browser.scale value\n * \n * @param {object} [config] 画线配置\n * \n * \n */\n\nlet {\n    context\n } = this ;\n\n draw(context , config) ;\n\n    }\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298438){\n\n            draw = include('src::browser.canvas.draw.line');\nscale = include('src::browser.scale')();\n\n            var_init_locked_1608956298438 = true ;\n        }\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.brush"
  },
  "src::browser.canvas.record.api.eraser.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.eraser.end(<object> config)",
    "standard": true,
    "importNames": [
      "src::browser.canvas.record.api.eraser.move"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956298440 = new Map();\n    \n                    return function(config){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956298440.has(this)){\n\n            var_current_scope_1608956298440.set(this , (() => {\n                const move = include('src::browser.canvas.record.api.eraser.move').bind(this);\n\n                function main(config){\n\n        \n/**\n * \n * 橡皮擦移动\n * \n * @import move from .move scoped\n * \n * @param {object} [config] 擦除配置\n * \n **/\n\n move(config) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298440.get(this) ;\n\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.eraser.end"
  },
  "src::browser.canvas.record.api.eraser.move": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.eraser.move({<number> x , <number> y , <number> size})",
    "standard": true,
    "importNames": [
      "src::browser.canvas.draw.line.arc",
      "src::browser.canvas.clear"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let arc,clear;\n    \n                    let var_init_locked_1608956298442;\n    \n                    \n\n                    function main({x , y , size}){\n\n        \n/**\n * \n * 橡皮擦移动\n * \n * @import arc from browser.canvas.draw.line.arc\n * \n * @import clear from browser.canvas.clear\n * \n * @param {object} [config = {}] 擦除配置\n * \n * @param {number} config.x 擦除横坐标\n * \n * @param {number} config.y 擦除纵坐标\n * \n * @param {number} config.size 橡皮擦大小\n * \n */\n\n let {\n    context\n } = this ;\n\n context.save() ;\n\n arc(context , {\n     x,\n     y,\n     r:size / 2,\n     end:270,\n     clip:true\n }) ;\n\n clear(context) ;\n\n context.restore() ;\n\n    }\n    \n                    return function({x , y , size} = {}){\n    \n                        \n        if(!var_init_locked_1608956298442){\n\n            arc = include('src::browser.canvas.draw.line.arc');\nclear = include('src::browser.canvas.clear');\n\n            var_init_locked_1608956298442 = true ;\n        }\n        \n    \n                        return main.call(this , {x , y , size}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.eraser.move"
  },
  "src::browser.canvas.record.api.eraser.start": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.eraser.start(<object> config)",
    "standard": true,
    "importNames": [
      "src::browser.canvas.record.api.eraser.move"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956298444 = new Map();\n    \n                    return function(config){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956298444.has(this)){\n\n            var_current_scope_1608956298444.set(this , (() => {\n                const move = include('src::browser.canvas.record.api.eraser.move').bind(this);\n\n                function main(config){\n\n        \n/**\n * \n * 橡皮擦开始\n * \n * @import move from .move scoped\n * \n * @param {object} [config] 擦除配置\n * \n */\n\n move(config) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298444.get(this) ;\n\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.eraser.start"
  },
  "src::browser.canvas.record.api.eraser": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.eraser({<array> points , <number> size})",
    "standard": true,
    "importNames": [
      "src::browser.canvas.draw.line.arc",
      "src::browser.canvas.clear"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let arc,clear;\n    \n                    let var_init_locked_1608956298447;\n    \n                    \n\n                    function main({points , size}){\n\n        \n/**\n * \n * 橡皮擦\n * \n * @import arc from browser.canvas.draw.line.arc\n * \n * @import clear from browser.canvas.clear\n * \n * @param {object} [config = {}] 擦除配置\n * \n * @param {array} [config.points = []] 擦除点集合\n * \n * @param {number} config.size 橡皮擦大小\n * \n */\n\nlet {\n    context\n } = this ;\n\n context.save() ;\n\n let {\n     length\n } = points ;\n\n for(let i = 0 ; i < length ; i += 2){\n\n    let x = points[i] ;\n\n    arc(context , {\n        x,\n        y:x + 1,\n        r:size / 2,\n        end:270,\n        clip:true\n    }) ;\n }\n\n clear(context) ;\n\n context.restore() ;\n\n    }\n    \n                    return function({points = [] , size} = {}){\n    \n                        \n        if(!var_init_locked_1608956298447){\n\n            arc = include('src::browser.canvas.draw.line.arc');\nclear = include('src::browser.canvas.clear');\n\n            var_init_locked_1608956298447 = true ;\n        }\n        \n    \n                        return main.call(this , {points , size}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.eraser"
  },
  "src::browser.canvas.record.api.word.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.word.end()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 绘制文字结束\n * \n * \n */\n\n this.saveData() ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.word.end"
  },
  "src::browser.canvas.record.api.word.input": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.word.input(<object> config)",
    "standard": true,
    "importNames": [
      "src::browser.canvas.draw.word"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let draw;\n    \n                    let var_init_locked_1608956298451;\n    \n                    \n\n                    function main(config){\n\n        \n/**\n * \n * 绘制文字中\n * \n * @import draw from browser.canvas.draw.word\n * \n * @param {object} [config] 文字配置\n * \n */\n\nlet me = this,\n{\n    context\n} = me ;\n\nme.redrawData() ;\n\ndraw(context , config) ;\n\n    }\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298451){\n\n            draw = include('src::browser.canvas.draw.word');\n\n            var_init_locked_1608956298451 = true ;\n        }\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.word.input"
  },
  "src::browser.canvas.record.api.word.start": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.word.start()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 绘制文字开始\n * \n */\n\nthis.saveData() ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.word.start"
  },
  "src::browser.canvas.record.api.word": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.record.api.word(<object> config)",
    "standard": true,
    "importNames": [
      "src::browser.canvas.draw.word"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let draw;\n    \n                    let var_init_locked_1608956298454;\n    \n                    \n\n                    function main(config){\n\n        \n/**\n * \n * 绘制文字\n * \n * @import draw from browser.canvas.draw.word\n * \n * @param {object} [config] 文字配置\n * \n */\n\nlet {\n    context\n} = this ;\n\ndraw(context , config) ;\n\n    }\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298454){\n\n            draw = include('src::browser.canvas.draw.word');\n\n            var_init_locked_1608956298454 = true ;\n        }\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.record.api.word"
  },
  "src::browser.canvas.recorder": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.recorder(<canvas.Context> context)",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::array.clear"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Observable,arrayClear;\n    \n                    let var_init_locked_1608956298458;\n    \n                    let var_class_1608956298458;\n    \n                    \n\n                    let var_global_main_1608956298458 ;\n    \n                    return function(context){\n    \n                        \n        if(!var_init_locked_1608956298458){\n\n            Observable = include('src::mixin.observable');\narrayClear = include('src::array.clear');\n\n            \n/**\n * \n * 画板录制机\n * \n * @import Observable from mixin.observable\n * \n * @import array.clear\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n */\n\n class main extends mixins({\n    mixins:[\n       Observable\n    ]\n}){\n\n    constructor({\n        user,\n        ...options\n    }){\n\n        super(options) ;\n\n        let me = this ;\n\n        me.user = user ;\n    }\n\n    begin(api , params){\n\n        record.call(this , api , params , 'start' , false) ;\n    }\n\n    record(api , params){\n\n        record.call(this , api , params , 'process') ;\n    }\n\n    end(api , params){\n\n        record.call(this , api , params , 'end' , false) ;\n    }\n }\n\n function record(api , params , type , isCalcDelay = true){\n\n    let me = this,\n    {\n        user,\n        previousTime\n    } = me,\n    record = {\n        type,\n        user,\n        api,\n        params\n    } ;\n\n    if(isCalcDelay){\n\n        record.delay = Date.now() - previousTime ;\n    }\n\n    me.previousTime = Date.now() ;\n\n    me.fireEvent('record' , record) ;\n }\n\n            var_class_1608956298458 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298458 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::browser.canvas.recorder' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298458 ;\n        \nvar_global_main_1608956298458 = main;\n\n            var_init_locked_1608956298458 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298458(context) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.recorder"
  },
  "src::browser.canvas.word.width": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.canvas.word.width(<canvas.Context> context , <string> text)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(context , text){\n\n        \n/**\n * \n * 获得文本的宽度\n * \n * @param {canvas.Context} context 画板的上下文对象\n * \n * @param {string} text 文本\n * \n */\n\nlet {\n    width\n} = context.measureText(text) ;\n\nreturn width ;\n\n    }\n    \n                    return function(context , text){\n    \n                        \n    \n                        return main.call(this , context , text) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.canvas.word.width"
  },
  "src::browser.element.class.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.element.class.add(<HTMLElement> el , <mixed> cls)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.array",
      "src::browser.element.class.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isArray,add;\n    \n                    let var_init_locked_1608956298462;\n    \n                    \n\n                    function main(el , cls){\n\n        \n/**\n * \n * 添加样式类 \n * \n * @import is.string\n * \n * @import is.array\n * \n * @import add from .add\n * \n * @param {HTMLElement} el 添加样式类的元素\n * \n * @param {mixed} cls 样式类\n * \n */\n\nif(isString(cls)){\n\n    el.classList.add(cls) ;\n\n}else if(isArray(cls)){\n\n    for(let item of cls){\n\n        add(el , item) ;\n    }\n}\n\n    }\n    \n                    return function(el , cls){\n    \n                        \n        if(!var_init_locked_1608956298462){\n\n            isString = include('src::is.string');\nisArray = include('src::is.array');\nadd = include('src::browser.element.class.add');\n\n            var_init_locked_1608956298462 = true ;\n        }\n        \n    \n                        return main.call(this , el , cls) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.element.class.add"
  },
  "src::browser.element.class.has": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::browser.element.class.has(<HTMLElement> el , <string> cls)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el , cls){\n\n        \n/**\n * \n * 判断指定元素是否拥有指定样式类\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} cls 样式类\n * \n * @return {boolean} 如果元素拥有对应样式类则返回 true , 否则返回 false \n * \n */\n\n return el.classList.contains(cls) ;\n\n    }\n    \n                    return function(el , cls){\n    \n                        \n    \n                        return main.call(this , el , cls) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.element.class.has"
  },
  "src::browser.element.class.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.element.class.remove(<HTMLElement> el , <mixed> cls)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.array",
      "src::browser.element.class.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isArray,remove;\n    \n                    let var_init_locked_1608956298468;\n    \n                    \n\n                    function main(el , cls){\n\n        \n/**\n * \n * 移除样式类 \n * \n * @import is.string\n * \n * @import is.array\n * \n * @import remove from .remove\n * \n * @param {HTMLElement} el 移除样式类的元素\n * \n * @param {mixed} cls 样式类\n * \n */\n\nif(isString(cls)){\n\n    el.classList.remove(cls) ;\n\n}else if(isArray(cls)){\n\n    for(let item of cls){\n\n        remove(el , item) ;\n    }\n}\n\n    }\n    \n                    return function(el , cls){\n    \n                        \n        if(!var_init_locked_1608956298468){\n\n            isString = include('src::is.string');\nisArray = include('src::is.array');\nremove = include('src::browser.element.class.remove');\n\n            var_init_locked_1608956298468 = true ;\n        }\n        \n    \n                        return main.call(this , el , cls) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.element.class.remove"
  },
  "src::browser.element.style": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.element.style(<HTMLElement> el , <string|array> name , <boolean> isNumber)",
    "standard": true,
    "importNames": [
      "src::is.array",
      "src::browser.element.style"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isArray,get;\n    \n                    let var_init_locked_1608956298470;\n    \n                    \n\n                    function main(el , name , isNumber){\n\n        \n/**\n * \n * 获得元素的样式\n * \n * @import is.array\n * \n * @import get from .style\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string|array} name 样式名称\n * \n * @param {boolean} [isNumber = false] 是否输出为数字 \n * \n * @return {mixed} 样式值 \n * \n */\n\n if(isArray(name)){\n\n    let names = name,\n        result = {};\n\n    for(let name of names){\n\n        result[name] = get(el , name , isNumber) ;\n    }\n\n    return result ;\n }\n\n let value = getComputedStyle(el , null)[name] ;\n\n if(isNumber){\n\n    return parseFloat(value) ;\n }\n\n return value ;\n\n    }\n    \n                    return function(el , name , isNumber = false){\n    \n                        \n        if(!var_init_locked_1608956298470){\n\n            isArray = include('src::is.array');\nget = include('src::browser.element.style');\n\n            var_init_locked_1608956298470 = true ;\n        }\n        \n    \n                        return main.call(this , el , name , isNumber) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.element.style"
  },
  "src::browser.element.xy": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.element.xy(<HTMLElement> el)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 获得元素的坐标\n * \n * @param {HTMLElement} el 元素\n * \n * @return {object} 坐标信息\n * \n */\n\n const {\n    round\n } = Math ;\n\nlet x = 0,\n    y = 0;\n\nif(el !== document && el !== document.body){\n\n    let {\n        left:bodyLeft,\n        top:bodyTop\n    } = document.body.getBoundingClientRect(),\n    {\n        left,\n        top\n    } = el.getBoundingClientRect();\n\n    x = left - bodyLeft,\n    y = top - bodyTop;\n}\n\nreturn {\n    x:round(x),\n    y:round(y)\n} ;\n\n    }\n    \n                    return function(el){\n    \n                        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.element.xy"
  },
  "src::browser.event.dispatch": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.dispatch(<HTMLElement> el , <string> name , <mixed> detail)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el , name , detail){\n\n        \n/**\n * \n * 触发一个自定义事件\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} name 自定义事件名称\n * \n * @param {mixed} detail 基于自定义事件传递的数据\n * \n */\n\nel.dispatchEvent(new CustomEvent(name , {\n   detail,\n   bubbles:false,\n   cancelable:false\n})) ;\n\n\n    }\n    \n                    return function(el , name , detail){\n    \n                        \n    \n                        return main.call(this , el , name , detail) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.dispatch"
  },
  "src::browser.event.gesture.contextmenu.contextmenu": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.contextmenu.contextmenu(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.prevent"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let prevent;\n    \n                    let var_init_locked_1608956298476;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 阻止默认右击菜单事件\n * \n * @import prevent from browser.event.prevent\n * \n * @param {Event} e 事件对象\n * \n */\n\nprevent(e) ;\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298476){\n\n            prevent = include('src::browser.event.prevent');\n\n            var_init_locked_1608956298476 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.contextmenu.contextmenu"
  },
  "src::browser.event.prevent": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.prevent(<Event> e)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 禁用默认事件\n * \n * @param {Event} e 事件对象\n * \n */\n\n e.preventDefault() ;\n\n    }\n    \n                    return function(e){\n    \n                        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.prevent"
  },
  "src::browser.event.gesture.contextmenu.event": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::browser.event.gesture.contextmenu.event()",
    "standard": true,
    "importNames": [
      "src::function.bind",
      "src::browser.event.gesture.longpress",
      "src::browser.event.gesture.contextmenu.contextmenu"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let bind,longpress,contextmenu;\n    \n                    let var_init_locked_1608956298480;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 右键事件配置\n * \n * @import bind from function.bind\n * \n * @import longpress from ..longpress\n * \n * @import contextmenu from .contextmenu\n *\n * @return {array} 事件配置  \n * \n */\n\n return [\n    'mouseup',\n    {\n        event:'contextmenu',\n        listener:contextmenu\n    },\n    {\n        event:'touchstart',\n        listener:bind(longpress , this , [\n            'contextmenu'\n        ])\n    }\n] ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298480){\n\n            bind = include('src::function.bind');\nlongpress = include('src::browser.event.gesture.longpress');\ncontextmenu = include('src::browser.event.gesture.contextmenu.contextmenu');\n\n            var_init_locked_1608956298480 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.contextmenu.event"
  },
  "src::function.bind": {
    "meta": "code.meta.script.function",
    "signature": "<function> src::function.bind(<function> fn , <mixed> scope , <mixed[]> args , <mixed> appendArgs)",
    "standard": true,
    "importNames": [
      "src::array.clone",
      "src::array.insert",
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let clone,insert,isNumber;\n    \n                    let var_init_locked_1608956298482;\n    \n                    \n\n                    function main(fn , scope , args , appendArgs){\n\n        \n/**\n * \n * 函数绑定作用域\n * \n * @import clone from array.clone\n * \n * @import insert from array.insert\n * \n * @import is.number\n * \n * @param {function} fn 函数\n * \n * @param {mixed} [scope] 作用域\n * \n * @param {mixed[]} [args] 函数参数\n * \n * @param {mixed} [appendArgs = true] 附加参数位置\n * \n * @return {function} 绑定作用域的函数\n * \n */\n\nif(arguments.length <= 2 ){\n\n    return fn.bind(scope) ;\n\n}\n\nreturn function() {\n\n    let callArgs = args || arguments;\n\n    if(appendArgs === true){\n\n        callArgs = [\n            ...arguments,\n            ...(args || [])\n        ];\n        \n    }else if (isNumber(appendArgs)){\n\n        callArgs = clone(arguments);\n        \n        insert(callArgs , appendArgs, args);\n    }\n\n    return fn.apply(scope || this, callArgs);\n};\n\n    }\n    \n                    return function(fn , scope , args , appendArgs = true){\n    \n                        \n        if(!var_init_locked_1608956298482){\n\n            clone = include('src::array.clone');\ninsert = include('src::array.insert');\nisNumber = include('src::is.number');\n\n            var_init_locked_1608956298482 = true ;\n        }\n        \n    \n                        return main.call(this , fn , scope , args , appendArgs) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "function.bind"
  },
  "src::browser.event.listeners": {
    "meta": "code.meta.script.function",
    "signature": "<Map> src::browser.event.listeners()",
    "standard": true,
    "importNames": [
      "src::map"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let map;\n    \n                    let var_init_locked_1608956298497;\n    \n                    let var_once_value_1608956298497;\n\n                    function main(){\n\n        \n/**\n * \n * 维护全局事件监听对象\n * \n * @import map value\n * \n * @return {Map} 集合对象 \n * \n * @once\n * \n */\n\nreturn map ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298497){\n\n            map = include('src::map')();\n\n            var_init_locked_1608956298497 = true ;\n        }\n        \n    \n                        \n        if(var_once_value_1608956298497){\n\n            return var_once_value_1608956298497 ;\n\n        }\n        return var_once_value_1608956298497 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.listeners"
  },
  "src::browser.selector.is": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::browser.selector.is(<HTMLElement> el , <string> selector)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el , selector){\n\n        \n/**\n * \n * 判断元素是否匹配选择器\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} selector 选择器字符串\n * \n * @return {boolean} 如果元素匹配选择器则返回 true , 否则返回 false \n * \n */\n\n let {\n    ownerDocument\n } = el ;\n\n let els = Array.from(ownerDocument.querySelectorAll(selector)) ;\n\n return els.includes(el) ;\n\n    }\n    \n                    return function(el , selector){\n    \n                        \n    \n                        return main.call(this , el , selector) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.selector.is"
  },
  "src::browser.selector.parent": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::browser.selector.parent(<HTMLElement> el , <string> selector)",
    "standard": true,
    "importNames": [
      "src::browser.selector.is"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956298499;\n    \n                    \n\n                    function main(el , selector){\n\n        \n/**\n * \n * 判断元素及其元素父祖级元素是否匹配选择器\n * \n * @import is from .is\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} selector 选择器\n * \n * @return {boolean} 如果匹配则返回 true , 否则返回 false \n * \n */\n\n while(el){\n\n    if(is(el , selector)){\n\n        return el ;\n    }\n\n    el = el.parentElement ;\n }\n\n    }\n    \n                    return function(el , selector){\n    \n                        \n        if(!var_init_locked_1608956298499){\n\n            is = include('src::browser.selector.is');\n\n            var_init_locked_1608956298499 = true ;\n        }\n        \n    \n                        return main.call(this , el , selector) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.selector.parent"
  },
  "src::browser.event.stop": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.stop(<Event> e)",
    "standard": true,
    "importNames": [
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject;\n    \n                    let var_init_locked_1608956298503;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 停止事件\n * \n * @import isObject from is.object.simple\n * \n * @param {Event} e 事件对象\n * \n */\n\ne.stopPropagation() ;\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298503){\n\n            isObject = include('src::is.object.simple');\n\n            var_init_locked_1608956298503 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.stop"
  },
  "src::browser.event.listener.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.listener.add(<mixed> target , <mixed> event , <mixed> fn , <object> config)",
    "standard": true,
    "importNames": [
      "src::browser.event.listeners",
      "src::browser.selector.parent",
      "src::browser.event.stop",
      "src::browser.event.prevent",
      "src::event.listener.add",
      "src::is.object.simple",
      "src::function.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let listeners,is,stopEvent,preventEvent,doAdd,isObject,get;\n    \n                    let var_init_locked_1608956298494;\n    \n                    \n\n                    \n/**\n * \n * 监听事件\n * \n * @import listeners from ..listeners value\n * \n * @import is from browser.selector.parent\n * \n * @import stopEvent from ..stop\n * \n * @import preventEvent from ..prevent\n * \n * @import doAdd from event.listener.add\n * \n * @import isObject from is.object.simple\n * \n * @import get from function.get\n * \n * @param {mixed} target 目标\n * \n * @param {mixed} event 目标监听事件\n * \n * @param {mixed} [fn] 目标监听回调\n * \n * @param {object} [config = {}] 配置\n * \n */\n\n function main(target , event , fn , config){\n\n    if(isObject(event)){\n\n        let {\n            scope,\n            ...listeners\n        } = event ;\n\n        let names = Object.keys(listeners) ;\n\n        for(let name of names){\n\n            let listener = listeners[name] ;\n\n            if(isObject(listener)){\n\n                let {\n                    fn,\n                    ...options\n                } = listener ;\n    \n                options.scope = options.scope || scope ;\n    \n                add(target , name , fn , options) ;\n            \n            }else{\n\n                add(target , name , listeners[name] , {\n                    scope\n                }) ;\n            }\n        }\n        \n    }else{\n\n        add(target , event , fn , config) ;\n    }\n\n }\n\n function add(target , event , fn , {\n     selector,\n     stop = false,\n     prevent = false,\n     scope,\n     ...config\n }){\n\n    if(listeners.has(target , event , fn , scope)){\n\n        return ;\n    }\n\n    let useFn = get(fn , scope),\n        listener = e =>{\n    \n            let {\n                target\n            } = e ;\n    \n            if(stop){\n                \n                stopEvent(e) ;\n            }\n    \n            if(prevent){\n    \n                preventEvent(e) ;\n            }\n    \n            if(selector){\n    \n                if(is(target , selector)){\n    \n                    useFn(e) ;\n                }\n                \n            }else{\n    \n                useFn(e) ;\n            }\n        };\n    \n    listeners.set(target , event , fn , scope , listener) ;\n    \n    doAdd(target , event , listener , {\n        options:{\n            passive:false\n        },\n        ...config\n    }) ;\n }\n\n\n    \n                    return function(target , event , fn , config = {}){\n    \n                        \n        if(!var_init_locked_1608956298494){\n\n            listeners = include('src::browser.event.listeners')();\nis = include('src::browser.selector.parent');\nstopEvent = include('src::browser.event.stop');\npreventEvent = include('src::browser.event.prevent');\ndoAdd = include('src::event.listener.add');\nisObject = include('src::is.object.simple');\nget = include('src::function.get');\n\n            var_init_locked_1608956298494 = true ;\n        }\n        \n    \n                        return main.call(this , target , event , fn , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.listener.add"
  },
  "src::browser.event.listener.global.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.listener.global.add(<string> event , <function> fn , <object> config)",
    "standard": true,
    "importNames": [
      "src::browser.event.listener.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let add;\n    \n                    let var_init_locked_1608956298490;\n    \n                    \n\n                    function main(event , fn , config){\n\n        \n/**\n * \n * 监听全局事件\n * \n * @import add from ..add\n * \n * @param {string} event 目标监听事件\n * \n * @param {function} fn 目标监听回调\n * \n * @param {object} [config] 配置\n * \n * \n */\n\n add(window , event , fn , config) ;\n\n    }\n    \n                    return function(event , fn , config){\n    \n                        \n        if(!var_init_locked_1608956298490){\n\n            add = include('src::browser.event.listener.add');\n\n            var_init_locked_1608956298490 = true ;\n        }\n        \n    \n                        return main.call(this , event , fn , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.listener.global.add"
  },
  "src::browser.event.name.single": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.event.name.single(<string> name , <PointerEvent> e)",
    "standard": true,
    "importNames": [
      "src::is.browser.support.pointer",
      "src::is.browser.support.touch"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isSupportPointer,isSupportTouch;\n    \n                    let var_init_locked_1608956298505;\n    \n                    \n\n                    function main(name , e){\n\n        \n/**\n * \n * 获取事件名称\n * \n * @import isSupportPointer from is.browser.support.pointer\n * \n * @import isSupportTouch from is.browser.support.touch\n * \n * @param {string} name 事件名称\n * \n * @param {PointerEvent} [e] 事件对象\n * \n * @return {mixed} 返回说明 \n * \n */\n\n let isTouch = isSupportTouch() ;\n\n if(e){\n\n    let {\n        pointerType,\n        touches\n    } = e;\n    \n    if(pointerType === 'touch' || touches){\n\n        isTouch = true ;\n    }\n }\n\nif(isTouch){\n\n    return `touch${name}` ;\n\n}else{\n\n    switch(name){\n\n        case 'start':\n    \n            name = 'down' ;\n    \n            break ;\n    \n        case 'end':\n    \n            name = 'up' ;\n    }\n    \n    if(isSupportPointer()){\n\n        return `pointer${name}` ;\n    }\n    \n    return `mouse${name}` ;\n}\n\n\n\n    }\n    \n                    return function(name , e){\n    \n                        \n        if(!var_init_locked_1608956298505){\n\n            isSupportPointer = include('src::is.browser.support.pointer');\nisSupportTouch = include('src::is.browser.support.touch');\n\n            var_init_locked_1608956298505 = true ;\n        }\n        \n    \n                        return main.call(this , name , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.name.single"
  },
  "src::browser.event.single": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.event.single(<Event> e , <string> name)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(e , name){\n\n        \n/**\n * \n * 获得单一的事件对象\n * \n * @param {Event} e 事件对象\n * \n * @param {string} name 事件名称\n *  \n * @return {mixed} 事件对象 \n * \n */\n\n let touches ;\n\n switch(name){\n\n    case 'start':\n    case 'move':\n\n        touches = e.touches ;\n\n        break ;\n\n    case 'end':\n\n        touches = e.changedTouches ;\n }\n\n if(touches){\n\n    return touches[0] ;\n }\n\n return e ;\n\n    }\n    \n                    return function(e , name){\n    \n                        \n    \n                        return main.call(this , e , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.single"
  },
  "src::browser.event.listener.remove": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.event.listener.remove(<mixed> target , <mixed> event , <mixed> fn , <object> scope)",
    "standard": true,
    "importNames": [
      "src::browser.event.listeners",
      "src::event.listener.remove",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let listeners,doRemove,isObject;\n    \n                    let var_init_locked_1608956298519;\n    \n                    \n\n                    \n/**\n * \n * 去除监听事件\n * \n * @import listeners from ..listeners value\n * \n * @import doRemove from event.listener.remove\n * \n * @import isObject from is.object.simple\n * \n * @param {mixed} target\n * \n * @param {mixed} event 目标监听事件\n * \n * @param {mixed} fn 目标监听回调\n * \n * @param {object} [scope] 作用域\n * \n * @return {mixed} 返回说明 \n * \n */\n\n function main(target , event , fn , scope){\n\n    if(isObject(event)){\n\n        let names = Object.keys(event) ;\n\n        for(let name of names){\n\n            if(name !== 'scope'){\n\n                let fn,\n                    listener = event[name];\n\n                if(isObject(listener)){\n\n                    fn = listener.fn ;\n\n                    scope = scope || listener.scope ;\n                \n                }else{\n\n                    fn = listener ;\n                }\n\n                remove(target , name , fn , scope) ;\n            }\n        }\n    \n    }else{\n\n        remove(target , event , fn , scope) ;\n    }\n }\n\n function remove(target , event , fn , scope){\n\n    let listener = listeners.get(target , event , fn , scope);\n\n    if(listener){\n\n        doRemove(target , event , listener) ;\n\n        listeners.delete(target , event , fn , scope) ;\n    }\n }\n    \n                    return function(target , event , fn , scope){\n    \n                        \n        if(!var_init_locked_1608956298519){\n\n            listeners = include('src::browser.event.listeners')();\ndoRemove = include('src::event.listener.remove');\nisObject = include('src::is.object.simple');\n\n            var_init_locked_1608956298519 = true ;\n        }\n        \n    \n                        return main.call(this , target , event , fn , scope) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.listener.remove"
  },
  "src::browser.event.listener.global.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.listener.global.remove(<string> event , <function> fn)",
    "standard": true,
    "importNames": [
      "src::browser.event.listener.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let remove;\n    \n                    let var_init_locked_1608956298517;\n    \n                    \n\n                    function main(event , fn){\n\n        \n/**\n * \n * 去除监听全局事件\n * \n * @import remove from ..remove\n * \n * @param {string} event 目标监听事件\n * \n * @param {function} fn 目标监听回调\n * \n * \n */\n\nremove(window , event , fn) ;\n\n    }\n    \n                    return function(event , fn){\n    \n                        \n        if(!var_init_locked_1608956298517){\n\n            remove = include('src::browser.event.listener.remove');\n\n            var_init_locked_1608956298517 = true ;\n        }\n        \n    \n                        return main.call(this , event , fn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.listener.global.remove"
  },
  "src::browser.event.gesture.longpress.disabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.longpress.disabled(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.listener.global.remove",
      "src::browser.event.name.single"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let un,getName;\n    \n                    let var_init_locked_1608956298515;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 取消监听全局事件\n * \n * @import un from browser.event.listener.global.remove\n * \n * @import getName from browser.event.name.single\n * \n * @param {Event} e 事件对象\n * \n */\n\nlet me = this,\n{\n   onEnd,\n   onMove,\n   timer\n} = me;\n\nif(timer){\n\n    clearTimeout(timer) ;\n}\n\nun(getName('move' , e) , onMove) ;\n\nun(getName('end' , e) ,  onEnd) ;\n\ndelete me.onMove ;\n\ndelete me.onEnd ;\n\ndelete me.timer ;\n\ndelete me.startPoint ;\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298515){\n\n            un = include('src::browser.event.listener.global.remove');\ngetName = include('src::browser.event.name.single');\n\n            var_init_locked_1608956298515 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.longpress.disabled"
  },
  "src::browser.event.gesture.longpress.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.longpress.end(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.gesture.longpress.disabled"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956298512 = new Map();\n    \n                    return function(e){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956298512.has(this)){\n\n            var_current_scope_1608956298512.set(this , (() => {\n                const disabled = include('src::browser.event.gesture.longpress.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * @import disabled from .disabled scoped\n * \n * @param {Event} e 事件对象\n * \n */\n\ndisabled(e) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298512.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.longpress.end"
  },
  "src::browser.event.touches": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.event.touches(<Event> e , <string> name)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(e , name){\n\n        \n/**\n * \n * 如果当前设备处于多点触控时返回，其它时候返回空\n * \n * @param {Event} e 事件对象\n * \n * @param {string} name 事件名称\n * \n * @return {mixed} 触摸事件集合\n * \n */\n\nlet touches ;\n\nswitch(name){\n\n   case 'start':\n   case 'move':\n\n       touches = e.touches ;\n\n       break ;\n\n   case 'end':\n\n       touches = e.changedTouches ;\n}\n\nif(touches && touches.length > 1){\n\n    return touches ;\n}\n\n    }\n    \n                    return function(e , name){\n    \n                        \n    \n                        return main.call(this , e , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.touches"
  },
  "src::math.point.line.distance": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.point.line.distance(<object> point1 , <object> point2)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(point1 , point2){\n\n        /**\n * \n * 计算两点之间的距离\n * \n * @param {object} point1 第一个点的位置\n * \n * @param {object} point2 第二个点的位置\n * \n * @return {number} 两点之间的距离\n * \n */\n\nconst {\n    pow,\n    sqrt\n} = Math ;\n\nreturn sqrt(pow(point1.x - point2.x , 2) + pow(point1.y - point2.y , 2) , 2);\n\n    }\n    \n                    return function(point1 , point2){\n    \n                        \n    \n                        return main.call(this , point1 , point2) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.point.line.distance"
  },
  "config::event.longpress": {
    "meta": "code.meta.config",
    "signature": "<void> config::event.longpress(<string> key)",
    "standard": true,
    "importNames": [
      "src::object.value.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956298530;\n    \n                    \n\n                    const config = {\n    \"minDuration\":600,\n    \"moveDistance\":30\n};\n                function main(key){\n\n                    return get(config , key) ;\n\n                }\n                \n    \n                    return function(key){\n    \n                        \n        if(!var_init_locked_1608956298530){\n\n            get = include('src::object.value.get');\n\n            var_init_locked_1608956298530 = true ;\n        }\n        \n    \n                        return main.call(this , key) ;\n                    } ;\n    \n                })()",
    "folder": "config",
    "name": "event.longpress"
  },
  "src::browser.event.gesture.longpress.move": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.longpress.move(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.touches",
      "src::browser.event.single",
      "src::math.point.line.distance",
      "src::browser.scale",
      "src::browser.event.gesture.longpress.disabled",
      "config::event.longpress"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getTouchEvents,getEvent,getDistance,getScale,moveDistance;\n    \n                    let var_init_locked_1608956298521;\n \n                    \n\n                    const var_current_scope_1608956298521 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298521){\n\n            getTouchEvents = include('src::browser.event.touches');\ngetEvent = include('src::browser.event.single');\ngetDistance = include('src::math.point.line.distance');\ngetScale = include('src::browser.scale');\nmoveDistance = config('event.longpress' , 'moveDistance');\n\n            var_init_locked_1608956298521 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298521.has(this)){\n\n            var_current_scope_1608956298521.set(this , (() => {\n                const disabled = include('src::browser.event.gesture.longpress.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 移动事件监听\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import getEvent from browser.event.single\n * \n * @import getDistance from math.point.line.distance\n * \n * @import getScale from browser.scale\n * \n * @import disabled from .disabled scoped\n * \n * @config moveDistance from event.longpress...moveDistance\n * \n * @param {Event} e 事件对象\n * \n */\n\nif(getTouchEvents(e , 'move')){\n\n    disabled(e) ;\n\n    return ;\n}\n\nlet me = this,\n    {\n        pageX,\n        pageY\n    } = getEvent(e , 'move'),\n    {\n        startPoint,\n        dispatch\n    } = me;\n\nif(Math.round(getDistance({\n    x:pageX,\n    y:pageY\n} , startPoint)) * getScale() >= moveDistance){\n\n    disabled(e) ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298521.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.longpress.move"
  },
  "src::browser.event.gesture.longpress.enabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.longpress.enabled(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single",
      "src::browser.event.listener.global.add",
      "src::browser.event.gesture.longpress.end",
      "src::browser.event.gesture.longpress.move"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName,on;\n    \n                    let var_init_locked_1608956298510;\n \n                    \n\n                    const var_current_scope_1608956298510 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298510){\n\n            getName = include('src::browser.event.name.single');\non = include('src::browser.event.listener.global.add');\n\n            var_init_locked_1608956298510 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298510.has(this)){\n\n            var_current_scope_1608956298510.set(this , (() => {\n                const onEnd = include('src::browser.event.gesture.longpress.end').bind(this);\nconst onMove = include('src::browser.event.gesture.longpress.move').bind(this);\n\n                function main(e){\n\n        /**\n * \n * 启用事件\n * \n * @import getName from browser.event.name.single\n * \n * @import on from browser.event.listener.global.add\n * \n * @import onEnd from .end scoped\n * \n * @import onMove from .move scoped\n * \n * @param {Event} e 事件对象\n * \n */\n\n let me = this ;\n \n on(getName('move' , e) , me.onMove = onMove) ;\n\n on(getName('end' , e) , me.onEnd = onEnd) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298510.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.longpress.enabled"
  },
  "src::browser.event.gesture.longpress.event": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::browser.event.gesture.longpress.event()",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956298532;\n    \n                    \n\n                    function main(){\n\n        /**\n * \n * 获得启动监听事件名称\n * \n * @import getName from browser.event.name.single\n * \n * @return {string}\n * \n */\n\nreturn getName('start') ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298532){\n\n            getName = include('src::browser.event.name.single');\n\n            var_init_locked_1608956298532 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.longpress.event"
  },
  "src::browser.event.gesture.longpress": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.longpress(<Event> e , <string> event)",
    "standard": true,
    "importNames": [
      "src::browser.event.listener.global.add",
      "src::browser.event.name.single",
      "src::browser.event.single",
      "src::browser.event.gesture.longpress.enabled",
      "src::browser.event.gesture.longpress.disabled",
      "src::browser.event.gesture.longpress.event",
      "config::event.longpress"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let on,getName,getEvent,browserEventGestureLongpressEvent,minDuration;\n    \n                    let var_init_locked_1608956298485;\n \n                    \n\n                    const var_current_scope_1608956298485 = new Map();\n    \n                    return function(e , event = 'longpress'){\n    \n                        \n        if(!var_init_locked_1608956298485){\n\n            on = include('src::browser.event.listener.global.add');\ngetName = include('src::browser.event.name.single');\ngetEvent = include('src::browser.event.single');\nbrowserEventGestureLongpressEvent = include('src::browser.event.gesture.longpress.event');\nminDuration = config('event.longpress' , 'minDuration');\n\n            var_init_locked_1608956298485 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298485.has(this)){\n\n            var_current_scope_1608956298485.set(this , (() => {\n                const enabled = include('src::browser.event.gesture.longpress.enabled').bind(this);\nconst disabled = include('src::browser.event.gesture.longpress.disabled').bind(this);\n\n                function main(e , event){\n\n        \n/**\n * \n * 开始事件监听\n * \n * @import on from browser.event.listener.global.add\n * \n * @import getName from browser.event.name.single\n * \n * @import getEvent from browser.event.single\n * \n * @import enabled from .longpress.enabled scoped\n * \n * @import disabled from .longpress.disabled scoped\n * \n * @import .longpress.event\n * \n * @config minDuration from event.longpress...minDuration\n *\n * @param {Event} e 事件对象\n * \n * @param {string} [event = 'longpress'] 抛出的事件名称\n * \n */\n\nlet me = this ;\n\nif(me.startPoint){\n\n   return ;\n\n}\n\nlet nativeEvent = getEvent(e , 'start'),\n    {\n        pageX:x,\n        pageY:y\n    } = nativeEvent;\n\n me.startPoint = {\n    x,\n    y\n } ;\n\nme.timer = setTimeout(() => {\n\n    me.dispatch(event , {\n        nativeEvent\n    }) ;\n\n    disabled(e) ;\n\n    if(event === 'longpress'){\n\n        on(getName('end' , e) , e =>  me.dispatch('longpresscancel' , {\n            nativeEvent:getEvent(e , 'end')\n        }) , {\n            once:true\n        }) ;\n    }\n\n } , minDuration);\n\nenabled(e) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298485.get(this) ;\n\n        \n    \n                        return main.call(this , e , event) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.longpress"
  },
  "src::browser.event.gesture.contextmenu": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.contextmenu(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.gesture.contextmenu.event"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let browserEventGestureContextmenuEvent;\n    \n                    let var_init_locked_1608956298534;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 开始事件监听\n * \n * @import .contextmenu.event\n *\n * @param {Event} e 事件对象\n * \n */\n\nlet {\n    button\n} = e ;\n\nif(e.button === 2){\n\n    this.dispatch('contextmenu' , {\n        nativeEvent:e\n    }) ;\n    \n}\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298534){\n\n            browserEventGestureContextmenuEvent = include('src::browser.event.gesture.contextmenu.event');\n\n            var_init_locked_1608956298534 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.contextmenu"
  },
  "src::browser.event.gesture.drag.disabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag.disabled(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single",
      "src::browser.event.listener.global.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName,un;\n    \n                    let var_init_locked_1613441962645;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 禁用监听全局事件\n * \n * @import getName from browser.event.name.single\n * \n * @import un from browser.event.listener.global.remove\n * \n * @param {Event} e 事件对象\n * \n */\n\nlet me = this,\n{\n    onStart,\n    onMove,\n    onEnd\n} = me;\n\nun(getName('move' , e) , onStart) ;\n\nun(getName('move' , e) ,  onMove) ;\n\nun(getName('end' , e) , onEnd) ;\n\ndelete me.onStart ;\n\ndelete me.onMove ;\n\ndelete me.onEnd ;\n\ndelete me.info ;\n\ndelete me.startTime ;\n\ndelete me.startPoint ;\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1613441962645){\n\n            getName = include('src::browser.event.name.single');\nun = include('src::browser.event.listener.global.remove');\n\n            var_init_locked_1613441962645 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.disabled"
  },
  "src::browser.event.gesture.drag.enabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag.enabled(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single",
      "src::browser.event.gesture.drag.move.drag",
      "src::browser.event.gesture.drag.end",
      "src::browser.event.listener.global.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName,on;\n    \n                    let var_init_locked_1608956298549;\n \n                    \n\n                    const var_current_scope_1608956298549 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298549){\n\n            getName = include('src::browser.event.name.single');\non = include('src::browser.event.listener.global.add');\n\n            var_init_locked_1608956298549 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298549.has(this)){\n\n            var_current_scope_1608956298549.set(this , (() => {\n                const onMove = include('src::browser.event.gesture.drag.move.drag').bind(this);\nconst onEnd = include('src::browser.event.gesture.drag.end').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 启用监听全局事件\n * \n * @import getName from browser.event.name.single\n * \n * @import onMove from .move.drag scoped\n * \n * @import onEnd from .end scoped\n * \n * @import on from browser.event.listener.global.add\n * \n * @param {Event} e 事件对象\n * \n */\n\nlet me = this ;\n\non(getName('move' , e) ,  me.onMove = onMove) ;\n\non(getName('end' , e) , me.onEnd = onEnd) ;\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298549.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.enabled"
  },
  "src::browser.event.gesture.drag.info.update": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag.info.update(<string> axis , <boolean> updatePrevious)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(axis , updatePrevious){\n\n        \n/**\n * \n * 刷新拖放信息\n * \n * @param {string} axis 轴名称\n * \n * @param {boolean} updatePrevious 是否更新上一次信息\n * \n */\n\n let {\n    info,\n    startPoint,\n    previousPoint,\n    lastPoint,\n    startTime\n } = this ;\n\n \nlet time = Date.now(),\n    value = lastPoint[axis],\n    previousValue = previousPoint[axis],\n    startValue = startPoint[axis],\n    delta = value - startValue,\n    direction = info.direction,\n    capAxis = axis.toUpperCase(),\n    previousFlick = info.previous[axis],\n    previousDelta;\n\n    previousDelta = info.delta[axis];\n    info.delta[axis] = delta;\n    info.absDelta[axis] = Math.abs(delta);\n\n    if (updatePrevious && value !== previousFlick && value !== info[axis] && time - info.previousTime[axis] >= 50) {\n\n        info.previous[axis] = info[axis];\n        \n        info.previousTime[axis] = info.time;\n    }\n\n    info[axis] = value;\n\n    if (value > previousValue) {\n\n        direction[axis] = 1;\n    }\n    else if (value < previousValue) {\n\n        direction[axis] = -1;\n    }\n\n    info['start' + capAxis] = startPoint[axis];\n    info['previous' + capAxis] = info.previous[axis];\n    info['page' + capAxis] = info[axis];\n    info['delta' + capAxis] = info.delta[axis];\n    info['absDelta' + capAxis] = info.absDelta[axis];\n    info['previousDelta' + capAxis] = previousDelta;\n    info.startTime = startTime;\n\n    }\n    \n                    return function(axis , updatePrevious){\n    \n                        \n    \n                        return main.call(this , axis , updatePrevious) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.info.update"
  },
  "src::browser.event.gesture.drag.move.drag": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag.move.drag(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.prevent",
      "src::browser.event.single",
      "src::browser.event.gesture.drag.info.update",
      "src::browser.event.touches",
      "src::browser.event.gesture.drag.disabled"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let prevent,getEvent,getTouchEvents;\n    \n                    let var_init_locked_1608956298553;\n \n                    \n\n                    const var_current_scope_1608956298553 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298553){\n\n            prevent = include('src::browser.event.prevent');\ngetEvent = include('src::browser.event.single');\ngetTouchEvents = include('src::browser.event.touches');\n\n            var_init_locked_1608956298553 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298553.has(this)){\n\n            var_current_scope_1608956298553.set(this , (() => {\n                const updateInfo = include('src::browser.event.gesture.drag.info.update').bind(this);\nconst disabled = include('src::browser.event.gesture.drag.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 拖动事件监听\n * \n * @import prevent from browser.event.prevent\n * \n * @import getEvent from browser.event.single\n * \n * @import updateInfo from ..info.update scoped\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import disabled from ..disabled scoped\n * \n * @param {Event} e 事件对象\n * \n */\n\nprevent(e) ;\n\nif(getTouchEvents(e ,'move')){\n\n    disabled(e) ;\n\n    return ;\n}\n\nlet me = this,\nnativeEvent = getEvent(e , 'move'),\n{\n    pageX:x,\n    pageY:y\n} = nativeEvent,\n{\n    lastPoint,\n    dispatch\n} = me;\n\nif(lastPoint){\n\n    me.previousPoint = lastPoint ;\n}\n\nme.lastPoint = {\n    x,\n    y\n} ;\n\nupdateInfo('x' , true);\n\nupdateInfo('y' , true);\n\nlet {\n    info\n} = me;\n\ninfo.time = Date.now();\n\ndispatch('drag' , {\n    info,\n    nativeEvent\n}) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298553.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.move.drag"
  },
  "src::browser.event.gesture.drag.end.axis": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag.end.axis(<string> axis , <object> info)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(axis , info){\n\n        \n/**\n * \n * 计算拖放速度\n * \n * @param {string} axis 轴信息\n * \n * @param {object} info 拖放信息\n * \n */\n\nlet duration = info.time - info.previousTime[axis];\n\nif (duration > 0) {\n\n    info.flick.velocity[axis] = (info[axis] - info.previous[axis]) / duration;\n}\n\n    }\n    \n                    return function(axis , info){\n    \n                        \n    \n                        return main.call(this , axis , info) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.end.axis"
  },
  "src::browser.event.gesture.drag.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag.end(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.prevent",
      "src::browser.event.single",
      "src::browser.event.gesture.drag.info.update",
      "src::browser.event.gesture.drag.end.axis",
      "src::browser.event.gesture.drag.disabled"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let prevent,getEvent;\n    \n                    let var_init_locked_1608956298540;\n \n                    \n\n                    const var_current_scope_1608956298540 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298540){\n\n            prevent = include('src::browser.event.prevent');\ngetEvent = include('src::browser.event.single');\n\n            var_init_locked_1608956298540 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298540.has(this)){\n\n            var_current_scope_1608956298540.set(this , (() => {\n                const updateInfo = include('src::browser.event.gesture.drag.info.update').bind(this);\nconst onAxisEnd = include('src::browser.event.gesture.drag.end.axis').bind(this);\nconst disabled = include('src::browser.event.gesture.drag.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 结束事件监听\n * \n * @import prevent from browser.event.prevent\n * \n * @import getEvent from browser.event.single\n * \n * @import updateInfo from .info.update scoped\n * \n * @import onAxisEnd from .end.axis scoped\n * \n * @import disabled from .disabled scoped\n * \n * @param {Event} e 事件对象\n * \n */\n\nprevent(e) ;\n\nlet me = this,\n{\n    info,\n    dispatch\n} = me,\n{\n    pageX:x,\n    pageY:y\n} = getEvent(e , 'end') ;\n\nme.lastPoint = {\n    x,\n    y\n} ;\n\nupdateInfo('x');\n\nupdateInfo('y');\n\ninfo.time = Date.now();\n\nonAxisEnd('x', info);\n\nonAxisEnd('y', info);\n\ndispatch('dragend', info);\n\ndisabled(e) ;\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298540.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.end"
  },
  "src::browser.event.gesture.drag.event": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::browser.event.gesture.drag.event()",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956298555;\n    \n                    \n\n                    function main(){\n\n        /**\n * \n * 获得启动监听事件名称\n * \n * @import getName from browser.event.name.single\n * \n * @return {string}\n * \n */\n\nreturn getName('start') ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298555){\n\n            getName = include('src::browser.event.name.single');\n\n            var_init_locked_1608956298555 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.event"
  },
  "src::browser.event.gesture.drag.info.reset": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag.info.reset(<string> axis)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(axis){\n\n        \n/**\n * \n * 刷新拖放信息\n * \n * @param {string} axis 轴名称\n * \n */\n\n let {\n    info,\n    startPoint,\n    lastPoint,\n    startTime\n } = this ;\n\nlet value = lastPoint[axis],\n    startValue = startPoint[axis],\n    delta = value - startValue,\n    capAxis = axis.toUpperCase();\n\ninfo.delta[axis] = delta;\ninfo.absDelta[axis] = Math.abs(delta);\n\ninfo.previousTime[axis] = startTime;\ninfo.previous[axis] = startValue;\ninfo[axis] = value;\ninfo.direction[axis] = 0;\n\ninfo['start' + capAxis] = startPoint[axis];\ninfo['previous' + capAxis] = info.previous[axis];\ninfo['page' + capAxis] = info[axis];\ninfo['delta' + capAxis] = info.delta[axis];\ninfo['absDelta' + capAxis] = info.absDelta[axis];\ninfo['previousDelta' + capAxis] = 0;\ninfo.startTime = startTime;\n\n    }\n    \n                    return function(axis){\n    \n                        \n    \n                        return main.call(this , axis) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.info.reset"
  },
  "src::browser.event.gesture.drag.move.start": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag.move.start(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.touches",
      "src::browser.event.prevent",
      "src::browser.event.single",
      "src::browser.event.name.single",
      "src::browser.event.gesture.drag.enabled",
      "src::browser.scale",
      "src::browser.event.gesture.drag.info.reset",
      "src::math.point.line.distance",
      "src::browser.event.listener.global.remove",
      "src::browser.event.gesture.drag.disabled",
      "config::event.drag"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getTouchEvents,prevent,getEvent,getName,scale,getDistance,un,minDistance;\n    \n                    let var_init_locked_1608956298561;\n \n                    \n\n                    const var_current_scope_1608956298561 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298561){\n\n            getTouchEvents = include('src::browser.event.touches');\nprevent = include('src::browser.event.prevent');\ngetEvent = include('src::browser.event.single');\ngetName = include('src::browser.event.name.single');\nscale = include('src::browser.scale');\ngetDistance = include('src::math.point.line.distance');\nun = include('src::browser.event.listener.global.remove');\nminDistance = config('event.drag' , 'minDistance');\n\n            var_init_locked_1608956298561 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298561.has(this)){\n\n            var_current_scope_1608956298561.set(this , (() => {\n                const enabled = include('src::browser.event.gesture.drag.enabled').bind(this);\nconst resetInfo = include('src::browser.event.gesture.drag.info.reset').bind(this);\nconst disabled = include('src::browser.event.gesture.drag.disabled').bind(this);\n\n                function main(e){\n\n        /**\n * \n * 检查是否启用拖曳事件\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import prevent from browser.event.prevent\n * \n * @import getEvent from browser.event.single\n * \n * @import getName from browser.event.name.single\n * \n * @import enabled from ..enabled scoped\n * \n * @import scale from browser.scale\n * \n * @import resetInfo from ..info.reset scoped\n * \n * @import getDistance from math.point.line.distance\n * \n * @import un from browser.event.listener.global.remove\n * \n * @import disabled from ..disabled scoped\n * \n * @config minDistance from event.drag...minDistance\n * \n * @param {Event} e 事件对象\n * \n */\n\n\nprevent(e) ;\n\nif(getTouchEvents(e , 'move')){\n\n    disabled(e) ;\n\n    return ;\n}\n\nlet me = this,\n{\n    pageX:x,\n    pageY:y\n} = getEvent(e , 'move'),\n{\n    startPoint,\n    info,\n    dispatch\n} = me,\npoint = {\n    x,\n    y\n};\n\nif (Math.round(getDistance(startPoint , point)) * scale() >= minDistance) {\n\n    me.previousPoint = point ;\n\n    me.lastPoint = point ;\n\n    resetInfo('x');\n    \n    resetInfo('y');\n\n    info.time = Date.now();\n\n    let {\n        dragStartNativeEvent\n    } = me ;\n\n    dispatch('dragstart', {\n        nativeEvent:dragStartNativeEvent,\n        info\n    });\n\n    delete me.dragStartNativeEvent ;\n\n    un(getName('move' , e) , me.onStart) ;\n\n    un(getName('end' , e) , me.onEnd) ;\n\n    enabled(e) ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298561.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag.move.start"
  },
  "config::event.drag": {
    "meta": "code.meta.config",
    "signature": "<void> config::event.drag(<string> key)",
    "standard": true,
    "importNames": [
      "src::object.value.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956298565;\n    \n                    \n\n                    const config = {\n    \"minDistance\":50\n};\n                function main(key){\n\n                    return get(config , key) ;\n\n                }\n                \n    \n                    return function(key){\n    \n                        \n        if(!var_init_locked_1608956298565){\n\n            get = include('src::object.value.get');\n\n            var_init_locked_1608956298565 = true ;\n        }\n        \n    \n                        return main.call(this , key) ;\n                    } ;\n    \n                })()",
    "folder": "config",
    "name": "event.drag"
  },
  "src::browser.event.gesture.drag": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.drag(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.single",
      "src::browser.event.gesture.drag.disabled",
      "src::browser.event.name.single",
      "src::browser.event.listener.global.add",
      "src::browser.event.gesture.drag.move.start",
      "src::browser.event.gesture.drag.event"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getEvent,getName,on,browserEventGestureDragEvent;\n    \n                    let var_init_locked_1608956298568;\n \n                    \n\n                    const var_current_scope_1608956298568 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298568){\n\n            getEvent = include('src::browser.event.single');\ngetName = include('src::browser.event.name.single');\non = include('src::browser.event.listener.global.add');\nbrowserEventGestureDragEvent = include('src::browser.event.gesture.drag.event');\n\n            var_init_locked_1608956298568 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298568.has(this)){\n\n            var_current_scope_1608956298568.set(this , (() => {\n                const disabled = include('src::browser.event.gesture.drag.disabled').bind(this);\nconst onStart = include('src::browser.event.gesture.drag.move.start').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 启动事件监听\n * \n * @import getEvent from browser.event.single\n * \n * @import disabled from .drag.disabled scoped\n * \n * @import getName from browser.event.name.single\n * \n * @import on from browser.event.listener.global.add\n * \n * @import onStart from .drag.move.start scoped\n * \n * @import .drag.event\n * \n * @param {Event} e 事件对象\n * \n */\n\n let me = this ;\n\nif(me.info){\n\n    return ;\n}\n\nlet {\n    pageX:x,\n    pageY:y,\n    pointerType\n} = getEvent(e , 'start');\n\nme.info = {\n    previous: {\n        x: 0,\n        y: 0\n    },\n    x: 0,\n    y: 0,\n    delta: {\n        x: 0,\n        y: 0\n    },\n    absDelta: {\n        x: 0,\n        y: 0\n    },\n    flick: {\n        velocity: {\n            x: 0,\n            y: 0\n        }\n    },\n    direction: {\n        x: 0,\n        y: 0\n    },\n    time: 0,\n    previousTime: {\n        x: 0,\n        y: 0\n    }\n} ;\n\nme.startTime = Date.now() ;\n\nme.startPoint = {\n    x,\n    y\n} ;\n\nme.dragStartNativeEvent = e ;\n\non(getName('move' , e) , me.onStart = onStart) ;\n\non(getName('end' , e) , me.onEnd = () => disabled(e) , {\n    once:true\n}) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298568.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.drag"
  },
  "src::browser.event.gesture.manager.dom": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.manager.dom()",
    "standard": true,
    "importNames": [
      "src::map",
      "src::browser.event.dispatch",
      "src::is.string",
      "src::is.object.simple",
      "src::is.array",
      "src::browser.event.listener.element.add",
      "src::browser.event.listener.element.remove",
      "config::event"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let createMap,doDispatch,isString,isObject,isArray,on,off,eventConfig;\n    \n                    let var_init_locked_1608956298575;\n    \n                    let var_class_1608956298575;\n    \n                    let var_once_value_1608956298575;\n\n                    let var_global_main_1608956298575 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298575){\n\n            createMap = include('src::map');\ndoDispatch = include('src::browser.event.dispatch');\nisString = include('src::is.string');\nisObject = include('src::is.object.simple');\nisArray = include('src::is.array');\non = include('src::browser.event.listener.element.add');\noff = include('src::browser.event.listener.element.remove');\neventConfig = config('event');\n\n            \n/**\n * \n * 传统事件管理\n * \n * @import createMap from map\n * \n * @import doDispatch from browser.event.dispatch\n * \n * @import is.string\n * \n * @import isObject from is.object.simple\n * \n * @import is.array\n * \n * @import on from ....listener.element.add\n * \n * @import off from ....listener.element.remove\n * \n * @config eventConfig from event\n * \n * @once\n * \n */\n\n function dispatch(event , params){\n\n    doDispatch(this , `gesture:${event}`  , params) ;\n }\n\n function getEvents(name){\n\n    let events = include(`browser.event.gesture.${name}.event`)() ;\n\n    if(isString(events)){\n\n        return [\n            events\n        ] ;\n    }\n\n    return events ;\n }\n\n function getName(name){\n\n    return eventConfig[name] ;\n }\n\n class main {\n\n    constructor(){\n\n        let me = this ;\n\n        me.events = createMap() ;\n\n    }\n\n    install(el , name , options = {}){\n\n        let {\n            events\n        } = this ;\n\n        name = getName(name);\n\n        if(events.has(el , name)){\n\n            return ;\n        }\n\n        let scope = {\n            dispatch:dispatch.bind(el)\n        },\n        gestureEvents = getEvents(name),\n        isAddMainListener = false,\n        listeners = [];\n\n        for(let event of gestureEvents){\n\n            if(isString(event) && !isAddMainListener){\n\n                let listener = include(`browser.event.gesture.${name}`).bind(scope) ;\n\n                listeners.push(listener) ;\n\n                on(el , event , listener , options) ;\n\n                isAddMainListener = true ;\n            \n            }else if(isObject(event)){\n\n                let {\n                    event:name,\n                    listener:fn\n                } = event,\n                listener = fn.bind(scope);\n\n                listeners.push(listener) ;\n\n                on(el , name , listener , options) ;\n            }\n        }\n\n        events.set(el , name , listeners) ;\n    }\n\n    uninstall(el , name){\n\n        name = getName(name);\n\n        let {\n            events\n        } = this,\n        listeners = events.get(el , name);\n\n        if(isArray(listeners)){\n\n            let gestureEvents = getEvents(name),\n                {\n                    length:len\n                } = gestureEvents;\n\n            for(let i = 0 ; i < len ; i ++){\n\n                let event = gestureEvents[i],\n                    listener = listeners[i];\n\n                if(isString(event)){\n\n                    off(el , event , listener) ;\n\n                }else if(isObject(event)){\n\n                    let {\n                        event:name\n                    } = event ;\n\n                    off(el , name , listener) ;\n                }\n            }\n\n            events.delete(el , name) ;\n        }\n\n        \n    }\n }\n\n            var_class_1608956298575 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298575 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::browser.event.gesture.manager.dom' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298575 ;\n        \nvar_global_main_1608956298575 = main;\n\n            var_init_locked_1608956298575 = true ;\n        }\n        \n    \n                        \n        if(var_once_value_1608956298575){\n\n            return var_once_value_1608956298575 ;\n\n        }\n        return var_once_value_1608956298575 = new var_global_main_1608956298575() ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.manager.dom"
  },
  "src::browser.event.listener.element.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.listener.element.add(<HTMLElement> el , <string> event , <function> fn , <object> config)",
    "standard": true,
    "importNames": [
      "src::browser.event.listener.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let add;\n    \n                    let var_init_locked_1608956298578;\n    \n                    \n\n                    function main(el , event , fn , config){\n\n        \n/**\n * \n * 监听元素事件\n * \n * @import add from ..add\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} event 目标监听事件\n * \n * @param {function} fn 目标监听回调\n * \n * @param {object} [config] 配置\n * \n */\n\n add(el , event , fn , config) ;\n\n    }\n    \n                    return function(el , event , fn , config){\n    \n                        \n        if(!var_init_locked_1608956298578){\n\n            add = include('src::browser.event.listener.add');\n\n            var_init_locked_1608956298578 = true ;\n        }\n        \n    \n                        return main.call(this , el , event , fn , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.listener.element.add"
  },
  "src::browser.event.listener.element.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.listener.element.remove(<HTMLElement> el , <string> event , <function> fn , <mixed> scope)",
    "standard": true,
    "importNames": [
      "src::browser.event.listener.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let remove;\n    \n                    let var_init_locked_1608956298580;\n    \n                    \n\n                    function main(el , event , fn , scope){\n\n        \n/**\n * \n * 去除监听元素事件\n * \n * @import remove from ..remove\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} event 目标监听事件\n * \n * @param {function} fn 目标监听回调\n * \n * @param {mixed} scope 作用域\n * \n * \n */\n\nremove(el , event , fn , scope) ;\n\n    }\n    \n                    return function(el , event , fn , scope){\n    \n                        \n        if(!var_init_locked_1608956298580){\n\n            remove = include('src::browser.event.listener.remove');\n\n            var_init_locked_1608956298580 = true ;\n        }\n        \n    \n                        return main.call(this , el , event , fn , scope) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.listener.element.remove"
  },
  "config::event": {
    "meta": "code.meta.config",
    "signature": "<void> config::event(<string> key)",
    "standard": true,
    "importNames": [
      "src::object.value.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956298582;\n    \n                    \n\n                    const config = {\n    \"tap\":\"tap\",\n    \"dragstart\":\"drag\",\n    \"drag\":\"drag\",\n    \"dragend\":\"drag\",\n    \"singletap\":\"tap.double\",\n    \"doubletap\":\"tap.double\",\n    \"longpress\":\"longpress\",\n    \"longpresscancel\":\"longpress\",\n    \"pinchstart\":\"pinch\",\n    \"pinch\":\"pinch\",\n    \"pinchend\":\"pinch\"\n};\n                function main(key){\n\n                    return get(config , key) ;\n\n                }\n                \n    \n                    return function(key){\n    \n                        \n        if(!var_init_locked_1608956298582){\n\n            get = include('src::object.value.get');\n\n            var_init_locked_1608956298582 = true ;\n        }\n        \n    \n                        return main.call(this , key) ;\n                    } ;\n    \n                })()",
    "folder": "config",
    "name": "event"
  },
  "src::browser.event.gesture.manager.jsx": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.event.gesture.manager.jsx(<object> config)",
    "standard": true,
    "importNames": [
      "src::string.capitalize"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let capitalize;\n    \n                    let var_init_locked_1608956298586;\n    \n                    \n\n                    \n/**\n * \n * 基于 JSX 的事件管理\n * \n * @import capitalize from string.capitalize\n * \n * @param {object} config 未经识别的事件集合\n * \n * @return {object} 已识别事件属性集合\n * \n */\n\n const eventSuffixRe = /(?:start|end)$/,\n eventPropertyRe = /^on/,\n {\n    keys\n } = Object;\n\n function getEventImplName(event){\n\n    return event.replace(eventSuffixRe , '') ;\n }\n\n function isGestureImplName(event){\n\n    try{\n\n        include(`browser.event.gesture.${event}.event`) ;\n\n        return true ;\n\n    }catch(err){\n\n    }\n\n    return false ;\n }\n\n function getGestureImplStartEventName(event){\n\n    switch(include(`browser.event.gesture.${event}.event`)()){\n\n        case 'pointerdown':\n\n            return 'onPointerDown' ;\n\n        case 'mousedown':\n\n            return 'onMouseDown' ;\n\n        case 'touchstart':\n\n            return 'onTouchStart' ;\n   }\n\n }\n\n function getGestureImplStartEventListener(event , listeners){\n\n    return include(`browser.event.gesture.${event}`).bind({\n        dispatch(event , params){\n\n            if(listeners.hasOwnProperty(event)){\n\n                listeners[event](params) ;\n            }\n        }\n    });\n}\n\nfunction addListener(listeners , event , fn){\n\n    if(listeners.hasOwnProperty(event)){\n\n        listeners[event] = (...args) =>{\n\n            listeners[event](...args) ;\n\n            fn(...args) ;\n        } ;\n    \n    }else{\n\n        listeners[event] = fn ;\n    }\n}\n\nfunction getEventProperties(listeners){\n\n    let events = keys(listeners),\n        properties = {};\n\n    for(let event of events){\n\n        if(eventPropertyRe.test(event)){\n\n            properties[event] = listeners[event];\n        }\n    }\n\n    return properties ;\n}\n\n function main(config){\n\n    let events = keys(config),\n        listeners = {},\n        gestureEvents = [];\n\n    for(let event of events){\n\n        let eventImpl = getEventImplName(event) ;\n\n        if(isGestureImplName(eventImpl) && !gestureEvents.includes(eventImpl)){\n\n            gestureEvents.push(eventImpl) ;\n\n            addListener(listeners , getGestureImplStartEventName(eventImpl) , getGestureImplStartEventListener(eventImpl , listeners)) ;\n        \n        }\n\n        addListener(listeners , event , config[event]) ;\n    }\n\n    return getEventProperties(listeners) ;\n }\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298586){\n\n            capitalize = include('src::string.capitalize');\n\n            var_init_locked_1608956298586 = true ;\n        }\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.manager.jsx"
  },
  "src::string.capitalize": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::string.capitalize(<string> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 实现首字母大写\n * \n * @param {string} data 字符串\n * \n * @return {string} 首字母大写的字符串 \n * \n */\n\n return `${data.charAt(0).toUpperCase()}${data.substr(1)}` ;\n\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "string.capitalize"
  },
  "src::browser.event.gesture.pinch.disabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.pinch.disabled()",
    "standard": true,
    "importNames": [
      "src::browser.event.listener.global.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let un;\n    \n                    let var_init_locked_1608956298591;\n    \n                    \n\n                    function main(){\n\n        /**\n * \n * 禁用事件\n * \n * @import un from browser.event.listener.global.remove\n * \n */\n\nlet me = this,\n{\n    onStart,\n    onMove,\n    onEnd\n} = me;\n\nun('touchmove' , onStart) ;\n\nun('touchmove' , onMove) ;\n\nun('touchend' , onEnd) ;\n\ndelete me.onStart ;\n\ndelete me.onMove ;\n\ndelete me.onEnd ;\n\ndelete me.startDistance ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298591){\n\n            un = include('src::browser.event.listener.global.remove');\n\n            var_init_locked_1608956298591 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.pinch.disabled"
  },
  "src::browser.event.gesture.pinch.enabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.pinch.enabled()",
    "standard": true,
    "importNames": [
      "src::browser.event.listener.global.add",
      "src::browser.event.gesture.pinch.move.start",
      "src::browser.event.gesture.pinch.end"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let on;\n    \n                    let var_init_locked_1608956298593;\n \n                    \n\n                    const var_current_scope_1608956298593 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298593){\n\n            on = include('src::browser.event.listener.global.add');\n\n            var_init_locked_1608956298593 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298593.has(this)){\n\n            var_current_scope_1608956298593.set(this , (() => {\n                const onMove = include('src::browser.event.gesture.pinch.move.start').bind(this);\nconst onEnd = include('src::browser.event.gesture.pinch.end').bind(this);\n\n                function main(){\n\n        /**\n * \n * 启用事件\n * \n * @import on from browser.event.listener.global.add\n * \n * @import onMove from .move.start scoped\n * \n * @import onEnd from .end scoped\n * \n */\n\n let me = this ;\n\non('touchmove' , me.onStart = onMove) ;\n\non('touchend' , me.onEnd = onEnd) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298593.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.pinch.enabled"
  },
  "src::math.point.line.center": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::math.point.line.center(<object> point1 , <object> point2)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(point1 , point2){\n\n        /**\n * \n * 计算线段的中心点坐标\n * \n * @param {object} point1 第一个点的位置\n * \n * @param {object} point2 第二个点的位置\n * \n * @return {object} 中心点坐标\n * \n */\n return {\n    x:(point1.x + point2.x) / 2,\n    y:(point1.y + point2.y) / 2\n } ;\n\n    }\n    \n                    return function(point1 , point2){\n    \n                        \n    \n                        return main.call(this , point1 , point2) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.point.line.center"
  },
  "src::browser.event.gesture.pinch.move.pinch": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.pinch.move.pinch(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.touches",
      "src::browser.event.stop",
      "src::math.point.line.distance",
      "src::math.point.line.center",
      "src::browser.event.listener.global.remove",
      "src::browser.event.gesture.pinch.move.pinch"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getTouchEvents,stop,getDistance,getCenterXY,un;\n    \n                    let var_init_locked_1608956298602;\n \n                    \n\n                    const var_current_scope_1608956298602 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298602){\n\n            getTouchEvents = include('src::browser.event.touches');\nstop = include('src::browser.event.stop');\ngetDistance = include('src::math.point.line.distance');\ngetCenterXY = include('src::math.point.line.center');\nun = include('src::browser.event.listener.global.remove');\n\n            var_init_locked_1608956298602 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298602.has(this)){\n\n            var_current_scope_1608956298602.set(this , (() => {\n                const onMove = include('src::browser.event.gesture.pinch.move.pinch').bind(this);\n\n                function main(e){\n\n        /**\n * \n * 缩放进行事件监听\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import stop from browser.event.stop\n * \n * @import getDistance from math.point.line.distance\n * \n * @import getCenterXY from math.point.line.center\n * \n * @import un from browser.event.listener.global.remove\n * \n * @import onMove from .pinch scoped\n * \n * @param {Event} e 事件对象\n * \n */\n\nstop(e) ;\n\nlet touches = getTouchEvents(e , 'move'),\n    [\n        firstTouch,\n        lastTouch\n    ] = touches,\n    startXY = {\n        x:firstTouch.pageX,\n        y:firstTouch.pageY\n    },\n    endXY = {\n        x:lastTouch.pageX,\n        y:lastTouch.pageY\n    },\n    distance = getDistance(startXY , endXY),\n    {\n        startDistance,\n        dispatch\n    } = this;\n\ndispatch('pinch', {\n    distance,\n    point:getCenterXY(startXY , endXY),\n    scale:distance / startDistance\n});\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298602.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.pinch.move.pinch"
  },
  "src::browser.event.gesture.pinch.move.start": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.pinch.move.start(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.touches",
      "src::browser.event.stop",
      "src::math.point.line.distance",
      "src::math.point.line.center",
      "src::browser.event.listener.global.remove",
      "src::browser.event.listener.global.add",
      "src::browser.event.gesture.pinch.move.pinch"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getTouchEvents,stop,getDistance,getCenterXY,un,on;\n    \n                    let var_init_locked_1608956298595;\n \n                    \n\n                    const var_current_scope_1608956298595 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298595){\n\n            getTouchEvents = include('src::browser.event.touches');\nstop = include('src::browser.event.stop');\ngetDistance = include('src::math.point.line.distance');\ngetCenterXY = include('src::math.point.line.center');\nun = include('src::browser.event.listener.global.remove');\non = include('src::browser.event.listener.global.add');\n\n            var_init_locked_1608956298595 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298595.has(this)){\n\n            var_current_scope_1608956298595.set(this , (() => {\n                const onMove = include('src::browser.event.gesture.pinch.move.pinch').bind(this);\n\n                function main(e){\n\n        /**\n * \n * 缩放开始事件监听\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import stop from browser.event.stop\n * \n * @import getDistance from math.point.line.distance\n * \n * @import getCenterXY from math.point.line.center\n * \n * @import un from browser.event.listener.global.remove\n * \n * @import on from browser.event.listener.global.add\n * \n * @import onMove from .pinch scoped\n * \n * @param {Event} e 事件对象\n * \n */\n\nstop(e) ;\n\nlet touches = getTouchEvents(e , 'move'),\n    [\n        firstTouch,\n        lastTouch\n    ] = touches,\n    firstXY = {\n        x:firstTouch.pageX,\n        y:firstTouch.pageY\n    },\n    lastXY = {\n        x:lastTouch.pageX,\n        y:lastTouch.pageY\n    },\n    distance = getDistance(firstXY , lastXY),\n    me = this;\n\nif(distance === 0){\n\n    return ;\n}\n\nlet {\n    el,\n    dispatch\n} = me ;\n\nme.startDistance = distance ;\n\ndispatch('pinchstart', {\n    distance,\n    point:getCenterXY(firstXY , lastXY)\n});\n\nun('touchmove' , me.onStart) ;\n\non('touchmove' , me.onMove = onMove) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298595.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.pinch.move.start"
  },
  "src::browser.event.gesture.pinch.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.pinch.end(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.stop",
      "src::browser.event.gesture.pinch.disabled"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let stop;\n    \n                    let var_init_locked_1608956298608;\n \n                    \n\n                    const var_current_scope_1608956298608 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298608){\n\n            stop = include('src::browser.event.stop');\n\n            var_init_locked_1608956298608 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298608.has(this)){\n\n            var_current_scope_1608956298608.set(this , (() => {\n                const disabled = include('src::browser.event.gesture.pinch.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 结束事件监听\n * \n * @import stop from browser.event.stop\n * \n * @import disabled from .disabled scoped\n * \n * @param {Event} e 事件对象\n * \n */\n\nstop(e) ;\n\nlet me = this,\n{\n    dispatch\n} = me;\n\ndisabled() ;\n\ndispatch('pinchend') ;\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298608.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.pinch.end"
  },
  "src::browser.event.gesture.pinch.event": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::browser.event.gesture.pinch.event()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        /**\n * \n * 获得启动监听事件名称\n * \n * @return {string}\n * \n */\n\nreturn 'touchstart' ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.pinch.event"
  },
  "src::browser.event.gesture.pinch": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.pinch(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.touches",
      "src::browser.event.listener.global.add",
      "src::browser.event.gesture.pinch.enabled",
      "src::browser.event.gesture.pinch.disabled",
      "src::browser.event.gesture.pinch.event"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getTouchEvents,on,browserEventGesturePinchEvent;\n    \n                    let var_init_locked_1608956298612;\n \n                    \n\n                    const var_current_scope_1608956298612 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298612){\n\n            getTouchEvents = include('src::browser.event.touches');\non = include('src::browser.event.listener.global.add');\nbrowserEventGesturePinchEvent = include('src::browser.event.gesture.pinch.event');\n\n            var_init_locked_1608956298612 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298612.has(this)){\n\n            var_current_scope_1608956298612.set(this , (() => {\n                const enabled = include('src::browser.event.gesture.pinch.enabled').bind(this);\nconst disabled = include('src::browser.event.gesture.pinch.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 开始事件监听\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import on from browser.event.listener.global.add\n * \n * @import enabled from .pinch.enabled scoped\n * \n * @import disabled from .pinch.disabled scoped\n * \n * @import .pinch.event\n *\n * @param {Event} e 事件对象\n * \n */\n\nlet me = this ;\n\nif(me.onStart){\n\n    disabled() ;\n}\n\nlet touches = getTouchEvents(e , 'start') ;\n\nif(touches){\n\n    enabled() ;\n}\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298612.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.pinch"
  },
  "src::browser.event.gesture.react": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.event.gesture.react(<object> config)",
    "standard": true,
    "importNames": [
      "src::browser.event.gesture.manager.jsx"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let jsx;\n    \n                    let var_init_locked_1608956298614;\n    \n                    \n\n                    function main(config){\n\n        \n/**\n * \n * 基于 React 的手势事件实现\n * \n * @import jsx from browser.event.gesture.manager.jsx\n * \n * @param {object} config 未经识别的事件集合\n * \n * @return {object} 已识别事件属性集合\n * \n */\n\n return jsx(config) ;\n\n    }\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1608956298614){\n\n            jsx = include('src::browser.event.gesture.manager.jsx');\n\n            var_init_locked_1608956298614 = true ;\n        }\n        \n    \n                        return main.call(this , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.react"
  },
  "src::browser.event.gesture.swipe.methods.cancel": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.methods.cancel(<HTMLElement> el , <Event> event , <Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.gesture.swipe.methods.disabled",
      "src::browser.event.dispatch"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let disabled,dispatch;\n    \n                    let var_init_locked_1608956298616;\n    \n                    \n\n                    function main(el , event , e){\n\n        /**\n * \n * 取消滑动事件\n * \n * @import disabled from browser.event.gesture.swipe.methods.disabled\n * \n * @import dispatch from browser.event.dispatch\n * \n * @param {HTMLElement} el 作用元素\n * \n * @param {Event} event 当前可用事件对象\n * \n * @param {Event} e 原始事件对象\n * \n */\n\ndisabled(el) ;\n\ndispatch(el , 'touch:swipecancel' , {\n    browserEvent:e,\n    event\n}) ;\n\n    }\n    \n                    return function(el , event , e){\n    \n                        \n        if(!var_init_locked_1608956298616){\n\n            disabled = include('src::browser.event.gesture.swipe.methods.disabled');\ndispatch = include('src::browser.event.dispatch');\n\n            var_init_locked_1608956298616 = true ;\n        }\n        \n    \n                        return main.call(this , el , event , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.methods.cancel"
  },
  "src::object.data.name.signature": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::object.data.name.signature()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956298631;\n\n                    function main(){\n\n        /**\n * \n * 用于生成当前生命周期唯一签名\n * \n * @once\n * \n * @return {string}\n * \n */\n\nreturn `zbee-key-${Date.now()}` ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956298631){\n\n            return var_once_value_1608956298631 ;\n\n        }\n        return var_once_value_1608956298631 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.data.name.signature"
  },
  "src::object.data.name": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::object.data.name(<string> name)",
    "standard": true,
    "importNames": [
      "src::object.data.name.signature"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let signature;\n    \n                    let var_init_locked_1608956298628;\n    \n                    \n\n                    function main(name){\n\n        /**\n * \n * 获取可以设置的属性名称\n * \n * @import signature from object.data.name.signature\n * \n * @param {string} name 属性名称\n * \n * @return {string} 可用的属性名称\n * \n */\n\nreturn `${signature()}-${name}` ;\n\n    }\n    \n                    return function(name){\n    \n                        \n        if(!var_init_locked_1608956298628){\n\n            signature = include('src::object.data.name.signature');\n\n            var_init_locked_1608956298628 = true ;\n        }\n        \n    \n                        return main.call(this , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.data.name"
  },
  "src::object.data.get": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::object.data.get(<mixed> target , <string> name)",
    "standard": true,
    "importNames": [
      "src::object.data.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956298627;\n    \n                    \n\n                    function main(target , name){\n\n        \n/**\n * \n * 获取元素的具体属性值\n * \n * @import getName from object.data.name\n * \n * @param {mixed} target 作用对象\n * \n * @param {string} name 属性名称\n * \n * @return {mixed} 对于属性名称的值 \n * \n */\n\nreturn target[getName(name)] ;\n\n\n    }\n    \n                    return function(target , name){\n    \n                        \n        if(!var_init_locked_1608956298627){\n\n            getName = include('src::object.data.name');\n\n            var_init_locked_1608956298627 = true ;\n        }\n        \n    \n                        return main.call(this , target , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.data.get"
  },
  "src::object.data.set": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::object.data.set(<mixed> target , <string> name , <mixed> value)",
    "standard": true,
    "importNames": [
      "src::object.data.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956298633;\n    \n                    \n\n                    function main(target , name , value){\n\n        \n/**\n * \n * 设置基于元素的具名属性值\n * \n * @import getName from object.data.name\n * \n * @param {mixed} target 作用对象\n * \n * @param {string} name 属性名称\n * \n * @param {mixed} value 属性值\n * \n * @return {mixed} 设置后的属性值\n * \n */\n\ntarget[getName(name)] = value ;\n\n    }\n    \n                    return function(target , name , value){\n    \n                        \n        if(!var_init_locked_1608956298633){\n\n            getName = include('src::object.data.name');\n\n            var_init_locked_1608956298633 = true ;\n        }\n        \n    \n                        return main.call(this , target , name , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.data.set"
  },
  "src::browser.event.gesture.swipe.methods.onMove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.methods.onMove(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.pointer",
      "src::browser.event.gesture.swipe.methods.cancel",
      "src::object.data.get",
      "src::object.data.set",
      "src::browser.event.dispatch",
      "src::browser.html.element.removeWindowEventListener",
      "src::browser.event.gesture.swipe.methods.onMove",
      "src::browser.event.pointer.move",
      "src::browser.support.touch",
      "config::gesture.swipe"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getEvent,cancel,get,set,dispatch,removeEventListener,onMove,getMoveEventName,supportTouch,maxDuration,moveDistance,minDistance,maxOffset;\n    \n                    let var_init_locked_1608956298622;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 移动事件监听\n * \n * @import getEvent from browser.event.pointer\n * \n * @import cancel from browser.event.gesture.swipe.methods.cancel\n * \n * @import get from object.data.get\n * \n * @import set from object.data.set\n * \n * @import dispatch from browser.event.dispatch\n * \n * @import removeEventListener from browser.html.element.removeWindowEventListener\n * \n * @import onMove from browser.event.gesture.swipe.methods.onMove\n * \n * @import getMoveEventName from browser.event.pointer.move\n * \n * @import supportTouch from browser.support.touch\n * \n * @config maxDuration from gesture.swipe...maxDuration\n * \n * @config moveDistance from gesture.swipe...moveDistance\n * \n * @config minDistance from gesture.swipe...minDistance\n * \n * @config maxOffset from gesture.swipe...maxOffset\n * \n * @param {Event} e 事件对象\n * \n * \n */\n\ne.preventDefault() ;\n\nlet el = this,\n    event = getEvent(e),\n    x = event.pageX,\n    y = event.pageY,\n    deltaX = x - get(el , 'swipe:startX'),\n    deltaY = y - get(el , 'swipe:startY'),\n    absDeltaX = Math.abs(deltaX),\n    absDeltaY = Math.abs(deltaY),\n    duration = Date.now() - get(el , 'swipe:startTime'),\n    isHorizontal = get(el , 'swipe:isHorizontal'),\n    isVertical = get(el , 'swipe:isVertical'),\n    direction,\n    distance;\n\nif ((supportTouch() && (absDeltaX === 0 && absDeltaY === 0)) || (duration > maxDuration)) {\n\n    return cancel(el , event , e) ;\n\n}\n\nif (isHorizontal && absDeltaY > maxOffset) {\n\n    set(el , 'swipe:isHorizontal' , isHorizontal = false) ;\n}\n\nif (isVertical && absDeltaX > maxOffset) {\n\n    set(el , 'swipe:isVertical' , isVertical = false) ;\n}\n\nif(!isHorizontal && !isVertical){\n\n    return cancel(el , event , e) ;\n}\n\nif (!isVertical || !isHorizontal){\n\n    if(isHorizontal && absDeltaX < minDistance) {\n\n        direction = (deltaX < 0) ? 'left' : 'right';\n\n        distance = absDeltaX;\n\n    }else if(isVertical && absDeltaY < minDistance) {\n\n        direction = (deltaY < 0) ? 'up' : 'down';\n        \n        distance = absDeltaY;\n    }\n}\n\nif (direction) {\n    \n    removeEventListener(el , getMoveEventName() , onMove) ;\n\n    dispatch(el , 'touch:swipestart' , {\n        browserEvent:e,\n        event,\n        direction,\n        distance,\n        duration\n    });\n}\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298622){\n\n            getEvent = include('src::browser.event.pointer');\ncancel = include('src::browser.event.gesture.swipe.methods.cancel');\nget = include('src::object.data.get');\nset = include('src::object.data.set');\ndispatch = include('src::browser.event.dispatch');\nremoveEventListener = include('src::browser.html.element.removeWindowEventListener');\nonMove = include('src::browser.event.gesture.swipe.methods.onMove');\ngetMoveEventName = include('src::browser.event.pointer.move');\nsupportTouch = include('src::browser.support.touch');\nmaxDuration = config('gesture.swipe' , 'maxDuration');\nmoveDistance = config('gesture.swipe' , 'moveDistance');\nminDistance = config('gesture.swipe' , 'minDistance');\nmaxOffset = config('gesture.swipe' , 'maxOffset');\n\n            var_init_locked_1608956298622 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.methods.onMove"
  },
  "src::browser.event.gesture.swipe.methods.onEnd": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.methods.onEnd(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.gesture.swipe.methods.cancel",
      "src::browser.event.gesture.swipe.methods.disabled",
      "src::browser.event.dispatch",
      "src::browser.event.pointer",
      "src::object.data.get",
      "src::object.data.set",
      "config::gesture.swipe"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let cancel,disabled,dispatch,getEvent,get,set,maxDuration,moveDistance,minDistance,maxOffset;\n    \n                    let var_init_locked_1608956298636;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 结束事件监听\n * \n * @import cancel from browser.event.gesture.swipe.methods.cancel\n * \n * @import disabled from browser.event.gesture.swipe.methods.disabled\n * \n * @import dispatch from browser.event.dispatch\n * \n * @import getEvent from browser.event.pointer\n * \n * @import get from object.data.get\n * \n * @import set from object.data.set\n * \n * @config maxDuration from gesture.swipe...maxDuration\n * \n * @config moveDistance from gesture.swipe...moveDistance\n * \n * @config minDistance from gesture.swipe...minDistance\n * \n * @config maxOffset from gesture.swipe...maxOffset\n * \n * @param {Event} e 事件对象\n * \n */\n\ne.preventDefault() ;\n\nlet el = this,\n    event = getEvent(e),\n    x = event.pageX,\n    y = event.pageY,\n    deltaX = x - get(el , 'swipe:startX'),\n    deltaY = y - get(el , 'swipe:startY'),\n    absDeltaX = Math.abs(deltaX),\n    absDeltaY = Math.abs(deltaY),\n    duration = Date.now() - get(el , 'swipe:startTime'),\n    isHorizontal = get(el , 'swipe:isHorizontal'),\n    isVertical = get(el , 'swipe:isVertical'),\n    direction,\n    distance;\n\n\nif(isVertical && absDeltaY < minDistance){\n\n    set(el , 'swipe:isVertical' , isVertical = false) ;\n}\n\nif(isHorizontal && absDeltaX < minDistance){\n\n    set(el , 'swipe:isHorizontal' , isHorizontal = false) ;\n}\n\nif(isHorizontal){\n\n    direction = (deltaX < 0) ? 'left' : 'right';\n\n    distance = absDeltaX;\n\n}else if(isVertical){\n\n    direction = (deltaY < 0) ? 'up' : 'down';\n    \n    distance = absDeltaY;\n}\n\nif(!isHorizontal && !isVertical){\n\n    return cancel(el , event , e) ;\n}\n\ndisabled(el) ;\n\ndispatch(el , 'touch:swipe' , {\n    browserEvent:e,\n    event,\n    direction,\n    distance,\n    duration\n});\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298636){\n\n            cancel = include('src::browser.event.gesture.swipe.methods.cancel');\ndisabled = include('src::browser.event.gesture.swipe.methods.disabled');\ndispatch = include('src::browser.event.dispatch');\ngetEvent = include('src::browser.event.pointer');\nget = include('src::object.data.get');\nset = include('src::object.data.set');\nmaxDuration = config('gesture.swipe' , 'maxDuration');\nmoveDistance = config('gesture.swipe' , 'moveDistance');\nminDistance = config('gesture.swipe' , 'minDistance');\nmaxOffset = config('gesture.swipe' , 'maxOffset');\n\n            var_init_locked_1608956298636 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.methods.onEnd"
  },
  "src::object.data.remove": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.data.remove(<mixed> target , <string> name)",
    "standard": true,
    "importNames": [
      "src::object.data.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956298638;\n    \n                    \n\n                    function main(target , name){\n\n        \n/**\n * \n * 移除元素指定的属性值\n * \n * @import getName from object.data.name\n * \n * @param {mixed} target 作用对象\n * \n * @param {string} name 属性名称\n * \n */\n\ndelete target[getName(name)] ;\n\n    }\n    \n                    return function(target , name){\n    \n                        \n        if(!var_init_locked_1608956298638){\n\n            getName = include('src::object.data.name');\n\n            var_init_locked_1608956298638 = true ;\n        }\n        \n    \n                        return main.call(this , target , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.data.remove"
  },
  "src::browser.event.gesture.swipe.methods.disabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.methods.disabled(<HTMLElement> el)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.removeWindowEventListener",
      "src::browser.event.gesture.swipe.methods.onMove",
      "src::browser.event.gesture.swipe.methods.onEnd",
      "src::browser.event.pointer.move",
      "src::browser.event.pointer.up",
      "src::object.data.get",
      "src::object.data.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let removeEventListener,onMove,onEnd,getMoveEventName,getUpEventName,get,remove;\n    \n                    let var_init_locked_1608956298618;\n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 禁用全局监听\n * \n * @import removeEventListener from browser.html.element.removeWindowEventListener\n * \n * @import onMove from browser.event.gesture.swipe.methods.onMove\n * \n * @import onEnd from browser.event.gesture.swipe.methods.onEnd\n * \n * @import getMoveEventName from browser.event.pointer.move\n * \n * @import getUpEventName from browser.event.pointer.up\n * \n * @import get from object.data.get\n * \n * @import remove from object.data.remove\n * \n * @param {HTMLElement} el 元素\n * \n * \n */\n\nremoveEventListener(el , getMoveEventName() , onMove) ;\n\nremoveEventListener(el , getUpEventName() , onEnd) ;\n\nremove(el , 'swipe:startTime') ;\n\nremove(el , 'swipe:isHorizontal') ;\n\nremove(el , 'swipe:isVertical') ;\n\nremove(el , 'swipe:startX') ;\n\nremove(el , 'swipe:startY') ;\n\n    }\n    \n                    return function(el){\n    \n                        \n        if(!var_init_locked_1608956298618){\n\n            removeEventListener = include('src::browser.html.element.removeWindowEventListener');\nonMove = include('src::browser.event.gesture.swipe.methods.onMove');\nonEnd = include('src::browser.event.gesture.swipe.methods.onEnd');\ngetMoveEventName = include('src::browser.event.pointer.move');\ngetUpEventName = include('src::browser.event.pointer.up');\nget = include('src::object.data.get');\nremove = include('src::object.data.remove');\n\n            var_init_locked_1608956298618 = true ;\n        }\n        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.methods.disabled"
  },
  "src::browser.event.gesture.swipe.methods.enabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.methods.enabled(<HTMLElement> el)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.addWindowEventListener",
      "src::browser.event.gesture.swipe.methods.onMove",
      "src::browser.event.gesture.swipe.methods.onEnd",
      "src::browser.event.pointer.move",
      "src::browser.event.pointer.up"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let addEventListener,onMove,onEnd,getMoveEventName,getUpEventName;\n    \n                    let var_init_locked_1608956298640;\n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 启动全局监听\n * \n * @import addEventListener from browser.html.element.addWindowEventListener\n * \n * @import onMove from browser.event.gesture.swipe.methods.onMove\n * \n * @import onEnd from browser.event.gesture.swipe.methods.onEnd\n * \n * @import getMoveEventName from browser.event.pointer.move\n * \n * @import getUpEventName from browser.event.pointer.up\n * \n * @param {HTMLElement} el 元素\n * \n * \n */\n\naddEventListener(el , getMoveEventName() , onMove) ;\n\naddEventListener(el , getUpEventName() , onEnd) ;\n\n    }\n    \n                    return function(el){\n    \n                        \n        if(!var_init_locked_1608956298640){\n\n            addEventListener = include('src::browser.html.element.addWindowEventListener');\nonMove = include('src::browser.event.gesture.swipe.methods.onMove');\nonEnd = include('src::browser.event.gesture.swipe.methods.onEnd');\ngetMoveEventName = include('src::browser.event.pointer.move');\ngetUpEventName = include('src::browser.event.pointer.up');\n\n            var_init_locked_1608956298640 = true ;\n        }\n        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.methods.enabled"
  },
  "src::browser.event.gesture.swipe.methods.install": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.methods.install(<HTMLElement> el)",
    "standard": true,
    "importNames": [
      "src::browser.event.gesture.swipe.methods.onStart",
      "src::browser.event.pointer.down"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let onStart,getEventName;\n    \n                    let var_init_locked_1608956298646;\n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 安装事件\n * \n * @import onStart from browser.event.gesture.swipe.methods.onStart\n * \n * @import getEventName from browser.event.pointer.down\n * \n * @param {HTMLElement} el 页面元素\n * \n * \n */\n\nel.addEventListener(getEventName() , onStart) ;\n\n\n    }\n    \n                    return function(el){\n    \n                        \n        if(!var_init_locked_1608956298646){\n\n            onStart = include('src::browser.event.gesture.swipe.methods.onStart');\ngetEventName = include('src::browser.event.pointer.down');\n\n            var_init_locked_1608956298646 = true ;\n        }\n        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.methods.install"
  },
  "src::browser.event.gesture.swipe.methods.onStart": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.methods.onStart(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.pointer",
      "src::browser.event.gesture.swipe.methods.enabled",
      "src::object.data.set"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getEvent,enabled,set;\n    \n                    let var_init_locked_1608956298648;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 启动事件监听\n * \n * @import getEvent from browser.event.pointer\n * \n * @import enabled from browser.event.gesture.swipe.methods.enabled\n * \n * @import set from object.data.set\n * \n * @param {Event} e 事件对象\n * \n */\n\ne.preventDefault() ;\n\nlet event = getEvent(e , true);\n\nif(!event){\n\n    return ;\n}\n\nlet el = this ;\n\nset(el , 'swipe:startTime' , Date.now()) ;\n\nset(el , 'swipe:isHorizontal' , true) ;\n\nset(el , 'swipe:isVertical' , true) ;\n\nset(el , 'swipe:startX' , event.pageX) ;\n\nset(el , 'swipe:startY' , event.pageY) ;\n\nenabled(el) ;\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298648){\n\n            getEvent = include('src::browser.event.pointer');\nenabled = include('src::browser.event.gesture.swipe.methods.enabled');\nset = include('src::object.data.set');\n\n            var_init_locked_1608956298648 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.methods.onStart"
  },
  "src::browser.event.gesture.swipe.methods.uninstall": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.methods.uninstall(<HTMLElement> el)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 卸载事件\n * \n * \n * @param {HTMLElement} el 页面元素\n * \n * \n */\n\n // 代码实现\n\n\n    }\n    \n                    return function(el){\n    \n                        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.methods.uninstall"
  },
  "src::browser.event.gesture.swipe.properties.handleEvents": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.swipe.properties.handleEvents()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_once_value_1608956298652;\n\n                    function main(){\n\n        \n/**\n * \n * 支持事件列表\n * \n * @once\n * \n */\n\nreturn [\n    'touch:swipestart',\n    'touch:swipe',\n    'touch:swipecancel'\n] ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        \n        if(var_once_value_1608956298652){\n\n            return var_once_value_1608956298652 ;\n\n        }\n        return var_once_value_1608956298652 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.swipe.properties.handleEvents"
  },
  "src::browser.event.gesture.tap.disabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.disabled()",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single",
      "src::browser.event.listener.global.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName,un;\n    \n                    let var_init_locked_1608956298654;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 取消监听全局事件\n * \n * @import getName from browser.event.name.single\n * \n * @import un from browser.event.listener.global.remove\n * \n */\n\n let me = this,\n {\n    onMove,\n    onEnd,\n    timer\n } = me;\n\n if(timer){\n\n   clearTimeout(timer) ;\n }\n\n un(getName('move') ,  onMove) ;\n\n un(getName('end') ,  onEnd) ;\n\n delete me.timer ;\n\n delete me.onMove ;\n\n delete me.onEnd ;\n\n \n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298654){\n\n            getName = include('src::browser.event.name.single');\nun = include('src::browser.event.listener.global.remove');\n\n            var_init_locked_1608956298654 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.disabled"
  },
  "src::browser.event.gesture.tap.double.disabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.double.disabled(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single",
      "src::browser.event.listener.global.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName,un;\n    \n                    let var_init_locked_1608956298656;\n    \n                    \n\n                    function main(e){\n\n        \n/**\n * \n * 取消监听全局事件\n * \n * @import getName from browser.event.name.single\n * \n * @import un from browser.event.listener.global.remove\n * \n * @param {Event} e 事件对象\n * \n */\n\nlet me = this,\n{\n   onMove,\n   onEnd,\n   timer\n} = me;\n\nif(timer){\n\n  clearTimeout(timer) ;\n\n}\n\nun(getName('move' , e) ,  onMove) ;\n\nun(getName('end' , e) ,  onEnd) ;\n\ndelete me.timer ;\n\ndelete me.onMove ;\n\ndelete me.onEnd ;\n\ndelete me.startPoint ;\n\ndelete me.startTime ;\n\ndelete me.lastTarget ;\n\ndelete me.lastTapTime ;\n\n\n\n    }\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298656){\n\n            getName = include('src::browser.event.name.single');\nun = include('src::browser.event.listener.global.remove');\n\n            var_init_locked_1608956298656 = true ;\n        }\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.double.disabled"
  },
  "src::browser.event.gesture.tap.double.enabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.double.enabled(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single",
      "src::browser.event.gesture.tap.double.move",
      "src::browser.event.gesture.tap.double.end",
      "src::browser.event.listener.global.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName,on;\n    \n                    let var_init_locked_1608956298660;\n \n                    \n\n                    const var_current_scope_1608956298660 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298660){\n\n            getName = include('src::browser.event.name.single');\non = include('src::browser.event.listener.global.add');\n\n            var_init_locked_1608956298660 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298660.has(this)){\n\n            var_current_scope_1608956298660.set(this , (() => {\n                const onMove = include('src::browser.event.gesture.tap.double.move').bind(this);\nconst onEnd = include('src::browser.event.gesture.tap.double.end').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 监听全局事件\n * \n * @import getName from browser.event.name.single\n * \n * @import onMove from .move scoped\n * \n * @import onEnd from .end scoped\n * \n * @import on from browser.event.listener.global.add\n * \n * @param {Event} e\n * \n */\n\nlet me = this ;\n\non(getName('move' , e) ,  me.onMove = onMove) ;\n\non(getName('end' , e) , me.onEnd = onEnd) ;\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298660.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.double.enabled"
  },
  "config::event.tap": {
    "meta": "code.meta.config",
    "signature": "<void> config::event.tap(<string> key)",
    "standard": true,
    "importNames": [
      "src::object.value.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956298666;\n    \n                    \n\n                    const config = {\n    \"maxDuration\": 600,\n    \"moveDistance\":100\n};\n                function main(key){\n\n                    return get(config , key) ;\n\n                }\n                \n    \n                    return function(key){\n    \n                        \n        if(!var_init_locked_1608956298666){\n\n            get = include('src::object.value.get');\n\n            var_init_locked_1608956298666 = true ;\n        }\n        \n    \n                        return main.call(this , key) ;\n                    } ;\n    \n                })()",
    "folder": "config",
    "name": "event.tap"
  },
  "src::browser.event.gesture.tap.double.move": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.double.move(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.touches",
      "src::browser.event.single",
      "src::math.point.line.distance",
      "src::browser.scale",
      "src::browser.event.gesture.tap.double.disabled",
      "config::event.tap"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getTouchEvents,getEvent,getDistance,getScale,moveDistance;\n    \n                    let var_init_locked_1608956298663;\n \n                    \n\n                    const var_current_scope_1608956298663 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298663){\n\n            getTouchEvents = include('src::browser.event.touches');\ngetEvent = include('src::browser.event.single');\ngetDistance = include('src::math.point.line.distance');\ngetScale = include('src::browser.scale');\nmoveDistance = config('event.tap' , 'moveDistance');\n\n            var_init_locked_1608956298663 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298663.has(this)){\n\n            var_current_scope_1608956298663.set(this , (() => {\n                const disabled = include('src::browser.event.gesture.tap.double.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 移动事件监听\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import getEvent from browser.event.single\n * \n * @import getDistance from math.point.line.distance\n * \n * @import getScale from browser.scale\n * \n * @import disabled from .disabled scoped\n * \n * @config moveDistance from event.tap...moveDistance\n * \n * @param {Event} e 事件对象\n * \n */\n\nif(getTouchEvents(e , 'move')){\n\n    disabled(e) ;\n\n    return ;\n}\n\nlet me = this,\n{\n    pageX,\n    pageY\n} = getEvent(e , 'move'),\n{\n    startPoint,\n    timer\n} = me;\n\nif(timer){\n\n    return ;\n}\n\nif(Math.round(getDistance({\n    x:pageX,\n    y:pageY\n} , startPoint)) * getScale() >= moveDistance){\n\n    disabled(e) ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298663.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.double.move"
  },
  "config::event.tap.double": {
    "meta": "code.meta.config",
    "signature": "<void> config::event.tap.double(<string> key)",
    "standard": true,
    "importNames": [
      "src::object.value.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956298672;\n    \n                    \n\n                    const config = {\n    \"maxDuration\": 600,\n    \"tapDistance\": 200\n};\n                function main(key){\n\n                    return get(config , key) ;\n\n                }\n                \n    \n                    return function(key){\n    \n                        \n        if(!var_init_locked_1608956298672){\n\n            get = include('src::object.value.get');\n\n            var_init_locked_1608956298672 = true ;\n        }\n        \n    \n                        return main.call(this , key) ;\n                    } ;\n    \n                })()",
    "folder": "config",
    "name": "event.tap.double"
  },
  "src::browser.event.gesture.tap.double.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.double.end(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.touches",
      "src::browser.event.single",
      "src::math.point.line.distance",
      "src::browser.scale",
      "src::browser.event.gesture.tap.double.disabled",
      "src::browser.event.stop",
      "config::event.tap.double"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getTouchEvents,getEvent,getDistance,getScale,stop,maxDuration,tapDistance;\n    \n                    let var_init_locked_1608956298670;\n \n                    \n\n                    const var_current_scope_1608956298670 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298670){\n\n            getTouchEvents = include('src::browser.event.touches');\ngetEvent = include('src::browser.event.single');\ngetDistance = include('src::math.point.line.distance');\ngetScale = include('src::browser.scale');\nstop = include('src::browser.event.stop');\nmaxDuration = config('event.tap.double' , 'maxDuration');\ntapDistance = config('event.tap.double' , 'tapDistance');\n\n            var_init_locked_1608956298670 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298670.has(this)){\n\n            var_current_scope_1608956298670.set(this , (() => {\n                const disabled = include('src::browser.event.gesture.tap.double.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 结束事件监听\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import getEvent from browser.event.single\n * \n * @import getDistance from math.point.line.distance\n * \n * @import getScale from browser.scale\n * \n * @import disabled from .disabled scoped\n * \n * @import stop from browser.event.stop\n * \n * @config maxDuration from event.tap.double...maxDuration\n * \n * @config tapDistance from event.tap.double...tapDistance\n * \n * @param {Event} e 事件对象\n * \n */\n\nif(getTouchEvents(e , 'end')){\n\n    disabled(e) ;\n\n    return ;\n}\n\nlet me = this,\n{\n    pointerType,\n    button\n } = e ;\n\n if(pointerType === 'mouse'){\n\n    if(button !== 0){\n\n        disabled(e) ;\n\n        return ;\n    }\n }\n\n let {\n    startTime,\n    lastTapTime,\n    lastTarget,\n    startPoint,\n    dispatch\n } = me,\n nativeEvent = getEvent(e , 'end'),\n time = Date.now();\n\n if(lastTapTime){\n\n    if(time - lastTapTime <= maxDuration){\n\n        let {\n            pageX,\n            pageY\n        } = nativeEvent;\n\n        if(Math.round(getDistance({\n            x:pageX,\n            y:pageY\n        } , startPoint)) * getScale() <= tapDistance){\n\n            if(nativeEvent.target === lastTarget){\n\n                dispatch('doubletap' , {\n                    nativeEvent\n                }) ;\n            }\n        \n        }\n\n    }\n\n    disabled(e) ;\n\n }else if(time - startTime > maxDuration){\n \n    dispatch('singletap' , {\n        nativeEvent\n    }) ;\n\n    disabled(e) ;\n\n }else{\n\n    me.lastTapTime = time ;\n\n    me.lastTarget = nativeEvent.target ;\n\n    me.timer = setTimeout(() => {\n\n        dispatch('singletap' , {\n            nativeEvent\n        }) ;\n    \n        disabled(e) ;\n\n    } , maxDuration) ;\n }\n\n \n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298670.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.double.end"
  },
  "src::browser.event.gesture.tap.double.event": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::browser.event.gesture.tap.double.event()",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956298674;\n    \n                    \n\n                    function main(){\n\n        /**\n * \n * 获得启动监听事件名称\n * \n * @import getName from browser.event.name.single\n * \n * @return {string}\n * \n */\n\nreturn getName('start') ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298674){\n\n            getName = include('src::browser.event.name.single');\n\n            var_init_locked_1608956298674 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.double.event"
  },
  "src::browser.event.gesture.tap.double": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.double(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.single",
      "src::browser.event.gesture.tap.double.enabled",
      "src::browser.event.gesture.tap.double.event"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getEvent,browserEventGestureTapDoubleEvent;\n    \n                    let var_init_locked_1608956298677;\n \n                    \n\n                    const var_current_scope_1608956298677 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298677){\n\n            getEvent = include('src::browser.event.single');\nbrowserEventGestureTapDoubleEvent = include('src::browser.event.gesture.tap.double.event');\n\n            var_init_locked_1608956298677 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298677.has(this)){\n\n            var_current_scope_1608956298677.set(this , (() => {\n                const enabled = include('src::browser.event.gesture.tap.double.enabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 双击事件实现\n * \n * @import getEvent from browser.event.single\n * \n * @import enabled from .double.enabled scoped\n * \n * @import .double.event\n * \n * @param {Event} e 事件对象\n * \n */\n\n let  me = this ;\n\nif(me.startPoint){\n\n    return ;\n \n }\n \nlet {\n   timer\n} = me;\n\nif(timer){\n\n   clearTimeout(timer) ;\n\n   return ;\n}\n\nlet nativeEvent = getEvent(e , 'start'),\n     {\n        pageX:x,\n        pageY:y\n    } = nativeEvent ;\n \n me.startPoint = {\n    x,\n    y\n } ;\n\n me.startTime = Date.now() ;\n \n enabled(e) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298677.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.double"
  },
  "src::browser.event.gesture.tap.enabled": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.enabled()",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single",
      "src::browser.event.gesture.tap.move",
      "src::browser.event.gesture.tap.end",
      "src::browser.event.listener.global.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName,on;\n    \n                    let var_init_locked_1608956298680;\n \n                    \n\n                    const var_current_scope_1608956298680 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298680){\n\n            getName = include('src::browser.event.name.single');\non = include('src::browser.event.listener.global.add');\n\n            var_init_locked_1608956298680 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298680.has(this)){\n\n            var_current_scope_1608956298680.set(this , (() => {\n                const onMove = include('src::browser.event.gesture.tap.move').bind(this);\nconst onEnd = include('src::browser.event.gesture.tap.end').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 监听全局事件\n * \n * @import getName from browser.event.name.single\n * \n * @import onMove from .move scoped\n * \n * @import onEnd from .end scoped\n * \n * @import on from browser.event.listener.global.add\n * \n */\n\n let me = this ;\n\n on(getName('move') ,  me.onMove = onMove) ;\n\n on(getName('end') , me.onEnd = onEnd) ;\n\n \n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298680.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.enabled"
  },
  "src::browser.event.gesture.tap.move": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.move(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.single",
      "src::math.point.line.distance",
      "src::browser.scale",
      "src::browser.event.gesture.tap.disabled",
      "config::event.tap"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getEvent,getDistance,getScale,moveDistance;\n    \n                    let var_init_locked_1608956298682;\n \n                    \n\n                    const var_current_scope_1608956298682 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298682){\n\n            getEvent = include('src::browser.event.single');\ngetDistance = include('src::math.point.line.distance');\ngetScale = include('src::browser.scale');\nmoveDistance = config('event.tap' , 'moveDistance');\n\n            var_init_locked_1608956298682 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298682.has(this)){\n\n            var_current_scope_1608956298682.set(this , (() => {\n                const disabled = include('src::browser.event.gesture.tap.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 移动事件监听\n * \n * @import getEvent from browser.event.single\n * \n * @import getDistance from math.point.line.distance\n * \n * @import getScale from browser.scale\n * \n * @import disabled from .disabled scoped\n * \n * @config moveDistance from event.tap...moveDistance\n * \n * @param {Event} e 事件对象\n * \n */\n\nlet me = this,\n    {\n        pageX,\n        pageY\n    } = getEvent(e , 'move'),\n    {\n        startPoint,\n        dispatch\n    } = this;\n\nif(Math.round(getDistance({\n    x:pageX,\n    y:pageY\n} , startPoint)) * getScale() >= moveDistance){\n\n    dispatch('tapcancel') ;\n\n    disabled() ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298682.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.move"
  },
  "src::browser.event.gesture.tap.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap.end(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.single",
      "src::browser.event.gesture.tap.disabled",
      "src::browser.event.stop"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getEvent,stop;\n    \n                    let var_init_locked_1608956298685;\n \n                    \n\n                    const var_current_scope_1608956298685 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298685){\n\n            getEvent = include('src::browser.event.single');\nstop = include('src::browser.event.stop');\n\n            var_init_locked_1608956298685 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298685.has(this)){\n\n            var_current_scope_1608956298685.set(this , (() => {\n                const disabled = include('src::browser.event.gesture.tap.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 结束事件监听\n * \n * @import getEvent from browser.event.single\n * \n * @import disabled from .disabled scoped\n * \n * @import stop from browser.event.stop\n * \n * @param {Event} e 事件对象\n * \n */\n\n let me = this,\n {\n    nativeEvent\n } = me ;\n\n me.dispatch('tap' , {\n    nativeEvent\n }) ;\n\n disabled() ;\n\n \n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298685.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.end"
  },
  "src::browser.event.gesture.tap.event": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::browser.event.gesture.tap.event()",
    "standard": true,
    "importNames": [
      "src::browser.event.name.single"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956298687;\n    \n                    \n\n                    function main(){\n\n        /**\n * \n * 获得启动监听事件名称\n * \n * @import getName from browser.event.name.single\n * \n * @return {string}\n * \n */\n\n return getName('start') ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298687){\n\n            getName = include('src::browser.event.name.single');\n\n            var_init_locked_1608956298687 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap.event"
  },
  "src::browser.event.gesture.tap": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.tap(<Event> e)",
    "standard": true,
    "importNames": [
      "src::browser.event.single",
      "src::browser.event.touches",
      "src::browser.event.gesture.tap.enabled",
      "src::browser.event.gesture.tap.disabled",
      "src::browser.event.gesture.tap.event",
      "src::browser.event.stop",
      "config::event.tap"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getEvent,getTouchEvents,browserEventGestureTapEvent,stop,maxDuration;\n    \n                    let var_init_locked_1608956298691;\n \n                    \n\n                    const var_current_scope_1608956298691 = new Map();\n    \n                    return function(e){\n    \n                        \n        if(!var_init_locked_1608956298691){\n\n            getEvent = include('src::browser.event.single');\ngetTouchEvents = include('src::browser.event.touches');\nbrowserEventGestureTapEvent = include('src::browser.event.gesture.tap.event');\nstop = include('src::browser.event.stop');\nmaxDuration = config('event.tap' , 'maxDuration');\n\n            var_init_locked_1608956298691 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298691.has(this)){\n\n            var_current_scope_1608956298691.set(this , (() => {\n                const enabled = include('src::browser.event.gesture.tap.enabled').bind(this);\nconst disabled = include('src::browser.event.gesture.tap.disabled').bind(this);\n\n                function main(e){\n\n        \n/**\n * \n * 开始事件监听\n * \n * @import getEvent from browser.event.single\n * \n * @import getTouchEvents from browser.event.touches\n * \n * @import enabled from .tap.enabled scoped\n * \n * @import disabled from .tap.disabled scoped\n * \n * @config maxDuration from event.tap...maxDuration\n * \n * @import .tap.event\n * \n * @import stop from ..stop\n *\n * @param {Event} e 事件对象\n * \n */\n\nif(getTouchEvents(e , 'start')){\n\n   disabled() ;\n\n   return ;\n\n}\n\nlet me = this,\n   nativeEvent = getEvent(e , 'start'),\n   {\n      pageX:x,\n      pageY:y,\n      pointerType,\n      button\n   } = nativeEvent;\n\nif(pointerType === 'mouse'){\n\n   if(button !== 0){\n\n      return ;\n   }\n}\n\nme.startPoint = {\n   x,\n   y\n} ;\n\nme.nativeEvent = nativeEvent ;\n\nenabled() ;\n\nme.timer = setTimeout(() => disabled() , maxDuration) ;\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298691.get(this) ;\n\n        \n    \n                        return main.call(this , e) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.tap"
  },
  "src::browser.event.gesture.vue": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.gesture.vue(<mixed> Vue)",
    "standard": true,
    "importNames": [
      "src::id.generate",
      "src::browser.event.gesture.manager.dom",
      "src::is.object.simple",
      "src::is.function",
      "src::browser.event.listener.element.add",
      "src::browser.event.listener.element.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let generate,EventDom,isObject,isFunction,on,un;\n    \n                    let var_init_locked_1608956298693;\n    \n                    \n\n                    \n/**\n * \n * 初始化 VUE 触摸指令\n * \n * @import generate from id.generate\n * \n * @import EventDom from browser.event.gesture.manager.dom value\n * \n * @import isObject from is.object.simple\n * \n * @import is.function\n * \n * @import on from browser.event.listener.element.add\n * \n * @import un from browser.event.listener.element.remove\n * \n * @param {mixed} [Vue] VUE 实例\n * \n * \n */\n\n const gesture = Object.freeze({\n\n    bind(el, {\n        arg:name,\n        value:fn\n    }){\n\n      addEventListener(el , name , fn) ;\n\n    },\n  \n    update(el, {\n        arg:name,\n        value:fn,\n        oldValue:oldFn\n    }) {\n\n        if(fn !== oldFn){\n\n            removeEventListener(el , name , oldFn) ;\n  \n            addEventListener(el , name , fn) ;\n        }\n    },\n  \n    unbind(el, {\n        arg:name,\n        value:fn\n    }){\n\n        removeEventListener(el , name , fn) ;\n      \n    }\n}) ;\n\nfunction main(Vue){\n\n    if(Vue){\n\n        Vue.directive('gesture' , gesture) ;\n        \n    }else{\n\n        return {\n            gesture\n        } ;\n    }\n}\n\nfunction addEventListener(el , name , fn){\n\n    let event = `gesture:${name}` ;\n\n    if(isObject(fn)){\n\n        let {\n            fn:listenerFn,\n            scope,\n            ...options\n        } = fn ;\n\n        EventDom.install(el, name , options);\n        \n        on(el , event , listenerFn , {\n            scope\n        });\n\n    }else{\n\n        EventDom.install(el, name);\n\n        on(el , event , fn) ;\n    }\n}\n\nfunction removeEventListener(el , name , fn){\n\n    let event = `gesture:${name}` ;\n\n    if(isObject(fn)){\n\n        let {\n            fn:listenerFn,\n            scope\n        } = fn ;\n        \n        un(el , event , listenerFn , scope);\n\n    }else if(isFunction(fn)){\n\n        un(el , event , fn) ;\n    }\n\n    EventDom.uninstall(el, name);\n}\n    \n                    return function(Vue){\n    \n                        \n        if(!var_init_locked_1608956298693){\n\n            generate = include('src::id.generate');\nEventDom = include('src::browser.event.gesture.manager.dom')();\nisObject = include('src::is.object.simple');\nisFunction = include('src::is.function');\non = include('src::browser.event.listener.element.add');\nun = include('src::browser.event.listener.element.remove');\n\n            var_init_locked_1608956298693 = true ;\n        }\n        \n    \n                        return main.call(this , Vue) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.gesture.vue"
  },
  "src::browser.event.init.cancel": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.init.cancel(<HTMLElement> target)",
    "standard": true,
    "importNames": [
      "src::browser.event.init.listeners",
      "src::browser.event.listener.remove"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let listeners,remove;\n    \n                    let var_init_locked_1608956298696;\n    \n                    \n\n                    function main(target){\n\n        \n/**\n * \n * 取消实始化事件应用环境\n * \n * @import listeners from .listeners value\n * \n * @import remove from browser.event.listener.remove\n * \n * @param {HTMLElement} target 事件应用环境元素\n * \n */\n\nremove(target , listeners) ;\n\n    }\n    \n                    return function(target){\n    \n                        \n        if(!var_init_locked_1608956298696){\n\n            listeners = include('src::browser.event.init.listeners')();\nremove = include('src::browser.event.listener.remove');\n\n            var_init_locked_1608956298696 = true ;\n        }\n        \n    \n                        return main.call(this , target) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.init.cancel"
  },
  "src::browser.event.init.listeners": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.event.init.listeners()",
    "standard": true,
    "importNames": [
      "src::browser.event.prevent",
      "src::browser.event.stop"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let prevent,stop;\n    \n                    let var_init_locked_1608956298698;\n    \n                    let var_once_value_1608956298698;\n\n                    function main(){\n\n        \n/**\n * \n * 函数实现说明\n * \n * @import prevent from ..prevent\n * \n * @import stop from ..stop\n * \n * @return {object} 初始化事件应用环境所使用到的事件 \n * \n * @once\n * \n */\n\n const doPrevent = e => {\n\n    let {\n        target\n    } = e ;\n\n    switch(target.nodeName){\n\n        case 'INPUT':\n        case 'TEXTAREA':\n        case 'SELECT':\n\n            return ;\n\n        default:\n\n            if(target.contentEditable === 'true'){\n\n                let {\n                    type\n                } = e ;\n\n                switch(type){\n\n                    case 'touchstart':\n                    case 'touchmove':\n\n                        break ;\n\n                    default:\n\n                        return ;\n                }\n            }\n    }\n\n    prevent(e) ;\n}\n\nreturn {\n    touchstart:doPrevent,\n    touchmove:doPrevent,\n    mousedown:doPrevent,\n    keydown:doPrevent,\n    mousewheel:doPrevent,\n    contextmenu(e){\n\n        stop(e) ;\n\n        prevent(e) ;\n    }\n} ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298698){\n\n            prevent = include('src::browser.event.prevent');\nstop = include('src::browser.event.stop');\n\n            var_init_locked_1608956298698 = true ;\n        }\n        \n    \n                        \n        if(var_once_value_1608956298698){\n\n            return var_once_value_1608956298698 ;\n\n        }\n        return var_once_value_1608956298698 = main.call(this ) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.init.listeners"
  },
  "src::browser.event.init": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.init(<HTMLElement> target)",
    "standard": true,
    "importNames": [
      "src::browser.event.init.listeners",
      "src::browser.event.listener.add",
      "src::os.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let listeners,add,os;\n    \n                    let var_init_locked_1608956298701;\n    \n                    \n\n                    function main(target){\n\n        \n/**\n * \n * 实始化事件应用环境\n * \n * @import listeners from .init.listeners value\n * \n * @import add from browser.event.listener.add\n * \n * @import os from os.name value\n * \n * @param {HTMLElement} target 事件应用环境元素\n * \n */\n\n switch(os){\n\n    case 'iOS':\n    case 'Android':\n\n        add(window , listeners) ;\n\n    break ;\n\n    default:\n\n        add(target , listeners) ;\n }\n\n    }\n    \n                    return function(target){\n    \n                        \n        if(!var_init_locked_1608956298701){\n\n            listeners = include('src::browser.event.init.listeners')();\nadd = include('src::browser.event.listener.add');\nos = include('src::os.name')();\n\n            var_init_locked_1608956298701 = true ;\n        }\n        \n    \n                        return main.call(this , target) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.init"
  },
  "src::browser.event.key": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.event.key(<Event> event)",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956298703;\n    \n                    \n\n                    \n/**\n * \n * 得到对应代码的值键值 \n * \n * @import is.defined\n * \n * @param {Event} event 键事件对象\n * \n * @return {mixed} 键值 \n * \n */\n\n const KEY_CODES = {\n    39:'RIGHT',\n    37:'LEFT',\n    38:'UP',\n    40:'DOWN',\n    13:'ENTER',\n    46:'DELETE',\n    9:'TAB',\n    107:'+',\n    187:'=',\n    27:'ESC'\n };\n\n function main({\n    shiftKey,\n    keyCode\n }){\n\n   if(isDefined(shiftKey) && isDefined(keyCode)){\n\n      return {\n         shift:shiftKey,\n         key:KEY_CODES[keyCode],\n         code:keyCode\n      } ;\n   }\n }\n    \n                    return function(event){\n    \n                        \n        if(!var_init_locked_1608956298703){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956298703 = true ;\n        }\n        \n    \n                        return main.call(this , event) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.key"
  },
  "src::browser.event.visibility.init": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.event.visibility.init()",
    "standard": true,
    "importNames": [
      "src::browser.event.dispatch"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let dispatch;\n    \n                    let var_init_locked_1608956298705;\n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 初始化页面隐藏/关闭事件\n * \n * @import dispatch from ..dispatch\n * \n */\n\n document.addEventListener('visibilitychange' , () => dispatch(document , document.visibilityState)) ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956298705){\n\n            dispatch = include('src::browser.event.dispatch');\n\n            var_init_locked_1608956298705 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.event.visibility.init"
  },
  "src::browser.html.element.box.page": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.html.element.box.page(<HTMLElement> el)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.getXY",
      "src::browser.html.element.getSize"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getXY,getSize;\n    \n                    let var_init_locked_1608956298707;\n    \n                    \n\n                    function main(el){\n\n        /**\n * \n * 获取元素的领域\n * \n * @import getXY from browser.html.element.getXY\n * \n * @import getSize from browser.html.element.getSize\n * \n * @param {HTMLElement} el\n * \n * @return {object} 高度与宽度的配置\n * \n */\n\nlet {\n    x,\n    y\n} = getXY(el),\n{\n    width,\n    height\n} = getSize(el);\n\n\nreturn {\n    width,\n    height,\n    left:x,\n    top:y,\n    right:x + width,\n    bottom:y + height\n} ;\n\n    }\n    \n                    return function(el){\n    \n                        \n        if(!var_init_locked_1608956298707){\n\n            getXY = include('src::browser.html.element.getXY');\ngetSize = include('src::browser.html.element.getSize');\n\n            var_init_locked_1608956298707 = true ;\n        }\n        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.box.page"
  },
  "src::browser.html.element.getXY": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.html.element.getXY(<HTMLElement> el)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 获得元素的坐标\n * \n * @param {HTMLElement} el 作用元素\n * \n * @return {object} 坐标 \n * \n */\n\nconst \n{\n    round\n} = Math ;\n\nlet \nx = 0,\ny = 0,\n{\n    body\n} = document;\n\nif(el !== document && el !== body){\n   \n    try{\n\n        let bodyRect = body.getBoundingClientRect(),\n            rect = el.getBoundingClientRect();\n\n        x = rect.left - bodyRect.left;\n        y = rect.top - bodyRect.top;\n    \n    }catch(ex){\n\n    }\n}\n\nreturn {\n    x:round(x), \n    y:round(y)\n};\n\n\n    }\n    \n                    return function(el){\n    \n                        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.getXY"
  },
  "src::browser.html.element.getStyle": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.html.element.getStyle(<HTMLElement> el , <string|array> prop , <boolean> inline)",
    "standard": true,
    "importNames": [
      "src::is.array",
      "src::browser.html.element.getStyle"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isArray,getStyle;\n    \n                    let var_init_locked_1608956298719;\n    \n                    \n\n                    function main(el , prop , inline){\n\n        \n/**\n * \n * 获得元素元素样式属性值\n * \n * @import is.array\n * \n * @import getStyle from browser.html.element.getStyle\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string|array} prop 属性名称\n * \n * @param {boolean} [inline = false] 是否获取内联样式值\n * \n * @return {mixed} 样式属性值\n * \n */\n\nif(isArray(prop)){\n\n    let values = {},\n        props = prop;\n    \n    for(let prop of props){\n\n        values[prop] = getStyle(el , prop , inline) ;\n    }\n\n    return values ;\n\n}\n\nif(inline){\n\n    return el.style.getPropertyValue(prop);\n\n}else{\n\n    style = window.getComputedStyle(el , null);\n\n    if(style){\n\n        return style[prop] ;\n\n    }else{\n\n        return getStyle(el , prop , true) ;\n    }\n}\n\n    }\n    \n                    return function(el , prop , inline = false){\n    \n                        \n        if(!var_init_locked_1608956298719){\n\n            isArray = include('src::is.array');\ngetStyle = include('src::browser.html.element.getStyle');\n\n            var_init_locked_1608956298719 = true ;\n        }\n        \n    \n                        return main.call(this , el , prop , inline) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.getStyle"
  },
  "src::browser.html.element.isStyle": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::browser.html.element.isStyle(<HTMLElement> el , <string> prop , <mixed> value)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.getStyle"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getStyle;\n    \n                    let var_init_locked_1608956298716;\n    \n                    \n\n                    function main(el , prop , value){\n\n        /**\n * \n * 判断元素的样式属性是否为指定值\n * \n * @import getStyle from browser.html.element.getStyle\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} prop 属性名称\n * \n * @param {mixed} value 样式属性值\n * \n * @return {boolean} 如果样式值匹配则返回 true , 否则返回 false\n * \n */\n\nreturn getStyle(el , prop) === value ;\n\n\n    }\n    \n                    return function(el , prop , value){\n    \n                        \n        if(!var_init_locked_1608956298716){\n\n            getStyle = include('src::browser.html.element.getStyle');\n\n            var_init_locked_1608956298716 = true ;\n        }\n        \n    \n                        return main.call(this , el , prop , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.isStyle"
  },
  "src::browser.html.element.getWidth": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::browser.html.element.getWidth(<HTMLElement> el)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.isStyle"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isStyle;\n    \n                    let var_init_locked_1608956298714;\n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 获得元素的宽度\n * \n * @import isStyle from browser.html.element.isStyle\n * \n * @param {HTMLElement} el 作用元素\n * \n * @return {number} 元素的宽度 \n * \n */\n\nif(isStyle(el , 'display' , 'none')){\n\n    return 0 ;\n}\n\ntry{\n\n    let {\n        left,\n        right\n    } = el.getBoundingClientRect() ;\n\n    return right - left ;\n\n}catch(err){\n\n\n}\n\nreturn el.offsetWidth ;\n\n\n\n    }\n    \n                    return function(el){\n    \n                        \n        if(!var_init_locked_1608956298714){\n\n            isStyle = include('src::browser.html.element.isStyle');\n\n            var_init_locked_1608956298714 = true ;\n        }\n        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.getWidth"
  },
  "src::browser.html.element.getHeight": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::browser.html.element.getHeight(<HTMLElement> el)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.isStyle"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isStyle;\n    \n                    let var_init_locked_1608956298722;\n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 获取元素的高度\n * \n * @import isStyle from browser.html.element.isStyle\n * \n * @param {HTMLElement} el 作用元素\n * \n * @return {number} 元素的高度 \n * \n */\n\n\nif(isStyle(el , 'display' , 'none')){\n\n    return 0 ;\n}\n\nif(el === document.body){\n\n    return document.body.clientHeight ;\n}\n\ntry{\n\n    let {\n        top,\n        bottom\n    } = el.getBoundingClientRect() ;\n\n    return top - bottom ;\n\n}catch(err){\n\n\n}\n\nreturn el.offsetHeight ;\n\n    }\n    \n                    return function(el){\n    \n                        \n        if(!var_init_locked_1608956298722){\n\n            isStyle = include('src::browser.html.element.isStyle');\n\n            var_init_locked_1608956298722 = true ;\n        }\n        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.getHeight"
  },
  "src::browser.html.element.getSize": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.html.element.getSize(<HTMLElement> el)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.getWidth",
      "src::browser.html.element.getHeight"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getWidth,getHeight;\n    \n                    let var_init_locked_1608956298712;\n    \n                    \n\n                    function main(el){\n\n        \n/**\n * \n * 获得元素的尺寸\n * \n * @import getWidth from browser.html.element.getWidth\n * \n * @import getHeight from browser.html.element.getHeight\n * \n * @param {HTMLElement} el 作用元素\n * \n * @return {object} 尺寸\n * \n */\n\nreturn{\n    width:getWidth(el),\n    height:getHeight(el)\n} ;\n\n\n    }\n    \n                    return function(el){\n    \n                        \n        if(!var_init_locked_1608956298712){\n\n            getWidth = include('src::browser.html.element.getWidth');\ngetHeight = include('src::browser.html.element.getHeight');\n\n            var_init_locked_1608956298712 = true ;\n        }\n        \n    \n                        return main.call(this , el) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.getSize"
  },
  "src::browser.html.element.position": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.html.element.position(<HTMLElement> el , <string> pos , <number> zIndex , <number> x , <number> y)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.isStyle",
      "src::browser.html.element.setStyle",
      "src::is.defined",
      "src::browser.html.element.setXY"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isStyle,setStyle,isDefined,setXY;\n    \n                    let var_init_locked_1608956298728;\n    \n                    \n\n                    function main(el , pos , zIndex , x , y){\n\n        \n/**\n * \n * 设置元素定位方式\n * \n * @import isStyle from browser.html.element.isStyle\n * \n * @import setStyle from browser.html.element.setStyle\n * \n * @import is.defined\n * \n * @import setXY from browser.html.element.setXY\n * \n * @param {HTMLElement} el 作用元素\n * \n * @param {string} [pos] 定位方式\n * \n * @param {number} [zIndex] 层次设置\n * \n * @param {number} [x] 横坐标\n * \n * @param {number} [y] 纵坐标\n * \n * @return {mixed} 返回说明 \n * \n */\n\nif(el !== document && el !== document.body){\n\n    if(!pos && isStyle(el , 'position' , 'static')){\n    \n        setStyle(el , 'position' , 'relative') ;\n    \n    }else if(pos){\n\n        setStyle(el , 'position' , pos) ;\n    }\n\n    if(isDefined(zIndex)){\n\n        setStyle(el , 'zindex' , zIndex) ;\n    }\n\n    if(x || y){\n\n        setXY(el , x || false , y || false) ;\n    }\n}\n\n\n    }\n    \n                    return function(el , pos , zIndex , x , y){\n    \n                        \n        if(!var_init_locked_1608956298728){\n\n            isStyle = include('src::browser.html.element.isStyle');\nsetStyle = include('src::browser.html.element.setStyle');\nisDefined = include('src::is.defined');\nsetXY = include('src::browser.html.element.setXY');\n\n            var_init_locked_1608956298728 = true ;\n        }\n        \n    \n                        return main.call(this , el , pos , zIndex , x , y) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.position"
  },
  "src::browser.html.element.setStyle": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.html.element.setStyle(<HTMLElement> el , <string|object> prop , <mixed> value)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::browser.html.element.setStyle"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,setStyle;\n    \n                    let var_init_locked_1608956298731;\n    \n                    \n\n                    function main(el , prop , value){\n\n        \n/**\n * \n * 设置元素样式\n * \n * @import is.string\n * \n * @import setStyle from browser.html.element.setStyle\n * \n * @param {HTMLElement} el 作用元素\n * \n * @param {string|object} prop 属性名称\n * \n * @param {mixed} [value] 属性值\n * \n */\n\nif(isString(prop)){\n\n    el.style.setProperty(prop , value) ;\n\n}else{\n\n    let names = Object.keys(prop) ;\n\n    for(let name of names){\n\n        setStyle(el , name , prop[name]) ;\n    }\n}\n\n    }\n    \n                    return function(el , prop , value){\n    \n                        \n        if(!var_init_locked_1608956298731){\n\n            isString = include('src::is.string');\nsetStyle = include('src::browser.html.element.setStyle');\n\n            var_init_locked_1608956298731 = true ;\n        }\n        \n    \n                        return main.call(this , el , prop , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.setStyle"
  },
  "src::browser.html.element.translateXY": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.html.element.translateXY(<HTMLElement> el , <number> x , <number> y)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.getStyle",
      "src::browser.html.element.getXY",
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getStyle,getXY,isNumber;\n    \n                    let var_init_locked_1608956298739;\n    \n                    \n\n                    function main(el , x , y){\n\n        \n/**\n * \n * 转换元素坐标值\n * \n * @import getStyle from browser.html.element.getStyle\n * \n * @import getXY from browser.html.element.getXY\n * \n * @import is.number\n * \n * @param {HTMLElement} el 作用元素\n * \n * @param {number} x 横坐标\n * \n * @param {number} y 纵坐标\n * \n * @return {object} 转换后的坐标值 \n * \n */\n\nlet {\n    position,\n    left,\n    top\n} = getStyle(el , [\n        'position',\n        'top',\n        'left'\n    ]),\nisRelative = position === 'relative',\n{\n    x:orignX,\n    y:orginY\n} = getXY(el);\n\nleft = parseFloat(left) ;\n\ntop = parseFloat(top) ;\n \nif(isNaN(left)){\n    \n    left = isRelative ? 0 : el.offsetLeft;\n}\n\nif(isNaN(top)){\n\n    top = isRelative ? 0 : el.offsetTop;\n}\n\nreturn {\n    x: x - orignX + left,\n    y: y - orginY + top\n};\n\n    }\n    \n                    return function(el , x , y){\n    \n                        \n        if(!var_init_locked_1608956298739){\n\n            getStyle = include('src::browser.html.element.getStyle');\ngetXY = include('src::browser.html.element.getXY');\nisNumber = include('src::is.number');\n\n            var_init_locked_1608956298739 = true ;\n        }\n        \n    \n                        return main.call(this , el , x , y) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.translateXY"
  },
  "src::browser.html.element.translatePoints": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::browser.html.element.translatePoints(<HTMLElement> el , <number> x , <number> y)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.translateXY"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let translateXY;\n    \n                    let var_init_locked_1608956298736;\n    \n                    \n\n                    function main(el , x , y){\n\n        \n/**\n * \n * 转换元素坐标值\n * \n * @import translateXY from browser.html.element.translateXY\n * \n * @param {HTMLElement} el 作用元素\n * \n * @param {number} x 横坐标\n * \n * @param {number} y 纵坐标\n * \n * @return {object} 转换后的坐标值 \n * \n */\n\nlet {\n    x:left,\n    y:top\n} = translateXY(el , x , y) ;\n\nreturn {\n    left,\n    top\n} ;\n\n    }\n    \n                    return function(el , x , y){\n    \n                        \n        if(!var_init_locked_1608956298736){\n\n            translateXY = include('src::browser.html.element.translateXY');\n\n            var_init_locked_1608956298736 = true ;\n        }\n        \n    \n                        return main.call(this , el , x , y) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.translatePoints"
  },
  "src::browser.html.element.setXY": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.html.element.setXY(<HTMLElement> el , <number> x , <number> y)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.translatePoints",
      "src::browser.html.element.position"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let translatePoints,position;\n    \n                    let var_init_locked_1608956298734;\n    \n                    \n\n                    function main(el , x , y){\n\n        \n/**\n * \n * 设置元素坐标\n * \n * @import translatePoints from browser.html.element.translatePoints\n * \n * @import position from browser.html.element.position\n * \n * @param {HTMLElement} el 作用元素\n * \n * @param {number} x 横坐标\n * \n * @param {number} y 纵坐标\n * \n */\n\nlet {\n    top,\n    left\n} = translatePoints(el , x , y),\n{\n    style\n} = el,\npos;\n\nposition(el) ;\n\nstyle.top = `${top}px` ;\n\nstyle.left = `${left}px` ;\n\n    }\n    \n                    return function(el , x , y){\n    \n                        \n        if(!var_init_locked_1608956298734){\n\n            translatePoints = include('src::browser.html.element.translatePoints');\nposition = include('src::browser.html.element.position');\n\n            var_init_locked_1608956298734 = true ;\n        }\n        \n    \n                        return main.call(this , el , x , y) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.setXY"
  },
  "src::browser.html.element.style.get": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::browser.html.element.style.get(<HTMLElement> el , <string> prop)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el , prop){\n\n        /**\n * \n * 获得元素元素样式属性值\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} prop 属性名称\n * \n * @return {mixed} 样式属性值\n * \n */\n\nlet cs = window.getComputedStyle(el , '') ;\n\nif(cs){\n\n   return cs[prop] ;\n}\n\n    }\n    \n                    return function(el , prop){\n    \n                        \n    \n                        return main.call(this , el , prop) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.style.get"
  },
  "src::browser.html.element.style.is": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::browser.html.element.style.is(<HTMLElement> el , <string> prop , <mixed> value)",
    "standard": true,
    "importNames": [
      "src::browser.html.element.style.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956298743;\n    \n                    \n\n                    function main(el , prop , value){\n\n        /**\n * \n * 判断元素的样式属性是否为指定值\n * \n * @import get from browser.html.element.style.get\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} prop 属性名称\n * \n * @param {mixed} value 样式属性值\n * \n * @return {boolean} 如果样式值匹配则返回 true , 否则返回 false\n * \n */\n\nreturn get(prop) === value ;\n\n    }\n    \n                    return function(el , prop , value){\n    \n                        \n        if(!var_init_locked_1608956298743){\n\n            get = include('src::browser.html.element.style.get');\n\n            var_init_locked_1608956298743 = true ;\n        }\n        \n    \n                        return main.call(this , el , prop , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.style.is"
  },
  "src::browser.html.element.style.set": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.html.element.style.set(<HTMLElement> el , <string> prop , <mixed> value)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(el , prop , value){\n\n        /**\n * \n * 设置元素元素样式属性值\n * \n * @param {HTMLElement} el 元素\n * \n * @param {string} prop 属性名称\n * \n * @param {mixed} value 样式属性值\n * \n * \n */\n\nel.style.setProperty(prop , value) ;\n\n    }\n    \n                    return function(el , prop , value){\n    \n                        \n    \n                        return main.call(this , el , prop , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.element.style.set"
  },
  "src::browser.html.focus.text": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::browser.html.focus.text(<HTMLElement> inputEl , <boolean> isCursorEnd)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(inputEl , isCursorEnd){\n\n        \n/**\n * \n * 文本类控件获取焦点\n * \n * @param {HTMLElement} inputEl 文本类控件\n * \n * @param {boolean} [isCursorEnd = true] 是否将光标置为输入框最后\n * \n */\n\nlet len = inputEl.value.length ;\n\ninputEl.setSelectionRange(len , len) ;\n\ninputEl.focus() ;\n\n\n    }\n    \n                    return function(inputEl , isCursorEnd = true){\n    \n                        \n    \n                        return main.call(this , inputEl , isCursorEnd) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.focus.text"
  },
  "src::browser.html.iframe": {
    "meta": "code.meta.script.function",
    "signature": "<Window> src::browser.html.iframe(<HTMLElement> iframeEl)",
    "standard": true,
    "importNames": [
      "src::is.html.iframe"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isHtmlIframe;\n    \n                    let var_init_locked_1608956298752;\n    \n                    \n\n                    function main(iframeEl){\n\n        /**\n * \n * 获得 iframe 的 contentWindow 引用\n * \n * @import is.html.iframe\n * \n * @param {HTMLElement} iframeEl iframe元素引用\n * \n * @return {Window}\n * \n */\n\nif(!isHtmlIframe(iframeEl)){\n\n    return ;\n}\n\nreturn new Promise(callback =>{\n\n    switch(iframeEl.readyState){\n\n        case 'complete':\n        case 'loaded':\n\n            callback(iframeEl) ;\n\n            break ;\n\n        default:\n        \n            iframeEl.addEventListener('load' , () =>{\n\n                callback(iframeEl) ;\n\n            }) ;\n    }\n\n}) ;\n\n    }\n    \n                    return function(iframeEl){\n    \n                        \n        if(!var_init_locked_1608956298752){\n\n            isHtmlIframe = include('src::is.html.iframe');\n\n            var_init_locked_1608956298752 = true ;\n        }\n        \n    \n                        return main.call(this , iframeEl) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "browser.html.iframe"
  },
  "src::object.assign.if": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::object.assign.if(<object> dest , <object> ...sources)",
    "standard": true,
    "importNames": [
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject;\n    \n                    let var_init_locked_1608956298757;\n    \n                    \n\n                    \n/**\n * \n * 懒惰深度合并\n * \n * @import isObject from is.object.simple\n * \n * @param {object} dest 目标数据\n * \n * @param {object} [...sources] 来源数据\n * \n * @return {object} 合并后数据\n * \n * @scoped\n * \n */\n\nfunction assign(dest , source){\n\n    if(isObject(dest) && isObject(source)){\n\n        let names = Object.keys(source) ;\n\n        for(let name of names){\n\n            if(!dest.hasOwnProperty(name)){\n\n                dest[name] = source[name] ;\n            \n            }else{\n\n                assign(dest[name] , source[name]) ;\n            }\n        }\n    }\n\n    return source ;\n}\n\nfunction main(dest , ...sources){\n\n    for(let source of sources){\n\n        assign(dest , source) ;\n    }\n\n    return dest ;\n\n}\n    \n                    return function(dest , ...sources){\n    \n                        \n        if(!var_init_locked_1608956298757){\n\n            isObject = include('src::is.object.simple');\n\n            var_init_locked_1608956298757 = true ;\n        }\n        \n    \n                        return main.call(this , dest , ...sources) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.assign.if"
  },
  "src::object.contains": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::object.contains(<object> target , <object> item)",
    "standard": true,
    "importNames": [
      "src::object.keys"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getKeys;\n    \n                    let var_init_locked_1608956298764;\n    \n                    \n\n                    function main(target , item){\n\n        /**\n * \n * 判断是否完全包含指定项\n * \n * @import getKeys from object.keys\n * \n * @param {object} target 目标对象\n * \n * @param {object} item 被包含对象\n * \n * @return {boolean} 被包含对象的所有数据都包含在目标对象中则返回 true , 否则返回 false\n * \n */\n\nlet keys = getKeys(item),\n    targetKeys = getKeys(target);\n\nfor(let key of keys){\n\n    if(!targetKeys.includes(key) || get(target , key) !== get(item , key)){\n\n        return false ;\n    }\n}\n\nreturn true ;\n\n    }\n    \n                    return function(target , item){\n    \n                        \n        if(!var_init_locked_1608956298764){\n\n            getKeys = include('src::object.keys');\n\n            var_init_locked_1608956298764 = true ;\n        }\n        \n    \n                        return main.call(this , target , item) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.contains"
  },
  "src::object.key.join": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::object.key.join(<array> ...keys)",
    "standard": true,
    "importNames": [
      "src::is.string"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString;\n    \n                    let var_init_locked_1608956298769;\n    \n                    \n\n                    \n/**\n * \n * 将多个键值连接起来\n * \n * @import is.string\n * \n * @param {array} [...keys] 一组键值\n * \n * @return {string} 连接后的键值 \n * \n */\n\nconst suffixRe = /(?:^\\.+)|(?:\\.+$)/g ;\n\nfunction main(...keys){\n\n    let result = [] ;\n\n    for(let key of keys){\n\n        if(isString(key)){\n\n            key = key.replace(suffixRe , '') ;\n\n            if(key){\n\n                result.push(key) ;\n            }\n        }\n    }\n\n    return result.join('.').trim() ;\n}\n\n\n    \n                    return function(...keys){\n    \n                        \n        if(!var_init_locked_1608956298769){\n\n            isString = include('src::is.string');\n\n            var_init_locked_1608956298769 = true ;\n        }\n        \n    \n                        return main.call(this , ...keys) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.key.join"
  },
  "src::object.keys": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::object.keys(<object> data)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::object.key.join"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,join;\n    \n                    let var_init_locked_1608956298766;\n    \n                    \n\n                    /**\n * \n * 获取对象的键值组合\n * \n * @import isObject from is.object.simple\n * \n * @import join from object.key.join\n * \n * @param {object} data 对象\n * \n * @return {array} 键值数组\n * \n * @scoped\n * \n */\n\nfunction main(data){\n\n   return get_keys(data) ;\n}\n\nfunction get_keys(data , rootKey){\n\n    let result = [] ;\n\n    if(isObject(data)){\n\n        let keys = Object.keys(data) ;\n\n        for(let key of keys){\n\n            result.push(...get_keys(data[key] , join(rootKey , key))) ;\n        }\n    \n    }else if(rootKey){\n\n        result.push(rootKey) ;\n    }\n\n    return result ;\n}\n\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298766){\n\n            isObject = include('src::is.object.simple');\njoin = include('src::object.key.join');\n\n            var_init_locked_1608956298766 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.keys"
  },
  "src::object.data.has": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::object.data.has(<mixed> target , <string> name)",
    "standard": true,
    "importNames": [
      "src::object.data.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getName;\n    \n                    let var_init_locked_1608956298771;\n    \n                    \n\n                    function main(target , name){\n\n        \n/**\n * \n * 判断当前元素是否拥有指定的属性值\n * \n * @import getName from object.data.name\n * \n * @param {mixed} target 作用对象\n * \n * @param {string} name 属性名称\n * \n * @return {boolean} 如果属性值存在则返回 true ，否则返回 false\n * \n */\n\nreturn target.hasOwnProperty(getName(name)) ;\n\n\n    }\n    \n                    return function(target , name){\n    \n                        \n        if(!var_init_locked_1608956298771){\n\n            getName = include('src::object.data.name');\n\n            var_init_locked_1608956298771 = true ;\n        }\n        \n    \n                        return main.call(this , target , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.data.has"
  },
  "src::object.flat": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::object.flat(<object> data)",
    "standard": true,
    "importNames": [
      "src::object.key.join",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let join,isObject;\n    \n                    let var_init_locked_1608956298776;\n    \n                    \n\n                    \n/**\n * \n * 将对象扁平化处理\n * \n * @import join from object.key.join\n * \n * @import isObject from is.object.simple\n * \n * @param {object} data 对象\n * \n * @return {object} 扁平化后的对象 \n * \n */\n\nfunction main(data){\n\n    return flat(data) ;\n }\n \n function flat(data , rootKey){\n \n     let result = {} ;\n \n     if(isObject(data)){\n \n         let keys = Object.keys(data) ;\n \n         for(let key of keys){\n \n             Object.assign(result , flat(data[key] , join(rootKey , key))) ;\n         }\n     \n     }else if(rootKey){\n \n         result[rootKey] = data ;\n     }\n \n     return result ;\n}\n\n \n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298776){\n\n            join = include('src::object.key.join');\nisObject = include('src::is.object.simple');\n\n            var_init_locked_1608956298776 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.flat"
  },
  "src::object.freeze": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::object.freeze(<object> data , <boolean> deep)",
    "standard": true,
    "importNames": [
      "src::is.object.simple",
      "src::is.array"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,isArray;\n    \n                    let var_init_locked_1608956298778;\n    \n                    \n\n                    /**\n * \n * 将对象进行冻结\n * \n * @param {object} data 作用对象\n * \n * @param {boolean} [deep = false] 是否深层遍历\n * \n * @return {object} 冻结后的对象\n * \n * @import isObject from is.object.simple\n * \n * @import is.array\n * \n */\n\nfunction main(data , deep){\n\n    if((isObject(data) || isArray(data)) && !Object.isFrozen(data)){\n\n        if(deep){\n\n            let names = Object.keys(data) ;\n\n            for(let name of names){\n\n                main(data[name] , keep) ;\n            }\n        }\n    }\n\n    return data ;\n}\n\n\n    \n                    return function(data , deep = false){\n    \n                        \n        if(!var_init_locked_1608956298778){\n\n            isObject = include('src::is.object.simple');\nisArray = include('src::is.array');\n\n            var_init_locked_1608956298778 = true ;\n        }\n        \n    \n                        return main.call(this , data , deep) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.freeze"
  },
  "src::object.property.undefine": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.property.undefine(<object> target , <string> name)",
    "standard": true,
    "importNames": [
      "src::object.property.inner.name"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let innerName;\n    \n                    let var_init_locked_1608956298787;\n    \n                    \n\n                    function main(target , name){\n\n        /**\n * \n * 取消定义一个属性\n * \n * @import innerName from .inner.name\n * \n * @param {object} target 目标对象\n * \n * @param {string} name 属性名称\n * \n */\n\n delete target[name] ;\n\n delete target[innerName(name)] ;\n\n\n\n    }\n    \n                    return function(target , name){\n    \n                        \n        if(!var_init_locked_1608956298787){\n\n            innerName = include('src::object.property.inner.name');\n\n            var_init_locked_1608956298787 = true ;\n        }\n        \n    \n                        return main.call(this , target , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.property.undefine"
  },
  "src::object.proxy.fly": {
    "meta": "code.meta.script.function",
    "signature": "<object.Proxy> src::object.proxy.fly(<mixed> target)",
    "standard": true,
    "importNames": [
      "src::object.proxy"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let createProxy;\n    \n                    let var_init_locked_1608956298789;\n    \n                    \n\n                    \n/**\n * \n * 构建一个共享对象代理\n * \n * @import createProxy from object.proxy\n * \n * @param {mixed} target 需要代理的对象\n * \n * @return {object.Proxy} 代理\n * \n */\n\n let proxy ;\n\n function main(target){\n\n    if(!proxy){\n\n        proxy = createProxy() ;\n    }\n\n    proxy.target = target ;\n\n    return proxy ;\n }\n    \n                    return function(target){\n    \n                        \n        if(!var_init_locked_1608956298789){\n\n            createProxy = include('src::object.proxy');\n\n            var_init_locked_1608956298789 = true ;\n        }\n        \n    \n                        return main.call(this , target) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.proxy.fly"
  },
  "src::object.value.set": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::object.value.set(<object> target , <string> key , <mixed> value)",
    "standard": true,
    "importNames": [
      "src::is.object",
      "src::string.split"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,split;\n    \n                    let var_init_locked_1608956298794;\n    \n                    \n\n                    /**\n * \n * 设置对象的属性值\n * \n * @import is.object\n * \n * @import split from string.split\n * \n * @param {object} target 目标对象\n * \n * @param {string} key 属性名称\n * \n * @param {mixed} value 属性值\n * \n * @scoped\n * \n */\n\nconst splitRe = /\\./;\n\nfunction main(target , key , value){\n\n    if(splitRe.test(key)){\n\n        let keys = split(key , splitRe) ;\n    \n        key = keys.pop();\n    \n        for(let key of keys){\n    \n            let data = target[key] ;\n    \n            if(!isObject(data)){\n    \n                data = target[key] = {} ;\n            }\n    \n            target = data ;\n        }\n    \n        target[key] = value ;\n    \n    }else{\n    \n        target[key] = value ;\n    }\n}   \n    \n                    return function(target , key , value){\n    \n                        \n        if(!var_init_locked_1608956298794){\n\n            isObject = include('src::is.object');\nsplit = include('src::string.split');\n\n            var_init_locked_1608956298794 = true ;\n        }\n        \n    \n                        return main.call(this , target , key , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "object.value.set"
  },
  "src::class.name": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::class.name(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.object"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject;\n    \n                    let var_init_locked_1608956298797;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 获得类名称\n * \n * @import is.object\n * \n * @param {mixed} data 类对象\n * \n * @return {string} 类名称 \n * \n */\n\n if(isObject(data)){\n\n    return data.__ZBEE_CLASS_NAME__ ;\n }\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298797){\n\n            isObject = include('src::is.object');\n\n            var_init_locked_1608956298797 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "class.name"
  },
  "src::date.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::date.constructor(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::date.format.discern"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,discernDateFormatString;\n    \n                    let var_init_locked_1613308340091;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 初始化日期时间对象\n * \n * @import is.string\n * \n * @import discernDateFormatString from date.format.discern\n * \n * @param {mixed} data 日期时间数据\n * \n * @require dayjs\n * \n */\n\n const dayjs = require('dayjs') ;\n\n let me = this,\n    dateFormatString = discernDateFormatString(data) ;\n\nme.dateFormatString = dateFormatString ;\n\nif(isString(data)){\n\n    me.date = dayjs(data , dateFormatString) ;\n\n}else{\n\n    me.date = dayjs(data) ;\n}\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1613308340091){\n\n            isString = include('src::is.string');\ndiscernDateFormatString = include('src::date.format.discern');\n\n            var_init_locked_1613308340091 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.constructor"
  },
  "src::date.format": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::date.format(<Date> date , <string> format)",
    "standard": true,
    "importNames": [],
    "dependentModules": {
      "date-and-time": "^0.11.0"
    },
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    \n/**\n * \n * 日期时间格式化\n * \n * @param {Date} date 日期时间对象\n * \n * @param {string} [format = 'yyyy-mm-dd'] 日期时间格式化字符串\n * \n * @return {string} 根据格式化字符串输出的日期数据\n * \n * @require date-and-time\n *\n * @scoped\n *  \n */\n\nconst {\n    format:doFormat\n} = require('date-and-time') ;\n\nfunction main(date , format){\n\n    return doFormat(date , format) ;\n}\n\n\n    \n                    return function(date , format = 'yyyy-mm-dd'){\n    \n                        \n    \n                        return main.call(this , date , format) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.format"
  },
  "src::date.get": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::date.get({<number> year , <number> month , <number> day , <number> hours , <number> minutes , <number> seconds})",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956298802;\n    \n                    \n\n                    function main({year , month , day , hours , minutes , seconds}){\n\n        \n/**\n * \n * 获得日期对象\n * \n * @import is.defined\n * \n * @param {object} [config = {}] 日期配置\n * \n * @param {number} [config.year] 年份\n * \n * @param {number} [config.month] 月份\n * \n * @param {number} [config.day] 日\n * \n * @param {number} [config.hours] 小时\n * \n * @param {number} [config.minutes] 分钟\n * \n * @param {number} [config.seconds] 秒\n * \n * @return {Date} 日期对象 \n * \n */\n\n let data = new Date() ;\n\n data.setMonth(0) ;\n\n data.setDate(1) ;\n\n data.setMilliseconds(0) ;\n\n if(isDefined(year)){\n\n   data.setFullYear(year) ;\n }\n\n if(isDefined(month)){\n\n   data.setMonth(month - 1) ;\n }\n\n if(isDefined(day)){\n\n   data.setDate(day) ;\n \n }\n\n if(isDefined(hours)){\n\n   data.setHours(hours) ;\n }\n\n if(isDefined(minutes)){\n\n   data.setMinutes(minutes) ;\n }\n\n if(isDefined(seconds)){\n\n   data.setSeconds(seconds) ;\n }\n\n return data ;\n\n\n\n    }\n    \n                    return function({year , month , day , hours , minutes , seconds} = {}){\n    \n                        \n        if(!var_init_locked_1608956298802){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956298802 = true ;\n        }\n        \n    \n                        return main.call(this , {year , month , day , hours , minutes , seconds}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.get"
  },
  "src::date.hours": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::date.hours()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 获得小时数\n * \n * @return {number} 小时数 \n * \n */\n\n return this.date.hour() ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.hours"
  },
  "src::date.list": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::date.list(<Date> startDate , <Date> endDate , <number> count , <boolean> isNumber)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(startDate , endDate , count , isNumber){\n\n        \n/**\n * \n * 生成日期列表\n * \n * @param {Date} startDate 起始日期\n * \n * @param {Date} endDate 终止日期\n * \n * @param {number} count 生成个数\n * \n * @param {boolean} [isNumber = true] 是否以数字方式取代日期对象\n * \n * @return {array} 日期列表\n * \n */\n\nlet startTime = startDate.getTime(),\nendTime = endDate.getTime(),\ncountTime = endTime - startTime ;\n\nif(countTime % count !== 0){\n\n   return [] ;\n}\n\nlet time = countTime / count ;\n\nif(time === 0){\n\n   return [] ;\n}\n\nlet result = [];\n\nfor(let i = startTime ; i <= endTime ; i += time){\n\n   result.push(i) ;\n}\n\nif(!isNumber){\n\nfor(let i = 0 ; i < count ; i ++){\n\n   result[i] = new Date(result[i]) ;\n}\n}\n\nreturn result ;\n\n    }\n    \n                    return function(startDate , endDate , count , isNumber = true){\n    \n                        \n    \n                        return main.call(this , startDate , endDate , count , isNumber) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.list"
  },
  "src::date.minute.add": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::date.minute.add(<number> value)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(value){\n\n        \n/**\n * \n * 分钟增量\n * \n * @param {number} value 增量值\n * \n */\n\n let me = this,\n {\n    date\n } = me ;\n\n me.date = date.add(value , 'minute') ;\n\n    }\n    \n                    return function(value){\n    \n                        \n    \n                        return main.call(this , value) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.minute.add"
  },
  "src::date.minutes": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::date.minutes()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 获得分钟数\n * \n * @return {number} 分钟数 \n * \n */\n\nreturn this.date.minute() ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.minutes"
  },
  "src::date.next.week": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::date.next.week(<Date|object> date)",
    "standard": true,
    "importNames": [
      "src::date.next"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let next;\n    \n                    let var_init_locked_1608956298807;\n    \n                    \n\n                    function main(date){\n\n        \n/**\n * \n * 基于当前日期的下一周的日期\n * \n * @import next from date.next\n * \n * @param {Date | object} date 基准日期\n * \n * @return {Date} 移过的日期 \n * \n */\n\n return next(date , 7) ;\n\n \n\n    }\n    \n                    return function(date){\n    \n                        \n        if(!var_init_locked_1608956298807){\n\n            next = include('src::date.next');\n\n            var_init_locked_1608956298807 = true ;\n        }\n        \n    \n                        return main.call(this , date) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.next.week"
  },
  "src::date.next": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::date.next(<Date|object> date , <number> step)",
    "standard": true,
    "importNames": [
      "src::date.get",
      "src::date.get.properties",
      "src::is.date"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,getProperty,isDate;\n    \n                    let var_init_locked_1608956298808;\n    \n                    \n\n                    function main(date , step){\n\n        /**\n * \n * 基于当前日历向后移一次\n * \n * @import get from date.get\n * \n * @import getProperty from date.get.properties\n * \n * @import is.date\n * \n * @param {Date | object} date 基准日期\n * \n * @param {number} [step = 1] 步长\n * \n * @return {Date} 移过的日期 \n * \n */\n\n if(isDate(date)){\n\n   date = getProperty(date , [\n     'year',\n     'month',\n     'day'\n   ]) ;\n }\n\n let {\n   day,\n   ...other\n } = date ;\n\n day += step ;\n\n return get({\n   day,\n   ...other\n }) ;\n\n    }\n    \n                    return function(date , step = 1){\n    \n                        \n        if(!var_init_locked_1608956298808){\n\n            get = include('src::date.get');\ngetProperty = include('src::date.get.properties');\nisDate = include('src::is.date');\n\n            var_init_locked_1608956298808 = true ;\n        }\n        \n    \n                        return main.call(this , date , step) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.next"
  },
  "src::date.prev.week": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::date.prev.week(<Date|object> date)",
    "standard": true,
    "importNames": [
      "src::date.prev"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let prev;\n    \n                    let var_init_locked_1608956298810;\n    \n                    \n\n                    function main(date){\n\n        \n/**\n * \n * 基于当前日期的上一周的日期\n * \n * @import prev from date.prev\n * \n * @param {Date | object} date 基准日期\n * \n * @return {Date} 移过的日期 \n * \n */\n\nreturn prev(date , 7) ;\n\n\n    }\n    \n                    return function(date){\n    \n                        \n        if(!var_init_locked_1608956298810){\n\n            prev = include('src::date.prev');\n\n            var_init_locked_1608956298810 = true ;\n        }\n        \n    \n                        return main.call(this , date) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.prev.week"
  },
  "src::date.prev": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::date.prev(<Date> date , <number> step)",
    "standard": true,
    "importNames": [
      "src::date.get",
      "src::date.get.properties",
      "src::is.date"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,getProperty,isDate;\n    \n                    let var_init_locked_1608956298812;\n    \n                    \n\n                    function main(date , step){\n\n        /**\n * \n * 基于当前日历向前移一次\n * \n * @import get from date.get\n * \n * @import getProperty from date.get.properties\n * \n * @import is.date\n * \n * @param {Date} date 基准日期\n * \n * @param {number} [step = 1] 步长\n * \n * @return {Date} 移过的日期 \n * \n */\n\nif(isDate(date)){\n\n   date = getProperty(date , [\n      'year',\n      'month',\n      'day'\n   ]) ;\n }\n\n let {\n   day,\n   ...other\n } = date ;\n\n day -= step ;\n\n return get({\n   day,\n   ...other\n }) ;\n\n    }\n    \n                    return function(date , step = 1){\n    \n                        \n        if(!var_init_locked_1608956298812){\n\n            get = include('src::date.get');\ngetProperty = include('src::date.get.properties');\nisDate = include('src::is.date');\n\n            var_init_locked_1608956298812 = true ;\n        }\n        \n    \n                        return main.call(this , date , step) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.prev"
  },
  "src::date.string": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::date.string(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 函数实现说明\n * \n * @param {mixed} data 参数说明\n * \n * @return {mixed} 返回说明 \n * \n */\n\n // 代码实现\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "date.string"
  },
  "src::json.clone": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::json.clone(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 拷贝\n * \n * @param {mixed} data 需要深拷贝的数据\n * \n * @return {mixed} 拷贝后的数据\n * \n */\n\n const {\n    stringify,\n    parse\n } = JSON ;\n\n return parse(stringify(data)) ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "json.clone"
  },
  "src::json.convert": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::json.convert(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 将指定数据转换成简单的数据\n * \n * @param {mixed} data 数据\n * \n * @return {mixed} 简单数据 \n * \n */\n\n try{\n\n    return JSON.parse(JSON.stringify(data)) ;\n\n }catch(err){\n\n\n }\n\n return {} ;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "json.convert"
  },
  "src::json.parse": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::json.parse(<string> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 将 JSON 字符串转换成 JSON 数据\n * \n * @param {string} data JSON 字符串\n * \n * @return {mixed} JSON 数据 \n * \n */\n\ntry{\n\n    return JSON.parse(data) ;\n\n }catch(err){\n\n\n }\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "json.parse"
  },
  "src::json.stringify": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::json.stringify(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * JSON 序列化\n * \n * @param {mixed} data 数据\n * \n * @return {string} JSON 序列化后的字符串 \n * \n */\n\n  try{\n  \n    return JSON.stringify(data);\n  \n  }catch(e){\n  \n  }\n\n  return false;\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "json.stringify"
  },
  "src::math.from": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::math.from(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 函数实现说明\n * \n * @param {mixed} data 参数说明\n * \n * @return {mixed} 返回说明 \n * \n */\n\n // 代码实现\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.from"
  },
  "src::math.point.rect.anchor": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::math.point.rect.anchor({<number> x , <number> y} , {<number> width , <number> height} , <string|array> anchor)",
    "standard": true,
    "importNames": [
      "src::is.array",
      "src::math.point.rect.anchor"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isArray,getAnchor;\n    \n                    let var_init_locked_1608956298825;\n    \n                    \n\n                    function main({x , y} , {width , height} , anchor){\n\n        \n/**\n * \n * 根据坐标获得相应方位的坐标\n * \n * @import is.array\n * \n * @import getAnchor from math.point.rect.anchor\n * \n * @param {object} xy 坐标\n * \n * @param {number} xy.x 横坐标\n * \n * @param {number} xy.y 纵坐标\n * \n * @param {object} size 尺寸\n * \n * @param {number} size.width 宽度\n * \n * @param {number} size.height 高度\n * \n * @param {string|array} [anchor='tl'] 方位\n * \n * @return {object} 方位坐标\n * \n */\n\nif(isArray(anchor)){\n\n    let result = [],\n        xy = {\n            x,\n            y\n        },\n        size = {\n            width,\n            height\n        };\n\n    for(let item of anchor){\n\n        result.push(getAnchor(xy , size , item)) ;\n    }\n\n    return result ;\n\n}else{\n\n    switch(anchor){\n\n        case 'tl':\n    \n            return {\n                x,\n                y\n            } ;\n    \n        case 't':\n    \n            return {\n                x:x + width / 2,\n                y \n            } ;\n    \n        case 'tr':\n    \n            return {\n                x: x + width,\n                y\n            } ;\n    \n        case 'r':\n    \n            return {\n                x: x + width,\n                y: y + height / 2\n            } ;\n    \n        case 'br':\n    \n            return {\n                x: x + width,\n                y : y + height\n            } ;\n    \n        case 'b':\n    \n            return {\n                x: x + width / 2,\n                y: y + height\n            } ;\n    \n        case 'bl':\n    \n            return {\n                x,\n                y: y + height\n            } ;\n    \n        case 'l':\n    \n            return {\n                x,\n                y: y + height / 2\n            } ;\n    \n        case 'c':\n    \n            return {\n                x : x + width / 2,\n                y: y + height / 2\n            } ;\n    }\n}\n\n\n\n    }\n    \n                    return function({x , y} , {width , height} , anchor = 'tl'){\n    \n                        \n        if(!var_init_locked_1608956298825){\n\n            isArray = include('src::is.array');\ngetAnchor = include('src::math.point.rect.anchor');\n\n            var_init_locked_1608956298825 = true ;\n        }\n        \n    \n                        return main.call(this , {x , y} , {width , height} , anchor) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.point.rect.anchor"
  },
  "src::math.point.rect.anchorBy": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::math.point.rect.anchorBy({<number> x , <number> y} , {<number> width , <number> height} , <string> anchor)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main({x , y} , {width , height} , anchor){\n\n        \n/**\n * \n * 根据方位的坐标推算出真正的坐标\n * \n * @param {object} xy 坐标\n * \n * @param {number} xy.x 横坐标\n * \n * @param {number} xy.y 纵坐标\n * \n * @param {object} size 尺寸\n * \n * @param {number} size.width 宽度\n * \n * @param {number} size.height 高度\n * \n * @param {string} [anchor='tl'] 方位\n * \n * @return {object} 坐标\n * \n */\n\nswitch(anchor){\n\n    case 'tl':\n\n        return {\n            x,\n            y\n        } ;\n\n    case 't':\n\n        return {\n            x:x - width / 2,\n            y \n        } ;\n\n    case 'tr':\n\n        return {\n            x: x - width,\n            y\n        } ;\n\n    case 'r':\n\n        return {\n            x: x - width,\n            y: y - height / 2\n        } ;\n\n    case 'br':\n\n        return {\n            x: x - width,\n            y : y - height\n        } ;\n\n    case 'b':\n\n        return {\n            x: x - width / 2,\n            y: y - height\n        } ;\n\n    case 'bl':\n\n        return {\n            x,\n            y: y - height\n        } ;\n\n    case 'l':\n\n        return {\n            x,\n            y: y - height / 2\n        } ;\n\n    case 'c':\n\n        return {\n            x : x - width / 2,\n            y: y - height / 2\n        } ;\n}\n\n    }\n    \n                    return function({x , y} , {width , height} , anchor = 'tl'){\n    \n                        \n    \n                        return main.call(this , {x , y} , {width , height} , anchor) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.point.rect.anchorBy"
  },
  "src::math.points.circle.border": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::math.points.circle.border({<number> x , <number> y} , <number> radius , <number> startValue , <number> step)",
    "standard": true,
    "importNames": [
      "src::math.degree2radian"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let convert;\n    \n                    let var_init_locked_1608956298833;\n    \n                    \n\n                    function main({x , y} , radius , startValue , step){\n\n        \n/**\n * \n * 计算圆心坐标边上的一系列坐标集合\n * \n * @import convert from math.degree2radian\n * \n * @param {object} xy 圆形坐标\n * \n * @param {number} xy.x 圆形横坐标\n * \n * @param {number} xy.y 圆形纵坐标\n * \n * @param {number} radius 圆的半径\n * \n * @param {number} [startValue = 0] 起始度数值\n * \n * @param {number} [step = 1] 圆边上一系列坐标间隔度数的步长\n * \n * @return {array} 圆边上一系列坐标集合 \n * \n */\n\nconst {\n    sin,\n    cos\n} = Math ;\n\nlet points = [] ;\n\nfor(let degree = startValue ; degree <= 360 ; degree += step){\n\n    let radian = convert(degree) ;\n\n    points.push({\n        degree,\n        x:x + cos(radian) * radius,\n        y:y + sin(radian) * radius\n    }) ;\n}\n\nreturn points ;\n\n    }\n    \n                    return function({x , y} , radius , startValue = 0 , step = 1){\n    \n                        \n        if(!var_init_locked_1608956298833){\n\n            convert = include('src::math.degree2radian');\n\n            var_init_locked_1608956298833 = true ;\n        }\n        \n    \n                        return main.call(this , {x , y} , radius , startValue , step) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.points.circle.border"
  },
  "src::math.points.ellipse.border": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::math.points.ellipse.border(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 函数实现说明\n * \n * @param {mixed} data 参数说明\n * \n * @return {mixed} 返回说明 \n * \n */\n\n // 代码实现\n\n\n    }\n    \n                    return function(data){\n    \n                        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.points.ellipse.border"
  },
  "src::math.radian2degree": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.radian2degree(<number> radian)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(radian){\n\n        \n/**\n * \n * 将弧度转换成角度\n * \n * @param {number} radian 弧度\n * \n * @return {number} 角度\n * \n */\n\nreturn 180 / Math.PI * radian ;\n\n\n\n    }\n    \n                    return function(radian){\n    \n                        \n    \n                        return main.call(this , radian) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.radian2degree"
  },
  "src::math.random.boolean": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::math.random.boolean()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 生成随机的布尔型值\n * \n * @return {boolean} 返回随机布尔值 \n * \n */\n\nreturn Math.random() >= 0.5 ;\n\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.random.boolean"
  },
  "src::math.region.contains.x": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::math.region.contains.x(<object> region , <mixed> position)",
    "standard": true,
    "importNames": [
      "src::math.region.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1613300300121;\n    \n                    \n\n                    function main(region , position){\n\n        \n/**\n * \n * 判断横坐标是否在范围之内\n * \n * @import get from ..get\n * \n * @param {object} region 参照范围\n * \n * @param {mixed} position 位置\n * \n * @return {boolean}  如果指定位置在指定区域之内则返回 true , 否则返回 false \n * \n */\n\nlet {\n    left,\n    right\n } = region,\n {\n    left:positionOLeft,\n    right:positionRight\n } = get(position);\n\n return positionOLeft >= left && positionRight <= right ;\n\n    }\n    \n                    return function(region , position){\n    \n                        \n        if(!var_init_locked_1613300300121){\n\n            get = include('src::math.region.get');\n\n            var_init_locked_1613300300121 = true ;\n        }\n        \n    \n                        return main.call(this , region , position) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.contains.x"
  },
  "src::math.region.from": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::math.region.from(<object> data)",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1608956298846;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 将数据转换成区域类型的对象\n * \n * @import is.defined\n * \n * @param {object} data 数据\n * \n * @return {object} 区域类型的数据 \n * \n */\n\n let {\n    x,\n    y,\n    width,\n    height,\n    top,\n    left,\n    bottom,\n    right\n } = data,\n {\n     length\n } = Object.keys(data);\n\n if(isDefined(x) && isDefined(y) && isDefined(width) && isDefined(height)){\n\n    return {\n        top:y,\n        left:x,\n        right:x + width,\n        bottom:y + height\n    } ;\n\n }else if(isDefined(x) && isDefined(y) && length === 2){\n\n    return {\n        top:y,\n        right:x,\n        left:x,\n        bottom:y\n    } ;\n\n }\n\n return {\n    top,\n    right,\n    bottom,\n    left\n} ;\n\n\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298846){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1608956298846 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.from"
  },
  "src::math.region.get": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::math.region.get(<object> data)",
    "standard": true,
    "importNames": [
      "src::is.object",
      "src::math.region.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isObject,from;\n    \n                    let var_init_locked_1613261554625;\n    \n                    \n\n                    function main(data){\n\n        \n/**\n * \n * 获取范围对象\n * \n * @import is.object\n * \n * @import from from .from\n * \n * @param {object} data 拥有范围信息的对象\n * \n * @return {object} 如果给定对象拥有范围对象的基本属性则直接返回该对象，否则则进行范围对象转换 \n * \n */\n\n if(isObject(data) &&　'top' in data && 'bottom' in data && 'left' in data && 'right' in data && Object.keys(data).length === 4){\n\n    return data ;\n }\n\n return from(data) ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1613261554625){\n\n            isObject = include('src::is.object');\nfrom = include('src::math.region.from');\n\n            var_init_locked_1613261554625 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.get"
  },
  "src::math.region.contains.y": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::math.region.contains.y(<object> region , <mixed> position)",
    "standard": true,
    "importNames": [
      "src::math.region.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1613300300118;\n    \n                    \n\n                    function main(region , position){\n\n        \n/**\n * \n * 判断纵坐标是否在范围之内\n * \n * @import get from ..get\n * \n * @param {object} region 参照范围\n * \n * @param {mixed} position 位置\n * \n * @return {boolean}  如果指定位置在指定区域之内则返回 true , 否则返回 false \n * \n */\n\n \nlet {\n    top,\n    bottom\n } = region,\n {\n    top:positionTop,\n    bottom:positionBottom\n } = get(position);\n\n return positionTop >= top && positionBottom <= bottom ;\n\n    }\n    \n                    return function(region , position){\n    \n                        \n        if(!var_init_locked_1613300300118){\n\n            get = include('src::math.region.get');\n\n            var_init_locked_1613300300118 = true ;\n        }\n        \n    \n                        return main.call(this , region , position) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.contains.y"
  },
  "src::math.region.contains": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::math.region.contains(<object> region , <mixed> position)",
    "standard": true,
    "importNames": [
      "src::math.region.contains.y",
      "src::math.region.contains.x",
      "src::math.region.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let containsY,containsX,get;\n    \n                    let var_init_locked_1613300300113;\n    \n                    \n\n                    function main(region , position){\n\n        \n/**\n * \n * 判断位置是否在指定区域之内\n * \n * @import containsY from .contains.y\n * \n * @import containsX from .contains.x\n * \n * @import get from .get\n * \n * @param {object} region 参照范围\n * \n * @param {mixed} position 位置\n * \n * @return {boolean}  如果指定位置在指定区域之内则返回 true , 否则返回 false \n * \n */\n\n region = get(region) ;\n\n position = get(position) ;\n\n return containsX(region , position) && containsY(region , position);\n\n    }\n    \n                    return function(region , position){\n    \n                        \n        if(!var_init_locked_1613300300113){\n\n            containsY = include('src::math.region.contains.y');\ncontainsX = include('src::math.region.contains.x');\nget = include('src::math.region.get');\n\n            var_init_locked_1613300300113 = true ;\n        }\n        \n    \n                        return main.call(this , region , position) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.contains"
  },
  "src::math.region.height": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.region.height(<object> region)",
    "standard": true,
    "importNames": [
      "src::math.region.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1613300300108;\n    \n                    \n\n                    function main(region){\n\n        \n/**\n * \n * 获得方位高度\n * \n * @import get from .get\n * \n * @param {object} region 范围\n * \n * @return {number} 宽度值 \n * \n */\n\n let {\n    bottom,\n    top\n } = get(region) ;\n\nreturn bottom - top ;\n\n    }\n    \n                    return function(region){\n    \n                        \n        if(!var_init_locked_1613300300108){\n\n            get = include('src::math.region.get');\n\n            var_init_locked_1613300300108 = true ;\n        }\n        \n    \n                        return main.call(this , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.height"
  },
  "src::math.region.intersect": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::math.region.intersect(<object> region1 , <object> region2)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(region1 , region2){\n\n        \n/**\n * \n * 判断两个范围是否相交\n * \n * @param {object} region1 范围1\n * \n * @param {object} region2 范围2\n * \n * @return {boolean} 如果两者相交则返回 true , 否则返回 false\n * \n */\n\n const {\n    min,\n    max\n } = Math ;\n\nreturn min(region1.bottom , region2.bottom) > max(region1.top , region2.top) && min(region1.right , region2.right) > max(region1.left , region2.left) ;\n\n    }\n    \n                    return function(region1 , region2){\n    \n                        \n    \n                        return main.call(this , region1 , region2) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.intersect"
  },
  "src::math.region.outOfBoundOffset.x": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.region.outOfBoundOffset.x(<object> region , <number> x)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(region , x){\n\n        \n/**\n * \n * 获取横坐标超出范围的偏移植\n * \n * @param {object} region 范围\n * \n * @param {number} x 横坐标 \n * \n * @return {number} 偏移植\n * \n */\n\nlet {\n   left,\n   right\n} = region;\n\nif (x <= left) {\n\n   return left - x;\n\n}else if (x >= right) {\n\n   return right - x;\n\n}\n\nreturn 0;\n\n    }\n    \n                    return function(region , x){\n    \n                        \n    \n                        return main.call(this , region , x) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.outOfBoundOffset.x"
  },
  "src::math.region.outOfBoundOffset.y": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.region.outOfBoundOffset.y(<object> region , <number> y)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(region , y){\n\n        \n/**\n * \n * 获取纵坐标超出范围的偏移植\n * \n * @param {object} region 范围\n * \n * @param {number} y 纵坐标 \n * \n * @return {number} 偏移植\n * \n */\n\nlet {\n    top,\n    bottom\n} = region ;\n\nif (y <= top) {\n\n    return top - y;\n\n}else if (y >= bottom) {\n\n    return bottom - y;\n\n}\n\nreturn 0;\n\n    }\n    \n                    return function(region , y){\n    \n                        \n    \n                        return main.call(this , region , y) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.outOfBoundOffset.y"
  },
  "src::math.region.outOfBoundOffset": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::math.region.outOfBoundOffset(<object> baseRegion , {<number> left , <number> right , <number> top , <number> bottom})",
    "standard": true,
    "importNames": [
      "src::math.region.outOfBoundOffset.x",
      "src::math.region.outOfBoundOffset.y"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getOutOfBoundOffsetX,getOutOfBoundOffsetY;\n    \n                    let var_init_locked_1608956298868;\n    \n                    \n\n                    function main(baseRegion , {left , right , top , bottom}){\n\n        \n/**\n * \n * 获取范围超出另外一个范围的偏移植\n * \n * @import getOutOfBoundOffsetX from  .outOfBoundOffset.x\n * \n * @import getOutOfBoundOffsetY from .outOfBoundOffset.y\n * \n * @param {object} baseRegion 参照范围\n * \n * @param {object} region 范围\n * \n * @param {number} region.left 范围左\n * \n * @param {number} region.right  范围右\n * \n * @param {number} region.top 范围上\n * \n * @param {number} region.bottom 范围下\n * \n * @return {object} 偏移植\n * \n */\n\n const {\n    abs\n } = Math ;\n\nleft = getOutOfBoundOffsetX(baseRegion , left) ;\n\nright = getOutOfBoundOffsetX(baseRegion , right) ;\n\nif(abs(left) < abs(right)){\n\n   left = right ;\n}\n\ntop = getOutOfBoundOffsetY(baseRegion , top) ;\n\nbottom = getOutOfBoundOffsetY(baseRegion , bottom) ;\n\nif(abs(top) < abs(bottom)){\n\n   top = bottom ;\n}\n\nreturn {\n   x:left,\n   y:top\n} ;\n\n    }\n    \n                    return function(baseRegion , {left , right , top , bottom}){\n    \n                        \n        if(!var_init_locked_1608956298868){\n\n            getOutOfBoundOffsetX = include('src::math.region.outOfBoundOffset.x');\ngetOutOfBoundOffsetY = include('src::math.region.outOfBoundOffset.y');\n\n            var_init_locked_1608956298868 = true ;\n        }\n        \n    \n                        return main.call(this , baseRegion , {left , right , top , bottom}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.outOfBoundOffset"
  },
  "src::math.region.scale.init.out": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::math.region.scale.init.out(<object> container , <object> target)",
    "standard": true,
    "importNames": [
      "src::math.region.width",
      "src::math.region.height"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let width,height;\n    \n                    let var_init_locked_1608956298870;\n    \n                    \n\n                    function main(container , target){\n\n        \n/**\n * \n * @import width from ....width\n * \n * @import height from ....height\n * \n * @param {object} container 容器范围\n * \n * @param {object} target 目标范围\n * \n */\n\nconst targetWidth = width(target), \n    targetHeight = height(target),\n    deltaWidth = width(container) - targetWidth,\n    deltaHeight = height(container) - targetHeight;\n\nif(deltaWidth >= 0 && deltaHeight >= 0){\n\n    return 1 ;\n}\n\nif(deltaWidth < deltaHeight){\n\n    return 1 + deltaWidth / targetWidth ;\n}\n\nreturn 1 + deltaHeight / targetHeight ;\n\n\n\n\n\n \n\n \n\n    }\n    \n                    return function(container , target){\n    \n                        \n        if(!var_init_locked_1608956298870){\n\n            width = include('src::math.region.width');\nheight = include('src::math.region.height');\n\n            var_init_locked_1608956298870 = true ;\n        }\n        \n    \n                        return main.call(this , container , target) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.scale.init.out"
  },
  "src::math.region.width": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.region.width(<object> region)",
    "standard": true,
    "importNames": [
      "src::math.region.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1613261554617;\n    \n                    \n\n                    function main(region){\n\n        \n/**\n * \n * 获得方位高度\n * \n * @import get from .get\n * \n * @param {object} region 范围\n * \n * @return {number} 高度值 \n * \n */\n\n let {\n    right,\n    left\n } = get(region) ;\n\n return right - left ;\n\n    }\n    \n                    return function(region){\n    \n                        \n        if(!var_init_locked_1613261554617){\n\n            get = include('src::math.region.get');\n\n            var_init_locked_1613261554617 = true ;\n        }\n        \n    \n                        return main.call(this , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.width"
  },
  "src::math.region.translate": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::math.region.translate(<object> region , {<number> x , <number> y})",
    "standard": true,
    "importNames": [
      "src::math.region.width",
      "src::math.region.height",
      "src::math.region.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let width,height,get;\n    \n                    let var_init_locked_1613308340341;\n    \n                    \n\n                    function main(region , {x , y}){\n\n        \n/**\n * \n * 平移\n * \n * @import width from .width\n * \n * @import height from .height\n * \n * @import get from .get\n * \n * @param {object} region 目标范围\n * \n * @param {object} xy 坐标\n * \n * @param {number} [xy.x] 横坐标\n * \n * @param {number} [xy.y] 纵坐标\n * \n */\n\n region = get(region) ;\n\nlet {\n    left,\n    right,\n    top,\n    bottom\n } = region;\n\nif(x){\n\n    left = x ;\n\n    right = left + width(region) ;\n}\n\nif(y){\n\n    top = y ;\n\n    bottom = top + height(region) ;\n}\n\nreturn {\n    left,\n    right,\n    top,\n    bottom\n} ;\n\n    }\n    \n                    return function(region , {x , y}){\n    \n                        \n        if(!var_init_locked_1613308340341){\n\n            width = include('src::math.region.width');\nheight = include('src::math.region.height');\nget = include('src::math.region.get');\n\n            var_init_locked_1613308340341 = true ;\n        }\n        \n    \n                        return main.call(this , region , {x , y}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.translate"
  },
  "src::math.region.union": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::math.region.union(<object> region1 , <object> region2)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(region1 , region2){\n\n        \n/**\n * \n * 范围联合\n * \n * @param {object} region1 范围1\n * \n * @param {object} region2 范围2\n * \n * @return {object} 范围\n * \n */\n\n const {\n    min,\n    max\n } = Math ;\n\n return {\n    top:min(region1.top , region2.top),\n    bottom:max(region1.bottom , region2.bottom),\n    left:min(region1.left , region2.left),\n    right:max(region1.right , region2.right)\n } ;\n\n    }\n    \n                    return function(region1 , region2){\n    \n                        \n    \n                        return main.call(this , region1 , region2) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.union"
  },
  "src::math.region.x.anchor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::math.region.x.anchor(<object> region , <string> anchor , <number> x)",
    "standard": true,
    "importNames": [
      "src::math.region.get",
      "src::math.region.width",
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,getWidth,isNumber;\n    \n                    let var_init_locked_1613394695924;\n    \n                    \n\n                    function main(region , anchor , x){\n\n        \n/**\n * \n * 根据锚定位置设置横坐标\n * \n * @import get from ..get\n * \n * @import getWidth from ..width\n * \n * @import is.number\n * \n * @param {object} region 范围\n * \n * @param {string} anchor 锚定位置\n * \n * @param {number} [x] 纵坐标值\n * \n */\n\nregion = get(region) ;\n\nlet width = getWidth(region) ;\n\nif(isNumber(x)){\n\n   switch(anchor){\n\n       case 'left':\n   \n           region.left = x ;\n   \n           break ;\n   \n       case 'center':\n   \n           region.left = x - width / 2 ;\n   \n           break ;\n   \n       \n       case 'right':\n   \n           region.left = y - width ;\n   \n           break ;\n    }\n\n    region.right = region.left + width ;\n\n}else{\n\n   switch(anchor){\n\n       case 'left':\n\n           return region.left ;\n\n       case 'center':\n\n           return region.left + width / 2 ;\n\n       case 'right':\n\n           return region.right ;\n   }\n\n}\n\n    }\n    \n                    return function(region , anchor , x){\n    \n                        \n        if(!var_init_locked_1613394695924){\n\n            get = include('src::math.region.get');\ngetWidth = include('src::math.region.width');\nisNumber = include('src::is.number');\n\n            var_init_locked_1613394695924 = true ;\n        }\n        \n    \n                        return main.call(this , region , anchor , x) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.x.anchor"
  },
  "src::math.region.xy.anchor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::math.region.xy.anchor(<object> region , <string> anchor , <object> xy)",
    "standard": true,
    "importNames": [
      "src::is.defined",
      "src::math.region.x.anchor",
      "src::math.region.y.anchor",
      "src::math.region.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined,doAnchorX,doAnchorY,get;\n    \n                    let var_init_locked_1613394633664;\n    \n                    \n\n                    function main(region , anchor , xy){\n\n        \n/**\n * \n * 计算中心点坐标\n * \n * @import is.defined\n * \n * @import doAnchorX from ..x.anchor\n * \n * @import doAnchorY from ..y.anchor\n * \n * @import get from ..get\n * \n * @param {object} region 方位信息\n * \n * @param {string} anchor 锚定位置\n * \n * @param {object} [xy] 需要设置的中心坐标\n * \n */\n\n region = get(region) ;\n\n let anchorX,\n     anchorY ;\n\n switch(anchor){\n\n    case 'tl':\n\n        anchorX = 'left' ;\n\n        anchorY = 'top' ;\n\n        break ;\n\n    case 'tr':\n\n        anchorX = 'right' ;\n\n        anchorY = 'top' ;\n\n        break ;\n\n    case 'br':\n\n        anchorX = 'right' ;\n\n        anchorY = 'bottom' ;\n\n        break ;\n\n    case 'bl':\n\n        anchorX = 'left' ;\n\n        anchorY = 'bottom' ;\n\n        break ;\n\n    case 't':\n\n        anchorX = 'center' ;\n\n        anchorY = 'top' ;\n\n        break ;\n\n    case 'b':\n\n        anchorX = 'center' ;\n\n        anchorY = 'bottom' ;\n\n        break ;\n\n    case 'c':\n\n        anchorX = 'center' ;\n\n        anchorY = 'center' ;\n\n        break ;\n\n    case 'l':\n\n        anchorX = 'left' ;\n\n        anchorY = 'center' ;\n\n        break ;\n\n    case 'r':\n\n        anchorX = 'right' ;\n\n        anchorY = 'center' ;\n\n\n }\n\n if(isDefined(xy)){\n\n    doAnchorX(region , anchorX , xy.x) ;\n\n    doAnchorY(region , anchorY , xy.y) ;\n \n}else{\n\n    return {\n        x:doAnchorX(region , anchorX),\n        y:doAnchorY(region , anchorY)\n    }\n\n}\n\n\n\n    }\n    \n                    return function(region , anchor , xy){\n    \n                        \n        if(!var_init_locked_1613394633664){\n\n            isDefined = include('src::is.defined');\ndoAnchorX = include('src::math.region.x.anchor');\ndoAnchorY = include('src::math.region.y.anchor');\nget = include('src::math.region.get');\n\n            var_init_locked_1613394633664 = true ;\n        }\n        \n    \n                        return main.call(this , region , anchor , xy) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.xy.anchor"
  },
  "src::math.region.y.anchor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::math.region.y.anchor(<object> region , <string> anchor , <number> y)",
    "standard": true,
    "importNames": [
      "src::math.region.get",
      "src::math.region.height",
      "src::is.number"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,getHeight,isNumber;\n    \n                    let var_init_locked_1613392193437;\n    \n                    \n\n                    function main(region , anchor , y){\n\n        \n/**\n * \n * 根据锚定位置设置纵坐标\n * \n * @import get from ..get\n * \n * @import getHeight from ..height\n * \n * @import is.number\n * \n * @param {object} region 范围\n * \n * @param {string} anchor 锚定位置\n * \n * @param {number} [y] 纵坐标值\n * \n */\n\n region = get(region) ;\n\n let height = getHeight(region) ;\n\n if(isNumber(y)){\n\n    switch(anchor){\n\n        case 'top':\n    \n            region.top = y ;\n    \n            break ;\n    \n        case 'center':\n    \n            region.top = y - height / 2 ;\n    \n            break ;\n    \n        \n        case 'bottom':\n    \n            region.top = y - height ;\n    \n            break ;\n     }\n\n     region.bottom = region.top + height ;\n \n}else{\n\n    switch(anchor){\n\n        case 'top':\n\n            return region.top ;\n\n        case 'center':\n\n            return region.top + height / 2 ;\n\n        case 'bottom':\n\n            return region.bottom ;\n    }\n\n }\n\n    }\n    \n                    return function(region , anchor , y){\n    \n                        \n        if(!var_init_locked_1613392193437){\n\n            get = include('src::math.region.get');\ngetHeight = include('src::math.region.height');\nisNumber = include('src::is.number');\n\n            var_init_locked_1613392193437 = true ;\n        }\n        \n    \n                        return main.call(this , region , anchor , y) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.y.anchor"
  },
  "src::math.region.y": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.region.y(<object> region)",
    "standard": true,
    "importNames": [
      "src::math.region.y.anchor"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getAnchorY;\n    \n                    let var_init_locked_1613300946857;\n    \n                    \n\n                    function main(region){\n\n        \n/**\n * \n * 获得范围的纵坐标\n * \n * @import getAnchorY from .y.anchor\n * \n * @param {object} region 范围\n * \n * @return {number} 纵坐标值\n * \n */\n\n return getAnchorY(region , 'top') ;\n\n    }\n    \n                    return function(region){\n    \n                        \n        if(!var_init_locked_1613300946857){\n\n            getAnchorY = include('src::math.region.y.anchor');\n\n            var_init_locked_1613300946857 = true ;\n        }\n        \n    \n                        return main.call(this , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.y"
  },
  "src::math.region.zoom": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::math.region.zoom(<object> region , <number> scale)",
    "standard": true,
    "importNames": [
      "src::math.region.get",
      "src::math.region.width",
      "src::math.region.height"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,width,height;\n    \n                    let var_init_locked_1613308340356;\n    \n                    \n\n                    function main(region , scale){\n\n        \n/**\n * \n * 缩放当前目标范围\n * \n * @import get from .get\n * \n * @import width from .width\n * \n * @import height from .height\n * \n * @param {object} region 目标范围\n * \n * @param {number} scale 缩放值\n * \n * @return {object} 缩放后的目标范围\n * \n */\n\n region = get(region) ;\n\n let {\n    left,\n    top\n } = region,\n right = left + width(region) * scale,\n bottom = top + height(region) * scale ;\n\n return {\n    left,\n    right,\n    top,\n    bottom\n } ;\n\n\n\n \n\n \n\n    }\n    \n                    return function(region , scale){\n    \n                        \n        if(!var_init_locked_1613308340356){\n\n            get = include('src::math.region.get');\nwidth = include('src::math.region.width');\nheight = include('src::math.region.height');\n\n            var_init_locked_1613308340356 = true ;\n        }\n        \n    \n                        return main.call(this , region , scale) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region.zoom"
  },
  "src::math.region": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::math.region(<number> top , <number> right , <number> bottom , <number> left)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_class_1608956298883;\n    \n                    \n\n                    let var_global_main_1608956298883 ;\n    \n                    return function(top , right , bottom , left){\n    \n                        \n        if(!var_init_locked_1608956298883){\n\n            \n\n            \n/**\n * \n * 区域\n * \n * @param {number} top 上\n * \n * @param {number} right 右\n * \n * @param {number} bottom 下\n * \n * @param {number} left 左\n * \n */\n\n const {\n    abs\n } = Math ;\n\n class main{\n\n    constructor(top , right , bottom , left){\n\n      let me = this ;\n\n      me.top = top ;\n\n      me.right = right ;\n\n      me.bottom = bottom ;\n\n      me.left = left ;\n\n    }\n\n   get x(){\n\n      return this.left ;\n   }\n\n   get y(){\n\n      return this.top ;\n   }\n\n   contains(region){\n\n      let {\n         x,\n         y,\n         right,\n         bottom\n      } = this,\n      {\n         x:regionX,\n         y:regionY,\n         right:regionRight,\n         bottom:regionBottom\n      } = region;\n\n      return (regionX >= x &&\n             (regionRight || regionX) <= right &&\n             regionY >= y &&\n             (regionBottom || regionY) <= bottom);\n   }\n\n   getOutOfBoundOffset({\n      x,\n      y,\n      right,\n      bottom\n   }){\n\n      let me = this;\n\n      x = me.getOutOfBoundOffsetX(x) ;\n\n      right = me.getOutOfBoundOffsetX(right) ;\n\n      if(abs(x) < abs(right)){\n\n         x = right ;\n      }\n\n      y = me.getOutOfBoundOffsetY(y) ;\n\n      bottom = me.getOutOfBoundOffsetY(bottom) ;\n\n      if(abs(y) < abs(bottom)){\n\n         y = bottom ;\n      }\n\n      return {\n         x,\n         y\n      } ;\n  }\n\n   getOutOfBoundOffsetX(x){\n\n      let me = this,\n      {\n         left,\n         right\n      } = me;\n\n      if (x <= left) {\n\n         return left - x;\n      \n      }else if (x >= right) {\n      \n         return right - x;\n      \n      }\n\n      return 0;\n  }\n\n  getOutOfBoundOffsetY(y){\n\n      let me = this,\n      {\n      top,\n      bottom\n      } = me ;\n\n      if (y <= top) {\n\n         return top - y;\n      \n      }else if (y >= bottom) {\n      \n         return bottom - y;\n      \n      }\n\n      return 0;\n   }\n}\n\n \n\n            var_class_1608956298883 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956298883 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::math.region' ;\n                }\n\n            } ;\n\n            main = var_class_1608956298883 ;\n        \nvar_global_main_1608956298883 = main;\n\n            var_init_locked_1608956298883 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956298883(top , right , bottom , left) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.region"
  },
  "src::math.speed": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.speed(<number> value , <string> unit)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(value , unit){\n\n        \n/**\n * \n * 计算出速度值\n * \n * @param {number} value 移动值\n * \n * @param {string} [unit = 'ms'] 时间单位\n * \n * @return {number} 返回说明 \n * \n */\n\nswitch(unit){\n\n    case 'ms':\n\n        return value ;\n\n    case 's':\n\n        return value / 1000 ;\n\n    case 'm':\n\n        return value / 1000 / 60 ;\n\n\n    case 'h':\n\n        return value / 1000 / 60 / 60 ;\n}\n\nreturn 0 ;\n\n\n    }\n    \n                    return function(value , unit = 'ms'){\n    \n                        \n    \n                        return main.call(this , value , unit) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.speed"
  },
  "src::math.sum": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::math.sum(<array> ...values)",
    "standard": true,
    "importNames": [
      "src::is.array",
      "src::math.sum"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isArray,sum;\n    \n                    let var_init_locked_1608956298888;\n    \n                    \n\n                    function main(...values){\n\n        \n/**\n * \n * 求和\n * \n * @import is.array\n * \n * @import sum from .sum\n * \n * @param {array} [...values] 一组待求和的值\n * \n * @return {number} 值\n * \n */\n\n let result = 0 ;\n\n for(let value of values){\n\n   if(isArray(value)){\n\n      result += sum(...value) ;\n\n   }else{\n\n      result += value ;\n   }    \n }\n\n return result ;\n\n    }\n    \n                    return function(...values){\n    \n                        \n        if(!var_init_locked_1608956298888){\n\n            isArray = include('src::is.array');\nsum = include('src::math.sum');\n\n            var_init_locked_1608956298888 = true ;\n        }\n        \n    \n                        return main.call(this , ...values) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "math.sum"
  },
  "src::file.read.json": {
    "meta": "code.meta.script.function",
    "signature": "async <mixed> src::file.read.json(<string> path , <function> watchFn)",
    "standard": true,
    "importNames": [
      "src::file.read.text",
      "src::json.parse"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let read,parse;\n    \n                    let var_init_locked_1608956298893;\n    \n                    \n\n                    \n/**\n * \n * 读取 JSON 文件\n * \n * @import read from file.read.text\n * \n * @import parse from json.parse\n * \n * @param {string} path JSON文件存储路径\n * \n *  @param {function} [watchFn] 是否以监听方式获取文件内容\n * \n * @return {mixed} JSON数据 \n * \n */\n\n async function main(path , watchFn){\n\n    if(watchFn){\n\n        read(path , data => watchFn(getJSON(data))) ;\n     \n    }else{\n    \n        return getJSON(await read(path)) ;\n    \n    }\n }\n\n function getJSON(data){\n\n    if(data){\n\n        return parse(data) ;\n    }\n }\n\n \n\n\n\n    \n                    return async function(path , watchFn){\n    \n                        \n        if(!var_init_locked_1608956298893){\n\n            read = include('src::file.read.text');\nparse = include('src::json.parse');\n\n            var_init_locked_1608956298893 = true ;\n        }\n        \n    \n                        return await main.call(this , path , watchFn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "file.read.json"
  },
  "src::file.read": {
    "meta": "code.meta.script.function",
    "signature": "async <ArrayBuffer> src::file.read(<string> path)",
    "standard": true,
    "importNames": [
      "src::is.file"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFile;\n    \n                    let var_init_locked_1608956298898;\n    \n                    \n\n                    async function main(path){\n\n        /**\n * \n * 读取文件\n * \n * @import is.file\n * \n * @param {string} path 文本文件路径\n * \n * @return {ArrayBuffer} 原生文件内容\n * \n */\n\nconst {\n    readFile\n} = require('fs') ;\n\nif(await isFile(path)){\n\n    return new Promise((resolve , reject) => readFile(path , (error , data) => error ? reject(error) : resolve(data))) ;\n}\n\n    }\n    \n                    return async function(path){\n    \n                        \n        if(!var_init_locked_1608956298898){\n\n            isFile = include('src::is.file');\n\n            var_init_locked_1608956298898 = true ;\n        }\n        \n    \n                        return await main.call(this , path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "file.read"
  },
  "src::file.read.text": {
    "meta": "code.meta.script.function",
    "signature": "async <string> src::file.read.text(<string> path , <function> watchFn)",
    "standard": true,
    "importNames": [
      "src::file.read"
    ],
    "dependentModules": {
      "chokidar": "^3.1.1"
    },
    "data": "(() =>{\n\n                    let read;\n    \n                    let var_init_locked_1608956298895;\n    \n                    \n\n                    /**\n * \n * 读取文本文件\n * \n * @require chokidar\n * \n * @import read from file.read\n * \n * @param {string} path 文本文件路径\n * \n * @param {function} [watchFn] 是否以监听方式获取文件内容\n * \n * @return {string} 文本文件内容\n * \n */\n\n const chokidar = require('chokidar'),\n       cacheFiles = {} ;\n\n async function main(path , watchFn){\n\n    if(!watchFn){\n\n        return await getText(path) ;\n    \n    }else{\n\n        if(cacheFiles.hasOwnProperty(path)){\n\n            watchFn(cacheFiles[path]) ;\n        \n        }else{\n\n            chokidar.watch(path).on('change' , async path => watchFn(cacheFiles[path] = await getText(path))) ;\n\n            watchFn(cacheFiles[path] = await getText(path)) ;\n        }   \n    }\n }\n\n async function getText(path) {\n     \n    let data = await read(path) ;\n\n    if(data){\n\n        return data.toString('utf8') ;\n    }\n }\n\n    \n                    return async function(path , watchFn){\n    \n                        \n        if(!var_init_locked_1608956298895){\n\n            read = include('src::file.read');\n\n            var_init_locked_1608956298895 = true ;\n        }\n        \n    \n                        return await main.call(this , path , watchFn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "file.read.text"
  },
  "src::file.stream.read": {
    "meta": "code.meta.script.function",
    "signature": "<fs.WriteStream> src::file.stream.read(<string> path , <object> options)",
    "standard": true,
    "importNames": [
      "src::directory.create"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let create;\n    \n                    let var_init_locked_1608956298900;\n    \n                    \n\n                    function main(path , options){\n\n        \n/**\n * \n * 创建读取流\n * \n * @import create from directory.create\n * \n * @param {string} path 路径\n * \n * @param {object} [options] 流配置\n * \n * @return {fs.WriteStream} 读取流 \n * \n */\n\nconst {\n    createReadStream\n } = require('fs');\n\n return createReadStream(path , options) ;\n\n\n\n\n    }\n    \n                    return function(path , options){\n    \n                        \n        if(!var_init_locked_1608956298900){\n\n            create = include('src::directory.create');\n\n            var_init_locked_1608956298900 = true ;\n        }\n        \n    \n                        return main.call(this , path , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "file.stream.read"
  },
  "src::file.stream.write": {
    "meta": "code.meta.script.function",
    "signature": "<fs.WriteStream> src::file.stream.write(<string> path , <object> options)",
    "standard": true,
    "importNames": [
      "src::directory.create"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let create;\n    \n                    let var_init_locked_1608956298902;\n    \n                    \n\n                    function main(path , options){\n\n        \n/**\n * \n * 创建写入流\n * \n * @import create from directory.create\n * \n * @param {string} path 路径\n * \n * @param {object} [options] 流配置\n * \n * @return {fs.WriteStream} 写入流 \n * \n */\n\n const {\n    dirname\n } = require('path'),\n {\n    createWriteStream\n } = require('fs');\n\n create(dirname(path)) ;\n\n return createWriteStream(path , options) ;\n\n\n\n\n    }\n    \n                    return function(path , options){\n    \n                        \n        if(!var_init_locked_1608956298902){\n\n            create = include('src::directory.create');\n\n            var_init_locked_1608956298902 = true ;\n        }\n        \n    \n                        return main.call(this , path , options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "file.stream.write"
  },
  "src::file.write.html": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::file.write.html(<string> path , <mixed> doc)",
    "standard": true,
    "importNames": [
      "src::file.write",
      "src::html.format"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let write,format;\n    \n                    let var_init_locked_1608956298904;\n    \n                    \n\n                    function main(path , doc){\n\n        /**\n * \n * 保存HTML文件\n * \n * @import write from file.write\n * \n * @import format from html.format\n * \n * @param {string} path 保存文件路径\n * \n * @param {mixed} doc 保存文件内容\n * \n */\n\nwrite(path , format(doc)) ;\n\n    }\n    \n                    return function(path , doc){\n    \n                        \n        if(!var_init_locked_1608956298904){\n\n            write = include('src::file.write');\nformat = include('src::html.format');\n\n            var_init_locked_1608956298904 = true ;\n        }\n        \n    \n                        return main.call(this , path , doc) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "file.write.html"
  },
  "src::file.write": {
    "meta": "code.meta.script.function",
    "signature": "async <void> src::file.write(<string> path , <mixed> data)",
    "standard": true,
    "importNames": [
      "src::directory.create"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let create;\n    \n                    let var_init_locked_1608956298907;\n    \n                    \n\n                    async function main(path , data){\n\n        \n/**\n * \n * 保存文件\n * \n * @import create from directory.create\n * \n * @param {string} path 保存文件路径\n * \n * @param {mixed} data 保存文件内容\n * \n * \n */\n\nconst {\n    writeFile\n} = require('fs'),\n{\n    dirname\n} = require('path');\n\nawait create(dirname(path)) ;\n\nreturn new Promise((resolve , reject) => writeFile(path , data , error => error ? reject(error) : resolve())) ;\n\n    }\n    \n                    return async function(path , data){\n    \n                        \n        if(!var_init_locked_1608956298907){\n\n            create = include('src::directory.create');\n\n            var_init_locked_1608956298907 = true ;\n        }\n        \n    \n                        return await main.call(this , path , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "file.write"
  },
  "src::html.format": {
    "meta": "code.meta.script.function",
    "signature": "<string> src::html.format(<mixed> data)",
    "standard": true,
    "importNames": [
      "src::is.string"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString;\n    \n                    let var_init_locked_1608956298909;\n    \n                    \n\n                    function main(data){\n\n        /**\n * \n * 格式化 HTML 文件内容\n * \n * @import is.string\n * \n * @param {mixed} data HTML 文件内容\n * \n * @return {string} 格式化后的 HTML 文件内容\n * \n */\n\nconst {\n    minify\n} = require('html-minifier'),\n{\n    html\n} = require('js-beautify');\n\nif(!isString(data)){\n\n   data = `<!DOCTYPE html>\\n${data.documentElement.outerHTML}` ;\n}\n\nreturn html(minify(data , {\n    collapseWhitespace:true\n})) ;\n\n    }\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956298909){\n\n            isString = include('src::is.string');\n\n            var_init_locked_1608956298909 = true ;\n        }\n        \n    \n                        return main.call(this , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "html.format"
  },
  "src::file.write.json": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::file.write.json(<string> path , <mixed> data)",
    "standard": true,
    "importNames": [
      "src::file.write"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let write;\n    \n                    let var_init_locked_1608956298911;\n    \n                    \n\n                    function main(path , data){\n\n        \n/**\n * \n * 保存JSON文件\n * \n * @import write from file.write\n * \n * @param {string} path 保存文件路径\n * \n * @param {mixed} data 保存文件内容\n * \n */\n\nreturn write(path , JSON.stringify(data , null , 2)) ;\n\n    }\n    \n                    return function(path , data){\n    \n                        \n        if(!var_init_locked_1608956298911){\n\n            write = include('src::file.write');\n\n            var_init_locked_1608956298911 = true ;\n        }\n        \n    \n                        return main.call(this , path , data) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "file.write.json"
  },
  "src::mindmap": {
    "meta": "code.meta.class",
    "signature": "<void> src::mindmap(<mixed> config)",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::class.empty",
      "src::mindmap.constructor",
      "src::mindmap.load",
      "src::mindmap.destroy",
      "src::mindmap.resize",
      "src::mindmap.deselect",
      "src::mindmap.reset",
      "src::mindmap.focus",
      "src::mindmap.node.select",
      "src::mindmap.node.collapse",
      "src::mindmap.node.expand",
      "src::mindmap.node.from",
      "src::mindmap.node.value.set",
      "src::mindmap.node.delete",
      "src::mindmap.node.append.new",
      "src::mindmap.node.insert.new.before",
      "src::mindmap.node.insert.new.after",
      "src::mindmap.node.restructure.start",
      "src::mindmap.node.restructure",
      "src::mindmap.node.restructure.end",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let mixin_1613700972894__1,extend,constructor,method_load,method_destroy,method_resize,method_deselect,method_reset,method_focus,method_selectNode,method_collapseNode,method_expandNode,method_getNode,method_setNodeValue,method_deleteNode,method_appendNewNode,method_insertNewNodeBefore,method_insertNewNodeAfter,method_startRestructureNode,method_restructureNode,method_endRestructureNode,isObject;\n    \n                    let var_init_locked_1613700972895;\n    \n                    let var_class_1613700972895;\n    \n                    \n\n                    let var_global_main_1613700972895 ;\n    \n                    return function(config){\n    \n                        \n        if(!var_init_locked_1613700972895){\n\n            mixin_1613700972894__1 = include('src::mixin.observable');\nextend = include('src::class.empty')();\nconstructor = include('src::mindmap.constructor');\nmethod_load = include('src::mindmap.load');\nmethod_destroy = include('src::mindmap.destroy');\nmethod_resize = include('src::mindmap.resize');\nmethod_deselect = include('src::mindmap.deselect');\nmethod_reset = include('src::mindmap.reset');\nmethod_focus = include('src::mindmap.focus');\nmethod_selectNode = include('src::mindmap.node.select');\nmethod_collapseNode = include('src::mindmap.node.collapse');\nmethod_expandNode = include('src::mindmap.node.expand');\nmethod_getNode = include('src::mindmap.node.from');\nmethod_setNodeValue = include('src::mindmap.node.value.set');\nmethod_deleteNode = include('src::mindmap.node.delete');\nmethod_appendNewNode = include('src::mindmap.node.append.new');\nmethod_insertNewNodeBefore = include('src::mindmap.node.insert.new.before');\nmethod_insertNewNodeAfter = include('src::mindmap.node.insert.new.after');\nmethod_startRestructureNode = include('src::mindmap.node.restructure.start');\nmethod_restructureNode = include('src::mindmap.node.restructure');\nmethod_endRestructureNode = include('src::mindmap.node.restructure.end');\nisObject = include('src::is.object.simple');\n\n            class main extends mixins({extend , mixins:[include('mixin.observable')]}){\n\n            \n\n            \n\n            constructor(...args){\n\n            super(...args) ;\n\n            constructor.apply(this , args) ;\n\n        }\n\n            load(...args){\n\n            return method_load.apply(this , args) ;\n\n        }\ndestroy(...args){\n\n            return method_destroy.apply(this , args) ;\n\n        }\nresize(...args){\n\n            return method_resize.apply(this , args) ;\n\n        }\ndeselect(...args){\n\n            return method_deselect.apply(this , args) ;\n\n        }\nreset(...args){\n\n            return method_reset.apply(this , args) ;\n\n        }\nfocus(...args){\n\n            return method_focus.apply(this , args) ;\n\n        }\nselectNode(...args){\n\n            return method_selectNode.apply(this , args) ;\n\n        }\ncollapseNode(...args){\n\n            return method_collapseNode.apply(this , args) ;\n\n        }\nexpandNode(...args){\n\n            return method_expandNode.apply(this , args) ;\n\n        }\ngetNode(...args){\n\n            return method_getNode.apply(this , args) ;\n\n        }\nsetNodeValue(...args){\n\n            return method_setNodeValue.apply(this , args) ;\n\n        }\ndeleteNode(...args){\n\n            return method_deleteNode.apply(this , args) ;\n\n        }\nappendNewNode(...args){\n\n            return method_appendNewNode.apply(this , args) ;\n\n        }\ninsertNewNodeBefore(...args){\n\n            return method_insertNewNodeBefore.apply(this , args) ;\n\n        }\ninsertNewNodeAfter(...args){\n\n            return method_insertNewNodeAfter.apply(this , args) ;\n\n        }\nstartRestructureNode(...args){\n\n            return method_startRestructureNode.apply(this , args) ;\n\n        }\nrestructureNode(...args){\n\n            return method_restructureNode.apply(this , args) ;\n\n        }\nendRestructureNode(...args){\n\n            return method_endRestructureNode.apply(this , args) ;\n\n        }\n\n            \n\n        }\n\n            var_class_1613700972895 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1613700972895 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::mindmap' ;\n                }\n\n            } ;\n\n            main = var_class_1613700972895 ;\n        \nvar_global_main_1613700972895 = main;\n\n            var_init_locked_1613700972895 = true ;\n        }\n        \n    \n                        return new var_global_main_1613700972895(config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap"
  },
  "src::mindmap.node.id.generate": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.id.generate()",
    "standard": true,
    "importNames": [
      "src::id.generate"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let generate;\n    \n                    let var_init_locked_1613621911584;\n    \n                    \n\n                    function main(){\n\n        /**\n * \n * 生成节点唯一编号\n * \n * @import generate from id.generate\n * \n */\n\n return generate('node-') ;\n\n    }\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1613621911584){\n\n            generate = include('src::id.generate');\n\n            var_init_locked_1613621911584 = true ;\n        }\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.id.generate"
  },
  "src::mindmap.node.create": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.node.create(<object> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.id.generate"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let generate;\n    \n                    let var_init_locked_1613634000859;\n    \n                    \n\n                    function main(node){\n\n        \n/**\n * \n * 创建新节点\n * \n * @import generate from .id.generate\n * \n * @param {object} [node = {}] 节点信息\n * \n * @return {data.Record} 创建出来的新节点 \n * \n */\n\nlet {\n   reader,\n   nodes\n} = this ;\n\ndelete node.hidden ;\n\ndelete node.level ;\n\nlet options = {\n   text:'',\n   ...node,\n   id:generate(),\n   children:[]\n} ;\n\nnode = reader.create(options) ;\n\nnodes.set(node.id , node) ;\n\nreturn node ;\n\n    }\n    \n                    return function(node = {}){\n    \n                        \n        if(!var_init_locked_1613634000859){\n\n            generate = include('src::mindmap.node.id.generate');\n\n            var_init_locked_1613634000859 = true ;\n        }\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.create"
  },
  "src::mindmap.node.parent": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.node.parent(<data.Record> node)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node){\n\n        \n/**\n * \n * 获取指定节点的父节点引用\n * \n * @param {data.Record} node 节点\n * \n * @return {data.Record} 父节点 \n * \n */\n\n let {\n   nodes\n } = this,\n {\n  parentNodeId\n } = node ;\n\n if(parentNodeId){\n\n   return nodes.get(parentNodeId) ;\n\n }\n\n\n\n    }\n    \n                    return function(node){\n    \n                        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.parent"
  },
  "src::mindmap.node.field.hidden.level": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.field.hidden.level(<data.Record> node , <boolean> hidden)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.parent"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613382328296 = new Map();\n    \n                    return function(node , hidden){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613382328296.has(this)){\n\n            var_current_scope_1613382328296.set(this , (() => {\n                const getParentNode = include('src::mindmap.node.parent').bind(this);\n\n                function main(node , hidden){\n\n        \n/**\n * \n * 设置脑图节点层次\n * \n * @import getParentNode from ....parent scoped\n * \n * @param {data.Record} node 节点\n * \n * @param {boolean} hidden 决定节点是否隐藏，隐藏为 true , 显示为 false\n * \n */\n\n if(hidden){\n\n    node.level = -1 ;\n \n }else{\n\n    let parentNode,\n        noLevelNodes = [\n            node\n        ];\n\n    while(parentNode = getParentNode(node)){\n\n        let {\n            level\n        } = parentNode ;\n\n        if(level === -1){\n\n            noLevelNodes.unshift(parentNode) ;\n        \n        }else{\n\n            for(let noLevelNode of noLevelNodes){\n\n                noLevelNode.level = ++ level ;\n            }\n\n            noLevelNodes.length = 0 ;\n\n            break ;\n        }\n    }\n\n    if(noLevelNodes.length){\n\n        let level = 0 ;\n\n        for(let noLevelNode of noLevelNodes){\n\n            noLevelNode.level = level ++ ;\n        }\n    }\n }\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613382328296.get(this) ;\n\n        \n    \n                        return main.call(this , node , hidden) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.field.hidden.level"
  },
  "src::mindmap.node.field.hidden": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.field.hidden(<data.Record> node , <boolean> hidden)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.field.hidden.level"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613382382813 = new Map();\n    \n                    return function(node , hidden){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613382382813.has(this)){\n\n            var_current_scope_1613382382813.set(this , (() => {\n                const level = include('src::mindmap.node.field.hidden.level').bind(this);\n\n                function main(node , hidden){\n\n        \n/**\n * \n * 设置节点隐藏属性\n * \n * @import level from .hidden.level scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @param {boolean} hidden 决定节点是否隐藏，隐藏为 true , 显示为 false\n * \n * @return {boolean} 节点隐藏状态\n * \n */\n\nlet {\n    id\n} = node,\nme = this;\n\nlevel(node , hidden) ;\n\nif(hidden){\n\n    node.selected = false ;\n\n    node.width = false ;\n\n    node.height = false ;\n}\n\nreturn hidden ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613382382813.get(this) ;\n\n        \n    \n                        return main.call(this , node , hidden) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.field.hidden"
  },
  "src::mindmap.node.field.selected": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.field.selected(<data.Record> node , <boolean> selected)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node , selected){\n\n        \n/**\n * \n * 设置选定状态\n * \n * @param {data.Record} node 节点\n * \n * @param {boolean} selected 节点选定状态\n * \n * \n */\n\nlet me = this,\n{\n   selectedNode\n} = me;\n\n if(selected){\n\n    if(selectedNode){\n\n       selectedNode.selected = false ;\n    }\n\n    me.selectedNode = node ;\n \n }else if(node === selectedNode){\n\n   delete me.selectedNode ;\n   \n }\n\n return selected ;\n\n    }\n    \n                    return function(node , selected){\n    \n                        \n    \n                        return main.call(this , node , selected) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.field.selected"
  },
  "src::mindmap.indicated": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.indicated(<data.Record> node , <boolean> indicated)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node , indicated){\n\n        \n/**\n * \n * 设置节点指示标识\n * \n * @param {data.Record} node 节点\n * \n * @param {boolean} indicated 指示标识值\n * \n * @return {boolean} 提示标识值 \n * \n */\n\n let me = this,\n {\n    restructureIndicatedNode\n } = me ;\n\n if(indicated){\n\n    if(restructureIndicatedNode){\n\n        restructureIndicatedNode.indicated = false ;\n    }\n\n    me.restructureIndicatedNode = node ;\n }\n\n return indicated ;\n\n    }\n    \n                    return function(node , indicated){\n    \n                        \n    \n                        return main.call(this , node , indicated) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.indicated"
  },
  "src::function.buffer": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::function.buffer(<mixed> fn , {<mixed> scope , <mixed> buffer})",
    "standard": true,
    "importNames": [
      "src::function.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956299059;\n    \n                    \n\n                    function main(fn , {scope , buffer}){\n\n        \n/**\n * \n * 实现懒执行模式函数\n * \n * @import get from function.get\n * \n * @param {mixed} fn 函数\n * \n * @param {object} [config = {}] 函数配置\n * \n * @param {mixed} [config.scope] 函数作用域\n * \n * @param {mixed} [config.buffer = 0] 缓存时间\n * \n * \n */\n\nlet bufferId ;\n\nreturn (...args) =>{\n\n    if(bufferId){\n\n        clearTimeout(bufferId) ;\n\n        bufferId = null ;\n    }\n\n    bufferId = setTimeout(() => {\n\n        get(fn , scope)(...args) ;\n\n        bufferId = null ;\n\n    } , buffer) ;\n} ;\n\n    }\n    \n                    return function(fn , {scope , buffer = 0} = {}){\n    \n                        \n        if(!var_init_locked_1608956299059){\n\n            get = include('src::function.get');\n\n            var_init_locked_1608956299059 = true ;\n        }\n        \n    \n                        return main.call(this , fn , {scope , buffer}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "function.buffer"
  },
  "src::mindmap.node.is.unsized": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.is.unsized(<data.Record> node)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node){\n\n        \n/**\n * \n * 节点是否未设置尺寸\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {boolean} 如果没有设置尺寸则返回 true , 否则返回 false \n * \n */\n\n return node.width === false && node.height === false ;\n\n    }\n    \n                    return function(node){\n    \n                        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.is.unsized"
  },
  "src::mindmap.data": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.data(<data.Record> node , <object> fields)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node , fields){\n\n        \n/**\n * \n * 获取节点实际的数据信息\n * \n * @param {data.Record} node 节点\n * \n * @param {object} fields 字段信息\n * \n * @return {object} 数据信息 \n * \n */\n\n if(node){\n\n    return this.reader.data(node , {\n        ignoreFields:[\n        'children'\n        ],\n        fields\n    }) ;\n }\n\n    }\n    \n                    return function(node , fields){\n    \n                        \n    \n                        return main.call(this , node , fields) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.data"
  },
  "src::mindmap.node.from": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.node.from(<mixed> node)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.object",
      "src::mindmap.node.from",
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isObject,isDefined;\n    \n                    let var_init_locked_1613542771251;\n \n                    \n\n                    const var_current_scope_1613542771251 = new Map();\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1613542771251){\n\n            isString = include('src::is.string');\nisObject = include('src::is.object');\nisDefined = include('src::is.defined');\n\n            var_init_locked_1613542771251 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613542771251.has(this)){\n\n            var_current_scope_1613542771251.set(this , (() => {\n                const from = include('src::mindmap.node.from').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 根据所提供的标识来获得脑图节点\n * \n * @import is.string\n * \n * @import isObject from is.object\n * \n * @import from from .from scoped\n * \n * @import is.defined\n * \n * @param {mixed} node 脑图节点标识\n * \n * @return {data.Record} 脑图节点 \n * \n */\n\nlet {\n   nodes,\n   selectedNode\n} = this ;\n\nif(isString(node)){\n\n   return nodes.get(node) ;\n\n}else if(isObject(node)){\n\n  let {\n      id\n  } = node ;\n\n  return from(id) ;\n\n}else if(!isDefined(node)){\n\n    return selectedNode ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613542771251.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.from"
  },
  "src::mindmap.node.is.root": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.is.root(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613566322989 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613566322989.has(this)){\n\n            var_current_scope_1613566322989.set(this , (() => {\n                const from = include('src::mindmap.node.from').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 判断指定脑图节点是否为根节点\n * \n * @import from from ..from scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {boolean} 如果为根节点则返回 true , 否则返回 false \n * \n */\n\nreturn from(node) === this.rootNode ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613566322989.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.is.root"
  },
  "src::mindmap.node.is.leaf": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.is.leaf(<data.Record> node)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node){\n\n        \n/**\n * \n * 判断指定节点是否为叶子节点\n * \n * @param {data.Record} node 节点\n * \n * @return {boolean} 如果节点为叶子节点则返回 true , 否则 false\n * \n */\n\n\nlet {\n  children\n} = node ;\n\nreturn !children.length ;\n\n    }\n    \n                    return function(node){\n    \n                        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.is.leaf"
  },
  "src::mindmap.node.data": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.node.data(<mixed> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.data",
      "src::mindmap.node.is.root",
      "src::mindmap.node.is.leaf"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613610502109 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613610502109.has(this)){\n\n            var_current_scope_1613610502109.set(this , (() => {\n                const data = include('src::mindmap.data').bind(this);\nconst isRootNode = include('src::mindmap.node.is.root').bind(this);\nconst isLeafNode = include('src::mindmap.node.is.leaf').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 获取节点参数级数据信息\n * \n * @import data from ..data scoped\n * \n * @import isRootNode from .is.root scoped\n * \n * @import isLeafNode from .is.leaf scoped\n * \n * @param {mixed} node 节点\n * \n * @return {object} 数据信息 \n * \n */\n\n return data(node , {\n\n   root(node){\n\n      return isRootNode(node) ;\n   },\n\n   leaf(node){\n\n      return isLeafNode(node) ;\n   }\n }) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613610502109.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.data"
  },
  "src::mindmap.layout.cache.clear": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.cache.clear()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 清除布局缓存\n * \n */\n\n delete this.layoutCache ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.cache.clear"
  },
  "src::mindmap.layout": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout()",
    "standard": true,
    "importNames": [
      "src::mindmap.node.is.unsized",
      "src::mindmap.node.data",
      "src::mindmap.layout.cache.clear"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613641966200 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613641966200.has(this)){\n\n            var_current_scope_1613641966200.set(this , (() => {\n                const isUnsized = include('src::mindmap.node.is.unsized').bind(this);\nconst getData = include('src::mindmap.node.data').bind(this);\nconst clear = include('src::mindmap.layout.cache.clear').bind(this);\n\n                \n/**\n * \n * 布局\n * \n * @import isUnsized from .node.is.unsized scoped\n * \n * @import getData from .node.data scoped\n * \n * @import clear from .layout.cache.clear scoped\n * \n */\n\n function main(){\n\n   let me = this,\n   {\n      isLayouting\n   } = me;\n\n   if(isLayouting){\n\n      return ;\n   }\n\n   me.isLayouting = true ;\n\n   clear() ;\n\n   let {\n      pattern:layout,\n      getRootNode,\n      getDescendantNodes,\n      createPositioner\n   } = me.layoutConfig ;\n\n   let rootNode = getRootNode() ;\n\n   doBeforeLayout.call(me , me.layoutNodes = [\n      rootNode,\n      ...getDescendantNodes(rootNode)\n   ] , () => {\n\n      me.layoutData = layout(rootNode) ;\n\n      me.layoutPositioner = createPositioner(me , me.layoutNodes) ;\n\n      me.refresh() ;\n\n      me.isLayouting = false ;\n\n   }) ;\n }\n\n function doBeforeLayout(layoutNodes , callback){\n\n   let unsizedNodes = new Map() ;\n\n    for(let layoutNode of layoutNodes){\n\n      if(isUnsized(layoutNode)){\n\n         unsizedNodes.set(layoutNode.id , layoutNode) ;\n      }\n    }\n\n    if(unsizedNodes.size){\n\n      this.fireEvent('nodeunsized' , getDataNodes(unsizedNodes) , sizes => {\n\n         let ids = Object.keys(sizes) ;\n\n         for(let id of ids){\n\n            let node = unsizedNodes.get(id),\n            {\n               width,\n               height\n            } = sizes[id];\n\n            node.width = width ;\n\n            node.height = height ;\n         }\n\n         callback() ;\n\n      }) ;\n\n    }else{\n\n      callback() ;\n    }\n }\n\n function getDataNodes(nodes){\n\n   nodes = nodes.values() ;\n\n   let result = [] ;\n\n   for(let node of nodes){\n\n      result.push(getData(node)) ;\n   }\n\n   return result ;\n }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613641966200.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout"
  },
  "src::mindmap.layout.cache": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::mindmap.layout.cache(<data.Record> node , <string> cacheName , <function> cacheFn)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node , cacheName , cacheFn){\n\n        \n/**\n * \n * 布局缓存\n * \n * @param {data.Record} node 脑图节点\n * \n * @param {string} cacheName 缓存名称\n * \n * @param {function} cacheFn 缓存计算函数\n * \n * @return {mixed} 缓存返回值\n * \n */\n\n let me = this ;\n\n if(!me.hasOwnProperty('layoutCache')){\n\n    me.layoutCache = new Map() ;\n }\n\n let {\n    layoutCache\n } = me ;\n\n if(!layoutCache.has(node)){\n\n    layoutCache.set(node , {}) ;\n }\n\n let cache = layoutCache.get(node) ;\n\n if(!cache.hasOwnProperty(cacheName)){\n\n    cache[cacheName] = cacheFn.call(me , node) ;\n }\n\n return cache[cacheName] ;\n\n    }\n    \n                    return function(node , cacheName , cacheFn){\n    \n                        \n    \n                        return main.call(this , node , cacheName , cacheFn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.cache"
  },
  "src::mindmap.layout.node.parent": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.layout.node.parent(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.parent",
      "src::mindmap.layout.cache"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613786076560 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613786076560.has(this)){\n\n            var_current_scope_1613786076560.set(this , (() => {\n                const getParentNode = include('src::mindmap.node.parent').bind(this);\nconst cache = include('src::mindmap.layout.cache').bind(this);\n\n                \n/**\n * \n * 获取父节点\n * \n * @import getParentNode from mindmap.node.parent scoped\n * \n * @import cache from mindmap.layout.cache scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {data.Record} 所获取的父节点\n * \n */\n\n function main(node){\n\n   return cache(node , 'getParentNode' , getLayoutedParentNode) ;\n \n }\n\n function getLayoutedParentNode(node){\n\n   let {\n      layoutNodes\n   } = this,\n   parentNode = getParentNode(node);\n  \n   if(parentNode && layoutNodes.includes(parentNode)){\n  \n      return parentNode ;\n   }\n }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613786076560.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.parent"
  },
  "src::mindmap.layout.node.is.root": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.layout.node.is.root(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.parent"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613359840570 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613359840570.has(this)){\n\n            var_current_scope_1613359840570.set(this , (() => {\n                const getParentNode = include('src::mindmap.layout.node.parent').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 判断是否为根节点\n * \n * @import getParentNode from ..parent scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {boolean} 如果为根节点则返回 true , 否则返回 false \n * \n */\n\nreturn !getParentNode(node) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613359840570.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.is.root"
  },
  "src::mindmap.layout.node.data": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.node.data(<mixed> node , <object> offset)",
    "standard": true,
    "importNames": [
      "src::mindmap.data",
      "src::mindmap.layout.node.is.root",
      "src::mindmap.node.is.leaf"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613610950999 = new Map();\n    \n                    return function(node , offset){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613610950999.has(this)){\n\n            var_current_scope_1613610950999.set(this , (() => {\n                const data = include('src::mindmap.data').bind(this);\nconst isRootNode = include('src::mindmap.layout.node.is.root').bind(this);\nconst isLeafNode = include('src::mindmap.node.is.leaf').bind(this);\n\n                function main(node , offset){\n\n        \n/**\n * \n * 获取节点参数级数据信息\n * \n * @import data from mindmap.data scoped\n * \n * @import isRootNode from .is.root scoped\n * \n * @import isLeafNode from mindmap.node.is.leaf scoped\n * \n * @param {mixed} node 节点\n * \n * @param {object} offset 坐标偏移值\n * \n * @return {object} 数据信息 \n * \n */\n\n return data(node , {\n\n   root(node){\n\n      return isRootNode(node) ;\n   },\n\n   leaf(node){\n\n      return isLeafNode(node) ;\n   },\n\n   x(node){\n\n      return node.x + offset.x ;\n   },\n\n   y(node){\n\n      return node.y + offset.y ;\n   }\n\n }) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613610950999.get(this) ;\n\n        \n    \n                        return main.call(this , node , offset) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.data"
  },
  "src::mindmap.layout.node.spacing.left": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::mindmap.layout.node.spacing.left(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1613610502145;\n \n                    \n\n                    const var_current_scope_1613610502145 = new Map();\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1613610502145){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1613610502145 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613610502145.has(this)){\n\n            var_current_scope_1613610502145.set(this , (() => {\n                const data = include('src::mindmap.node.data').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 脑图节点的左侧间距\n * \n * @import is.function\n * \n * @import data from mindmap.node.data scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {number} 间距值\n * \n */\n\nlet {\n    left\n } = this.layoutConfig.nodeSpacing;\n\n if(isFunction(left)){\n\n    return left(data(node)) ;\n }\n\n return left ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613610502145.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.spacing.left"
  },
  "src::mindmap.layout.node.spacing.right": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::mindmap.layout.node.spacing.right(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1613610502150;\n \n                    \n\n                    const var_current_scope_1613610502150 = new Map();\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1613610502150){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1613610502150 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613610502150.has(this)){\n\n            var_current_scope_1613610502150.set(this , (() => {\n                const data = include('src::mindmap.node.data').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 脑图节点的右侧间距\n * \n * @import is.function\n * \n * @import data from mindmap.node.data scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {number} 间距值\n * \n */\n\nlet {\n    right\n } = this.layoutConfig.nodeSpacing;\n\n if(isFunction(right)){\n\n    return right(data(node)) ;\n }\n\n return right ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613610502150.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.spacing.right"
  },
  "src::mindmap.layout.node.spacing.top": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::mindmap.layout.node.spacing.top(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1613610502154;\n \n                    \n\n                    const var_current_scope_1613610502154 = new Map();\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1613610502154){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1613610502154 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613610502154.has(this)){\n\n            var_current_scope_1613610502154.set(this , (() => {\n                const data = include('src::mindmap.node.data').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 脑图节点的顶部间距\n * \n * @import is.function\n * \n * @import data from mindmap.node.data scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {number} 间距值\n * \n */\n\nlet {\n   top\n} = this.layoutConfig.nodeSpacing;\n\n if(isFunction(top)){\n\n    return top(data(node)) ;\n }\n\n return top ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613610502154.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.spacing.top"
  },
  "src::mindmap.layout.node.spacing.bottom": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::mindmap.layout.node.spacing.bottom(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1613610502159;\n \n                    \n\n                    const var_current_scope_1613610502159 = new Map();\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1613610502159){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1613610502159 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613610502159.has(this)){\n\n            var_current_scope_1613610502159.set(this , (() => {\n                const data = include('src::mindmap.node.data').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 脑图节点的底部间距\n * \n * @import is.function\n * \n * @import data from mindmap.node.data scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {number} 间距值\n * \n */\n\nlet {\n    bottom\n } = this.layoutConfig.nodeSpacing;\n\n if(isFunction(bottom)){\n\n    return bottom(data(node)) ;\n }\n\n return bottom ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613610502159.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.spacing.bottom"
  },
  "src::mindmap.layout.node.region.self": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.node.region.self(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.spacing.left",
      "src::mindmap.layout.node.spacing.right",
      "src::mindmap.layout.node.spacing.top",
      "src::mindmap.layout.node.spacing.bottom"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613740790834 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613740790834.has(this)){\n\n            var_current_scope_1613740790834.set(this , (() => {\n                const getLeftSpacing = include('src::mindmap.layout.node.spacing.left').bind(this);\nconst getRightSpacing = include('src::mindmap.layout.node.spacing.right').bind(this);\nconst getTopSpacing = include('src::mindmap.layout.node.spacing.top').bind(this);\nconst getBottomSpacing = include('src::mindmap.layout.node.spacing.bottom').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 获得脑图节点自身范围\n * \n * @import getLeftSpacing from ..spacing.left scoped\n * \n * @import getRightSpacing from ..spacing.right scoped\n * \n * @import getTopSpacing from ..spacing.top scoped\n * \n * @import getBottomSpacing from ..spacing.bottom scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {object} 范围信息 \n * \n */\n\n let {\n    x,\n    y,\n    width,\n    height\n } = node,\n top = y - getTopSpacing(node),\n left = x - getLeftSpacing(node);\n\n return {\n     top,\n     bottom:y + height + getBottomSpacing(node),\n     left,\n     right:x + width + getRightSpacing(node)\n } ;\n\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613740790834.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.region.self"
  },
  "src::mindmap.refresh": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.refresh()",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.data",
      "src::math.region.from",
      "src::mindmap.layout.node.region.self",
      "src::math.region.xy.anchor",
      "src::mindmap.layout.node.parent"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from,getAnchorXY;\n    \n                    let var_init_locked_1613610852862;\n \n                    \n\n                    const var_current_scope_1613610852862 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1613610852862){\n\n            from = include('src::math.region.from');\ngetAnchorXY = include('src::math.region.xy.anchor');\n\n            var_init_locked_1613610852862 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613610852862.has(this)){\n\n            var_current_scope_1613610852862.set(this , (() => {\n                const getData = include('src::mindmap.layout.node.data').bind(this);\nconst getRegion = include('src::mindmap.layout.node.region.self').bind(this);\nconst getParentNode = include('src::mindmap.layout.node.parent').bind(this);\n\n                \n/**\n * \n * 刷新\n * \n * @import getData from .layout.node.data scoped\n * \n * @import from from math.region.from\n * \n * @import getRegion from .layout.node.region.self scoped\n * \n * @import getAnchorXY from math.region.xy.anchor\n * \n * @import getParentNode from .layout.node.parent scoped\n * \n */\n\n function main(){\n\n    let me = this,\n    {\n        layoutNodes,\n        layoutData\n    } = me,\n    {\n        size,\n        offset\n    } = layoutData,\n    {\n        nodes,\n        selectedNode\n    } = getNodeDataset(layoutNodes , offset),\n    {\n        placeholderNode\n    } = me;\n\n    me.fireEvent('draw' , {\n        nodes:getNodes(nodes),\n        lines:getLines(nodes , placeholderNode),\n        selectedNode,\n        selectedNodeRegion:getRegion(selectedNode),\n        canvas:size\n    }) ;\n }\n\n function getNodes(nodes){\n\n    nodes = nodes.values() ;\n\n    let result = [] ;\n\n    for(let {\n        data\n    } of nodes){\n\n        result.push(data) ;\n    }\n\n    return result ;\n }\n\n function getLines(nodes , placeholderNode){\n\n    let layoutNodes = nodes.keys(),\n        lines = [];\n\n    for(let layoutNode of layoutNodes){\n\n        let parentNode = getParentNode(layoutNode) ;\n\n        if(parentNode){\n\n            let {\n                data:start,\n                centerXY:startCenterXY,\n                rightXY:startRightXY\n            } = nodes.get(parentNode),\n            {\n                data:end,\n                leftXY:endLeftXY\n            } = nodes.get(layoutNode);\n\n            lines.push({\n                indicated:layoutNode === placeholderNode,\n                start,\n                startCenterXY,\n                startRightXY,\n                end,\n                endLeftXY\n            }) ;\n        }\n    }\n\n    return lines ;\n }\n\n function getNodeDataset(nodes , offset){\n\n    let result = new Map(),\n        selectedNode;\n\n    for(let node of nodes){\n\n        let data = getData(node , offset),\n            region = from(data);\n\n        if(data.selected){\n\n            selectedNode = data ;\n        }\n\n        result.set(node , {\n            data,\n            centerXY:getAnchorXY(region , 'c'),\n            rightXY:getAnchorXY(region , 'r'),\n            leftXY:getAnchorXY(region , 'l')\n        })\n    }\n\n    return {\n        nodes:result,\n        selectedNode\n    } ;\n }\n\n\n\n\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613610852862.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.refresh"
  },
  "src::mindmap.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.constructor({<data.Reader> reader , <data.Reader> readConfig , <function> nodeSeparationDistance , <number> nodeVerticalSeparationDistance , <number> nodeHorizontalSeparationDistance , <number> nodeHorizontalLineBreakPointOffset , <number> nodeSpacing , <number> placeholderNodeWidth , <number> placeholderNodeHeight , <number> padding , <number> width , <number> height , <object> placeholderNodeData , <mixed> layout , <object> api})",
    "standard": true,
    "importNames": [
      "src::mindmap.node.create",
      "src::data.reader.json",
      "src::mindmap.node.field.hidden",
      "src::mindmap.node.field.selected",
      "src::mindmap.indicated",
      "src::function.buffer",
      "src::mindmap.layout",
      "src::mindmap.refresh",
      "src::is.object.simple",
      "src::is.array",
      "src::function.empty",
      "src::is.number",
      "src::is.string",
      "src::function.get",
      "src::mindmap.node.id.generate"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let createReader,buffer,isObject,isArray,emptyFn,isNumber,isString,get,generate;\n    \n                    let var_init_locked_1613625470749;\n \n                    \n\n                    const var_current_scope_1613625470749 = new Map();\n    \n                    return function({reader , readConfig = {} , nodeSeparationDistance , nodeVerticalSeparationDistance = 15 , nodeHorizontalSeparationDistance = 0 , nodeHorizontalLineBreakPointOffset = 12.5 , nodeSpacing = 5 , placeholderNodeWidth = 60 , placeholderNodeHeight = 20 , padding = 5 , width = 0 , height = 0 , placeholderNodeData = {} , layout , api = {}}){\n    \n                        \n        if(!var_init_locked_1613625470749){\n\n            createReader = include('src::data.reader.json');\nbuffer = include('src::function.buffer');\nisObject = include('src::is.object.simple');\nisArray = include('src::is.array');\nemptyFn = include('src::function.empty')();\nisNumber = include('src::is.number');\nisString = include('src::is.string');\nget = include('src::function.get');\ngenerate = include('src::mindmap.node.id.generate');\n\n            var_init_locked_1613625470749 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613625470749.has(this)){\n\n            var_current_scope_1613625470749.set(this , (() => {\n                const create = include('src::mindmap.node.create').bind(this);\nconst setHidden = include('src::mindmap.node.field.hidden').bind(this);\nconst setSelected = include('src::mindmap.node.field.selected').bind(this);\nconst setIndicated = include('src::mindmap.indicated').bind(this);\nconst doLayout = include('src::mindmap.layout').bind(this);\nconst doRefresh = include('src::mindmap.refresh').bind(this);\n\n                function main({reader , readConfig , nodeSeparationDistance , nodeVerticalSeparationDistance , nodeHorizontalSeparationDistance , nodeHorizontalLineBreakPointOffset , nodeSpacing , placeholderNodeWidth , placeholderNodeHeight , padding , width , height , placeholderNodeData , layout , api}){\n\n        \n/**\n * \n * 初始化脑图\n * \n * @import create from .node.create scoped\n * \n * @import createReader from data.reader.json\n * \n * @import setHidden from .node.field.hidden scoped\n * \n * @import setSelected from .node.field.selected scoped\n * \n * @import setIndicated from .indicated scoped\n * \n * @import buffer from function.buffer\n * \n * @import doLayout from .layout scoped\n * \n * @import doRefresh from .refresh scoped\n * \n * @import isObject from is.object.simple\n * \n * @import is.array\n * \n * @import emptyFn from function.empty value\n * \n * @import is.number\n * \n * @import is.string\n * \n * @import get from function.get\n * \n * @import generate from .node.id.generate\n * \n * @param {object} config 脑图配置\n * \n * @param {data.Reader} config.reader 数据读取配置\n * \n * @param {data.Reader} [config.readConfig = {}] 数据读取根路径设置\n * \n * @param {function} [config.nodeSeparationDistance] 节点间隔距离\n * \n * @param {number} [config.nodeVerticalSeparationDistance = 15] 节点垂直间隔距离\n * \n * @param {number} [config.nodeHorizontalSeparationDistance = 0] 节点水平间隔距离\n * \n * @param {number} [config.nodeHorizontalLineBreakPointOffset = 12.5] 脑图节点之间连线的折点的偏移位置\n * \n * @param {number} [config.nodeSpacing = 5] 节点间隔设置\n * \n * @param {number} [config.placeholderNodeWidth = 60] 占位符宽度\n * \n * @param {number} [config.placeholderNodeHeight = 20] 占位符高度\n * \n * @param {number} [config.padding = 5] 脑图四周填充距离\n * \n * @param {number} [config.width = 0] 脑图宽度\n * \n * @param {number} [config.height = 0] 脑图高度\n * \n * @param {object} [config.placeholderNodeData = {}] 占位脑图节点的其它配置\n * \n * @param {mixed} [config.layout] 布局模式\n * \n * @param {object} [config.api = {}] 附加 API\n * \n */\n\n let me = this ;\n\n {\n   let methods = Object.keys(api) ;\n\n   for(let method of methods){\n\n      me[method] = get(api[method] , me) ;\n   }\n }\n\n {\n\n   let layoutConfig = {} ;\n\n   if(isString(layout)){\n\n      layout = {\n         pattern:layout\n      };\n   \n   }else if(!isObject(layout)){\n\n      layout = {} ;\n   }\n\n   let {\n      createPositioner = 'mindmap.layout.positioner.logic.right',\n      pattern = 'mindmap.layout.pattern.logic.right',\n      getRootNode = 'mindmap.node.root',\n      getDescendantNodes = 'mindmap.nodes.descendant'\n   } = layout ;\n\n   layoutConfig.createPositioner = get(createPositioner , me) ;\n   \n   layoutConfig.pattern = get(pattern , me) ;\n\n   layoutConfig.getRootNode = get(getRootNode , me) ;\n\n   layoutConfig.getDescendantNodes = get(getDescendantNodes , me) ;\n\n   if(isNumber(nodeSpacing)){\n\n      nodeSpacing = {\n         top:nodeSpacing,\n         bottom:nodeSpacing,\n         left:nodeSpacing,\n         right:nodeSpacing\n      } ;\n   }\n\n   if(isObject(nodeSpacing)){\n\n      layoutConfig.nodeSpacing = nodeSpacing ;\n   \n   }\n\n   me.layoutConfig = layoutConfig ;\n   \n }\n\n me.nodes = new Map() ;\n\n me.unpublishedNodes = new Set() ;\n\n me.nodeSeparationDistance = nodeSeparationDistance ;\n\n me.nodeVerticalSeparationDistance = nodeVerticalSeparationDistance ;\n\n if(isObject(nodeHorizontalSeparationDistance)){\n\n   let {\n      max = 0,\n      min = 0\n   } = nodeHorizontalSeparationDistance ;\n\n   me.maxNodeHorizontalSeparationDistance = max ;\n\n   me.minNodeHorizontalSeparationDistance = min ;\n\n   nodeHorizontalSeparationDistance = 0 ;\n }\n\n me.nodeHorizontalSeparationDistance = nodeHorizontalSeparationDistance ;\n\n if(nodeHorizontalLineBreakPointOffset > nodeHorizontalSeparationDistance){\n\n   nodeHorizontalLineBreakPointOffset = nodeHorizontalSeparationDistance / 2;\n }\n\n me.nodeHorizontalLineBreakPointOffset = nodeHorizontalLineBreakPointOffset ;\n\n if(isNumber(padding)){\n\n   me.padding = {\n      top:padding,\n      bottom:padding,\n      left:padding,\n      right:padding\n   } ;\n\n }else if(isObject(padding)){\n\n   me.padding = Object.assign({\n      top:0,\n      bottom:0,\n      left:0,\n      right:0\n   } , padding) ;\n\n }else{\n\n   me.padding = {\n      top:0,\n      bottom:0,\n      left:0,\n      right:0\n   } ;\n }\n\n me.width = width ;\n\n me.height = height ;\n\n let mindmap = me,\n {\n    fields:readerFields,\n    addFields:readerAddFields = () => {}\n } = reader;\n \n reader = me.reader = createReader({\n         ...readerFields,\n         id:{\n            convert(){\n\n               return generate() ;\n            }\n         },\n         parentNodeId: {\n            local:true,\n            mode:'readwrite'\n          },\n         expanded:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:false\n         },\n         hidden:{\n            mode:'readwrite',\n            local:true,\n            set(hidden){\n\n               return setHidden(this , hidden) ;\n            },\n            defaultValue:true\n         },\n         level:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:-1\n         },\n         width:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:false\n         },\n         height:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:false\n         },\n         x:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:0\n         },\n         y:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:0\n         },\n         selected:{\n            mode:'readwrite',\n            local:true,\n            set(selected){\n\n               return setSelected(this , selected) ;\n\n            },\n            defaultValue:false\n         },\n         placeholder:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:false\n         },\n         restructuring:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:false\n         },\n         indicated:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:false,\n            set(indicated){\n\n               return setIndicated(this , indicated) ;\n            }\n         },\n         editing:{\n            mode:'readwrite',\n            local:true,\n            defaultValue:false\n         }\n      } , readerAddFields.bind(me)) ;\n\n me.readConfig = readConfig ;\n\n let placeholderNode = create(Object.assign({\n   width:placeholderNodeWidth,\n   height:placeholderNodeHeight,\n   placeholder:true\n } , placeholderNodeData)) ;\n\n me.placeholderNode = placeholderNode ;\n\n\n me.layout = buffer(doLayout) ;\n\n me.refresh = buffer(doRefresh) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613625470749.get(this) ;\n\n        \n    \n                        return main.call(this , {reader , readConfig , nodeSeparationDistance , nodeVerticalSeparationDistance , nodeHorizontalSeparationDistance , nodeHorizontalLineBreakPointOffset , nodeSpacing , placeholderNodeWidth , placeholderNodeHeight , padding , width , height , placeholderNodeData , layout , api}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.constructor"
  },
  "src::mindmap.load": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.load(<mixed> data , <mixed> readAsRoot)",
    "standard": true,
    "importNames": [
      "src::is.defined"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isDefined;\n    \n                    let var_init_locked_1613625470783;\n    \n                    \n\n                    \n/**\n * \n * 初始化脑图数据\n * \n * @import is.defined\n * \n * @param {mixed} data 数据\n * \n * @param {mixed} [readAsRoot] 获得脑图节点根读取入口\n * \n */\n\nfunction main(data , readAsRoot){\n\n  let me = this,\n  {\n    reader,\n    readConfig\n  } = me ;\n  \n  if(isDefined(readAsRoot)){\n  \n    readConfig = Object.assign({} , readConfig , {\n      root:readAsRoot\n    }) ;\n  }\n  \n  let rootNode = reader.read(data , {\n    ...readConfig,\n    multi:false\n  });\n\n  if(rootNode){\n\n      register_node.call(me , rootNode) ;\n\n      me.rootNode = rootNode ;\n\n      return rootNode ;\n\n  }\n}\n\nfunction register_node(node){\n\n  let {\n      id,\n      children\n  } = node,\n  me = this,\n  {\n    nodes\n  } = me;\n\n  nodes.set(id , node) ;\n\n  for(let childNode of children){\n\n    register_node.call(me , childNode) ;\n  }\n}\n    \n                    return function(data , readAsRoot){\n    \n                        \n        if(!var_init_locked_1613625470783){\n\n            isDefined = include('src::is.defined');\n\n            var_init_locked_1613625470783 = true ;\n        }\n        \n    \n                        return main.call(this , data , readAsRoot) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.load"
  },
  "src::mindmap.node.sibling.previous": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.node.sibling.previous(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.parent"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613566323059 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613566323059.has(this)){\n\n            var_current_scope_1613566323059.set(this , (() => {\n                const getParentNode = include('src::mindmap.node.parent').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 返回节点的上兄弟节点\n * \n * @import getParentNode from ..parent scoped\n * \n * @param {data.Record} node \n * \n * @return {data.Record} 上兄弟节点 \n * \n */\n\nlet parentNode = getParentNode(node) ;\n\nif(parentNode){\n\n    let {\n        children\n    } = parentNode;\n\n    return children[children.indexOf(node) - 1] ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613566323059.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.sibling.previous"
  },
  "src::mindmap.node.sibling.next": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.node.sibling.next(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.parent"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613566323070 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613566323070.has(this)){\n\n            var_current_scope_1613566323070.set(this , (() => {\n                const getParentNode = include('src::mindmap.node.parent').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 返回节点的下兄弟节点\n * \n * @import getParentNode from ..parent scoped\n * \n * @param {data.Record} node \n * \n * @return {data.Record} 下兄弟节点 \n * \n */\n\nlet parentNode = getParentNode(node) ;\n\nif(parentNode){\n\n    let {\n        children\n    } = parentNode;\n\n    return children[children.indexOf(node) + 1] ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613566323070.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.sibling.next"
  },
  "src::mindmap.nodes.descendant": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.nodes.descendant(<data.Record> node)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    \n/**\n * \n * 获得子孙节点\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {array} 子孙节点数组 \n * \n */\n\nfunction main(node){\n\n    return getDescendantNodes(node) ;\n }\n\n function getDescendantNodes({\n     expanded,\n     children\n }){\n\n    let result = [] ;\n\n    if(expanded){\n\n        for(let childNode of children){\n\n            result.push(childNode) ;\n\n            result.push(...getDescendantNodes(childNode)) ;\n        }\n\n        return result ;\n    }\n\n    return result ;\n }\n    \n                    return function(node){\n    \n                        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.nodes.descendant"
  },
  "src::mindmap.layout.nodes.child": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.layout.nodes.child(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.cache"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613370221958 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613370221958.has(this)){\n\n            var_current_scope_1613370221958.set(this , (() => {\n                const cache = include('src::mindmap.layout.cache').bind(this);\n\n                \n/**\n * \n * 获得子节点集合\n * \n * @import cache from mindmap.layout.cache scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {array} 子节点集合 \n * \n */\n\n function main(node){\n\n   return cache(node , 'getChildNodes' , getChildNodes) ;\n }\n\n function getChildNodes(node){\n\n   let {\n      children,\n      expanded\n   } = node;\n\n   if(!expanded){\n\n      return [] ;\n   }\n\n   let result = [],\n   {\n      layoutNodes\n   } = this;\n\n   for(let childNode of children){\n\n      if(layoutNodes.includes(childNode)){\n\n         result.push(childNode) ;\n      }\n   }\n\n   return result ;\n\n }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613370221958.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.nodes.child"
  },
  "src::mindmap.node.hide": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.hide(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.nodes.child",
      "src::mindmap.node.hide"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613707334244 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613707334244.has(this)){\n\n            var_current_scope_1613707334244.set(this , (() => {\n                const getChildNodes = include('src::mindmap.layout.nodes.child').bind(this);\nconst hide = include('src::mindmap.node.hide').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 显示节点\n * \n * @import getChildNodes from ..layout.nodes.child scoped\n * \n * @import hide from .hide scoped\n * \n * @param {data.Record} node 节点\n * \n */\n\nlet {\n    hidden\n } = node ;\n\n if(hidden){\n\n    return ;\n }\n\n let childNodes = getChildNodes(node) ;\n\n for(let childNode of childNodes){\n\n   hide(childNode) ;\n }\n\nnode.hidden = true ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613707334244.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.hide"
  },
  "src::mindmap.node.show": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.show(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.is.leaf",
      "src::mindmap.node.show"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613465726059 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613465726059.has(this)){\n\n            var_current_scope_1613465726059.set(this , (() => {\n                const isLeaf = include('src::mindmap.node.is.leaf').bind(this);\nconst show = include('src::mindmap.node.show').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 显示节点\n * \n * @import isLeaf from .is.leaf scoped\n * \n * @import show from .show scoped\n * \n * @param {data.Record} node 节点\n * \n */\n\n let {\n    hidden\n } = node ;\n\n if(!hidden){\n\n    return ;\n }\n\nnode.hidden = false ;\n\nlet {\n    expanded\n} = node ;\n\nif(expanded){\n\n    let {\n        children\n    } = node ;\n\n    for(let childNode of children){\n\n        show(childNode) ;\n    }\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613465726059.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.show"
  },
  "src::mindmap.node.expand": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.expand(<mixed> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.show",
      "src::mindmap.node.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613455282102 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613455282102.has(this)){\n\n            var_current_scope_1613455282102.set(this , (() => {\n                const show = include('src::mindmap.node.show').bind(this);\nconst from = include('src::mindmap.node.from').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 展开节点\n * \n * @import show from .show scoped\n * \n * @import from from .from scoped\n * \n * @param {mixed} node 节点\n * \n * @return {boolean} 如果正确展开则返回 true , 否则返回 false\n * \n */\n\nnode = from(node) ;\n\nif(node){\n\n    let {\n        expanded\n    } = node;\n\n    if(!expanded){\n\n        node.expanded = true ;\n\n        let {\n            children\n        } = node ;\n\n        for(let childNode of children){\n\n            show(childNode) ;\n        }\n\n        return true ;\n    }\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613455282102.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.expand"
  },
  "src::mindmap.node.select": {
    "meta": "code.meta.script.function",
    "signature": "<Boolean> src::mindmap.node.select(<mixed> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.data",
      "src::mindmap.node.parent",
      "src::mindmap.node.from",
      "src::mindmap.node.expand"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613610502168 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613610502168.has(this)){\n\n            var_current_scope_1613610502168.set(this , (() => {\n                const data = include('src::mindmap.node.data').bind(this);\nconst getParentNode = include('src::mindmap.node.parent').bind(this);\nconst from = include('src::mindmap.node.from').bind(this);\nconst expand = include('src::mindmap.node.expand').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 选定节点\n * \n * @import data from .data scoped\n * \n * @import getParentNode from .parent scoped\n * \n * @import from from .from scoped\n * \n * @import expand from .expand scoped\n * \n * @param {mixed} node 脑图节点\n * \n * @return {Boolean} 如果成功选定节点则返回 true , 否则返回  false\n * \n */\n\nnode = from(node) ;\n\nlet me = this,\n{\n  selectedNode\n} = me;\n\nif(node !== selectedNode){\n\n  if(node.hidden){\n\n      let parentNode,\n          baseNode = node,\n          parentNodes = [];\n\n      while(parentNode = getParentNode(baseNode)){\n\n        parentNodes.unshift(parentNode) ;\n\n        if(!parentNode.hidden){\n\n          break ;          \n        \n        }else{\n\n          baseNode = parentNode ; \n        }\n      }\n\n      for(let parentNode of parentNodes){\n\n        expand(parentNode) ;\n\n      }\n  }\n\n  node.selected = true ;\n\n  me.fireEvent('nodeselect' , data(node) , data(selectedNode)) ;\n\n  return true ;\n\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613610502168.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.select"
  },
  "src::mindmap.node.delete": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.delete(<mixed> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.is.root",
      "src::mindmap.node.parent",
      "src::mindmap.node.sibling.previous",
      "src::mindmap.node.sibling.next",
      "src::mindmap.node.data",
      "src::mindmap.nodes.descendant",
      "src::mindmap.node.hide",
      "src::mindmap.node.from",
      "src::mindmap.node.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613702696682 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613702696682.has(this)){\n\n            var_current_scope_1613702696682.set(this , (() => {\n                const isRootNode = include('src::mindmap.node.is.root').bind(this);\nconst getParentNode = include('src::mindmap.node.parent').bind(this);\nconst getPreviousNode = include('src::mindmap.node.sibling.previous').bind(this);\nconst getNextNode = include('src::mindmap.node.sibling.next').bind(this);\nconst data = include('src::mindmap.node.data').bind(this);\nconst getDescendantNodes = include('src::mindmap.nodes.descendant').bind(this);\nconst hide = include('src::mindmap.node.hide').bind(this);\nconst from = include('src::mindmap.node.from').bind(this);\nconst select = include('src::mindmap.node.select').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 删除节点\n * \n * @import isRootNode from .is.root scoped\n * \n * @import getParentNode from .parent scoped\n * \n * @import getPreviousNode from .sibling.previous scoped\n * \n * @import getNextNode from .sibling.next scoped\n * \n * @import data from .data scoped\n * \n * @import getDescendantNodes from ..nodes.descendant scoped\n * \n * @import hide from .hide scoped\n * \n * @import from from .from scoped\n * \n * @import select from .select scoped\n * \n * @param {mixed} node 节点\n * \n * @return {boolean} 删除标识\n */\n\nnode = from(node) ;\n\nlet parentNode = getParentNode(node) ;\n\nif(!isRootNode(node)){\n\n   select(getPreviousNode(node) || getNextNode(node) || parentNode) ;\n\n   hide(node) ;\n\n   let nodes = [\n       node,\n       ...getDescendantNodes(node)\n   ],\n   me = this,\n   {\n       nodes:originNodes\n   } = me;\n\n   for(let node of nodes){\n\n       node.parentNodeId = null ;\n\n       node.children.length = 0 ;\n\n       node.hidden = false ;\n\n       node.selected = false ;\n\n       originNodes.delete(node.id) ;\n   }\n\n    let {\n        children\n    } = parentNode;\n\n   children.splice(children.indexOf(node) , 1) ;\n\n   me.fireEvent('nodedelete' , data(node)) ;\n\n   return true ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613702696682.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.delete"
  },
  "src::mindmap.destroy": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.destroy()",
    "standard": true,
    "importNames": [
      "src::mindmap.node.delete"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613465726067 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613465726067.has(this)){\n\n            var_current_scope_1613465726067.set(this , (() => {\n                const remove = include('src::mindmap.node.delete').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 销毁脑图实例\n * \n * @import remove from .node.delete scoped\n * \n */\n\n let me = this,\n {\n    rootNode,\n    nodes,\n    visibilityNodes\n } = me,{\n    children\n } = rootNode ;\n\n me.removeAllListeners() ;\n\n for(let childNode of children){\n\n    remove(childNode) ;\n }\n\n nodes.clear() ;\n\n visibilityNodes.clear() ;\n\n\n\n\n\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613465726067.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.destroy"
  },
  "src::mindmap.resize": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.resize(<number> width , <number> height)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1608956299223 = new Map();\n    \n                    return function(width , height){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1608956299223.has(this)){\n\n            var_current_scope_1608956299223.set(this , (() => {\n                const layout = include('src::mindmap.layout').bind(this);\n\n                function main(width , height){\n\n        \n/**\n * \n * 重新计算大小\n * \n * @import layout from .layout scoped\n * \n * @param {number} width 宽度\n * \n * @param {number} height 高度\n * \n */\nlet me = this,\n{\n    width:mindmapWidth,\n    height:mindmapHeight\n} = me;\n\nif(mindmapWidth !== width || mindmapHeight !== height){\n\n    me.width = width;\n\n    me.height = height;\n\n    delete me.region ;\n\n    layout() ;\n\n    return true ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299223.get(this) ;\n\n        \n    \n                        return main.call(this , width , height) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.resize"
  },
  "src::mindmap.deselect": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.deselect()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 取消脑图选择\n * \n */\n\n let me = this,\n {\n    selectedNode\n } = me ;\n\n if(selectedNode){\n\n    selectedNode.selected = false ;\n\n    me.layout() ;\n }\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.deselect"
  },
  "src::mindmap.node.root": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.node.root()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 获得实际的根节点\n * \n * @return {data.Record} 根节点 \n * \n */\n\n return this.rootNode ;\n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.root"
  },
  "src::mindmap.nodes.relation.descendant": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.nodes.relation.descendant(<data.Reocrd> node , <boolean> isVisible)",
    "standard": true,
    "importNames": [
      "src::mindmap.nodes.relation.descendant"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getDescendantNodes;\n    \n                    let var_init_locked_1613568804328;\n    \n                    \n\n                    function main(node , isVisible){\n\n        \n/**\n * \n * 获取所有子孙节点\n * \n * @import getDescendantNodes from .descendant\n * \n * @param {data.Reocrd} node 节点\n * \n * @param {boolean} [isVisible = true] 是否只获取可见的节点\n * \n * @return {array} 节点集合\n * \n */\n\nlet {\n    descendantNodes\n} = node ;\n\nif(descendantNodes){\n\n    return descendantNodes ;\n}\n\nlet {\n    expanded,\n    children\n} = node;\n\ndescendantNodes = node.descendantNodes = [] ;\n\nif(expanded || !isVisible){\n\n    for(let childNode of children){\n\n        descendantNodes.push(childNode , ...getDescendantNodes(childNode , isVisible)) ;\n    }\n\n}\n\nreturn descendantNodes ;\n\n    }\n    \n                    return function(node , isVisible = true){\n    \n                        \n        if(!var_init_locked_1613568804328){\n\n            getDescendantNodes = include('src::mindmap.nodes.relation.descendant');\n\n            var_init_locked_1613568804328 = true ;\n        }\n        \n    \n                        return main.call(this , node , isVisible) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.nodes.relation.descendant"
  },
  "src::mindmap.node.expand.deep": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.expand.deep(<mixed> node , <number> level)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.from",
      "src::mindmap.node.expand"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613308340469 = new Map();\n    \n                    return function(node , level = 1){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613308340469.has(this)){\n\n            var_current_scope_1613308340469.set(this , (() => {\n                const from = include('src::mindmap.node.from').bind(this);\nconst expand = include('src::mindmap.node.expand').bind(this);\n\n                \n/**\n * \n * 深度展开节点\n * \n * @import from from ..from scoped\n * \n * @import expand from ..expand scoped\n * \n * @param {mixed} node 脑图节点\n * \n * @param {number} [level = 1] 展开层次\n * \n * @return {boolean} 如果有展开动作则返回 true , 否则返回 false\n * \n */\n\nfunction main(node , level){\n\n    return doDeepExpand(from(node) , 0 , level) ;\n}\n\nfunction doDeepExpand(node , level , maxLevel){\n\n    node.hidden = false ;\n\n    level ++ ;\n\n    if(level <= maxLevel){\n\n        let isExpand = false ;\n\n        if(expand(node)){\n\n            isExpand = true ;\n        }\n\n        let {\n            children\n        } = node ;\n\n        for(let childNode of children){\n\n            if(doDeepExpand(childNode , level , maxLevel)){\n\n                isExpand = true ;\n            }\n        }\n\n        if(isExpand){\n\n            return true ;\n        }\n    }\n\n    return false ;\n}\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340469.get(this) ;\n\n        \n    \n                        return main.call(this , node , level) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.expand.deep"
  },
  "src::mindmap.data.node.from": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.data.node.from(<mixed> node)",
    "standard": true,
    "importNames": [
      "src::is.string",
      "src::is.object",
      "src::mindmap.data.node.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isString,isObject;\n    \n                    let var_init_locked_1608956298947;\n \n                    \n\n                    const var_current_scope_1608956298947 = new Map();\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1608956298947){\n\n            isString = include('src::is.string');\nisObject = include('src::is.object');\n\n            var_init_locked_1608956298947 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956298947.has(this)){\n\n            var_current_scope_1608956298947.set(this , (() => {\n                const from = include('src::mindmap.data.node.from').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 根据所提供的标识来获得脑图节点\n * \n * @import is.string\n * \n * @import isObject from is.object\n * \n * @import from from .from scoped\n * \n * @param {mixed} node 脑图节点标识\n * \n * @return {data.Record} 脑图节点 \n * \n */\n\n let {\n    nodes\n } = this ;\n\nif(isString(node)){\n\n    return nodes.get(node) ;\n\n}else if(isObject(node)){\n\n   let {\n       id\n   } = node ;\n\n   return from(id) ;\n}\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956298947.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.data.node.from"
  },
  "src::mindmap.data.nodes.descendant": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.data.nodes.descendant(<mixed> node , <function> fn)",
    "standard": true,
    "importNames": [
      "src::mindmap.data.node.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613308340390 = new Map();\n    \n                    return function(node , fn){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613308340390.has(this)){\n\n            var_current_scope_1613308340390.set(this , (() => {\n                const from = include('src::mindmap.data.node.from').bind(this);\n\n                \n/**\n * \n * 获得所有的子孙节点\n * \n * @import from from ..node.from scoped\n * \n * @param {mixed} node 脑图节点\n * \n * @param {function} fn 查询条件函数\n * \n * @return {array} 节点集合 \n * \n */\n\nfunction main(node , fn){\n\n    node = from(node) ;\n\n    let nodes = getDescendantNodes(node , fn || (() => ({\n        result:true,\n        next:true\n    }))) ;\n\n    if(nodes.length && nodes[0].id === node.id){\n\n        nodes.shift() ;\n    }\n    \n    return nodes ;\n}\n\nfunction getDescendantNodes(node , fn){\n\n    let {\n        result,\n        next\n    } = fn(node),\n    nodes = [];\n\n    if(result){\n\n        nodes.push(node) ;\n    }\n\n    if(next){\n\n        let {\n            children\n        } = node ;\n\n        for(let childNode of children){\n\n            nodes.push(...getDescendantNodes(childNode , fn)) ;\n        }\n    }\n\n    return nodes ;\n}\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340390.get(this) ;\n\n        \n    \n                        return main.call(this , node , fn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.data.nodes.descendant"
  },
  "src::mindmap.node.collapse.deep": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.collapse.deep(<mixed> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.from",
      "src::mindmap.data.nodes.descendant"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613308340478 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613308340478.has(this)){\n\n            var_current_scope_1613308340478.set(this , (() => {\n                const from = include('src::mindmap.node.from').bind(this);\nconst getDescendantNodes = include('src::mindmap.data.nodes.descendant').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 深度收起\n * \n * @import from from ..from scoped\n * \n * @import getDescendantNodes from ....data.nodes.descendant scoped\n * \n * @param {mixed} node 脑图节点\n * \n * \n */\n\n node = from(node) ;\n\n if(!node.hidden){\n\n    node.expanded = false ;\n\n    let nodes = getDescendantNodes(node),\n        isCollapse = false;\n\n    for(let node of nodes){\n\n        let {\n            children,\n            expanded,\n            hidden\n        } = node ;\n\n        if(!hidden && children.length && expanded){\n\n            isCollapse = true ;\n        }\n\n        node.expanded = false ;\n\n        node.hidden = true ;\n    }\n\n    return isCollapse ;\n }\n\n return false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340478.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.collapse.deep"
  },
  "src::mindmap.node.reset": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.reset(<mixed> rootNode , <number> level)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.from",
      "src::mindmap.nodes.relation.descendant",
      "src::mindmap.node.expand.deep",
      "src::mindmap.node.collapse.deep"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613308340475 = new Map();\n    \n                    return function(rootNode , level = 1){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613308340475.has(this)){\n\n            var_current_scope_1613308340475.set(this , (() => {\n                const from = include('src::mindmap.node.from').bind(this);\nconst getDescendantNodes = include('src::mindmap.nodes.relation.descendant').bind(this);\nconst expand = include('src::mindmap.node.expand.deep').bind(this);\nconst collapse = include('src::mindmap.node.collapse.deep').bind(this);\n\n                function main(rootNode , level){\n\n        \n/**\n * \n * 重置脑图\n * \n * @import from from .from scoped\n * \n * @import getDescendantNodes from ..nodes.relation.descendant scoped\n * \n * @import expand from .expand.deep scoped\n * \n * @import collapse from .collapse.deep scoped\n * \n * @param {mixed} rootNode 脑图节点\n * \n * @param {number} [level = 1] 显示层数\n * \n * @return {boolean} 如果发生重置行为则返回 true , 否则返回 false\n * \n */\n\n rootNode = from(rootNode) ;\n\nlet {\n    level:maxNodeLevel\n} = rootNode,\nisReset = false;\n\nif(expand(rootNode , level)){\n\n    isReset = true ;\n}\n\nmaxNodeLevel += level ;\n\nlet nodes = getDescendantNodes(rootNode) ;\n\nfor(let node of nodes){\n\n    let {\n        level:nodeLevel\n    } = node ;\n\n    if(nodeLevel === maxNodeLevel){\n\n        if(collapse(node)){\n\n            isReset = true ;\n        }\n    }\n}\n\nreturn isReset ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340475.get(this) ;\n\n        \n    \n                        return main.call(this , rootNode , level) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.reset"
  },
  "src::mindmap.reset": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.reset(<number> level)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.root",
      "src::mindmap.node.reset",
      "src::mindmap.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613308340555 = new Map();\n    \n                    return function(level){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613308340555.has(this)){\n\n            var_current_scope_1613308340555.set(this , (() => {\n                const getRootNode = include('src::mindmap.node.root').bind(this);\nconst reset = include('src::mindmap.node.reset').bind(this);\nconst select = include('src::mindmap.select').bind(this);\n\n                function main(level){\n\n        \n/**\n * \n * 重置脑图\n * \n * @import getRootNode from .node.root scoped\n * \n * @import reset from .node.reset scoped\n * \n * @import select from .select scoped\n * \n * @param {number} [level] 显示层数\n * \n */\n\nlet rootNode = getRootNode(),\n    isSelect = select(rootNode),\n    isReset = reset(rootNode , level) ;\n\nif(!isSelect && isReset){\n\n    this.layout() ;\n}\n\n\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340555.get(this) ;\n\n        \n    \n                        return main.call(this , level) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.reset"
  },
  "src::mindmap.node.focus": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.focus(<mixed> node , <number> level)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.from",
      "src::mindmap.node.reset"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613308340473 = new Map();\n    \n                    return function(node , level){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613308340473.has(this)){\n\n            var_current_scope_1613308340473.set(this , (() => {\n                const from = include('src::mindmap.node.from').bind(this);\nconst reset = include('src::mindmap.node.reset').bind(this);\n\n                function main(node , level){\n\n        \n/**\n * \n * 聚焦节点\n * \n * @import from from .from scoped\n * \n * @import reset from .reset scoped\n * \n * @param {mixed} node 脑图节点\n * \n * @param {number} [level] 显示层数\n * \n * @return {boolean} 如果聚焦成功则返回 true , 否则返回 false\n * \n */\n\n let me = this,\n {\n    focusNode\n } = me;\n\n node = from(node) ;\n\n if(focusNode !== node){\n\n    reset(node , level) ;\n\n    me.focusNode = node ;\n\n    return true ;\n }\n\n return false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340473.get(this) ;\n\n        \n    \n                        return main.call(this , node , level) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.focus"
  },
  "src::mindmap.focus": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.focus(<mixed> node , <number> level)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.root",
      "src::mindmap.select",
      "src::mindmap.node.focus"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613308340471 = new Map();\n    \n                    return function(node , level){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613308340471.has(this)){\n\n            var_current_scope_1613308340471.set(this , (() => {\n                const getRootNode = include('src::mindmap.node.root').bind(this);\nconst select = include('src::mindmap.select').bind(this);\nconst focus = include('src::mindmap.node.focus').bind(this);\n\n                function main(node , level){\n\n        \n/**\n * \n * 聚焦节点\n * \n * @import getRootNode from .node.root scoped\n * \n * @import select from .select scoped\n * \n * @import focus from .node.focus scoped\n * \n * @param {mixed} node 脑图节点\n * \n * @param {number} [level] 显示层数\n * \n */\n\nlet isSelect = select(node),\n    isFocus = focus(node , level) ;\n\nif(!isSelect && isFocus){\n\n    this.layout() ;\n}\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340471.get(this) ;\n\n        \n    \n                        return main.call(this , node , level) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.focus"
  },
  "src::mindmap.node.collapse": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.collapse(<mixed> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.hide",
      "src::mindmap.node.select",
      "src::mindmap.node.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613455282110 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613455282110.has(this)){\n\n            var_current_scope_1613455282110.set(this , (() => {\n                const hide = include('src::mindmap.node.hide').bind(this);\nconst select = include('src::mindmap.node.select').bind(this);\nconst from = include('src::mindmap.node.from').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 收起节点\n * \n * @import hide from .hide scoped\n * \n * @import select from .select scoped\n * \n * @import from from .from scoped\n * \n * @param {mixed} node 脑图节点\n * \n * @return {boolean} 如果收起动作执行则返回 true , 否则返回 false\n * \n */\n\n node = from(node) ;\n\nlet {\n    expanded\n} = node;\n\nif(expanded){\n\n    let {\n        children\n    } = node,\n    {\n        selectedNode\n    } = this;\n\n    for(let childNode of children){\n\n        hide(childNode) ;\n    }\n\n    node.expanded = false ;\n\n    if(selectedNode.hidden){\n\n        select(node) ;\n    }\n\n    return true ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613455282110.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.collapse"
  },
  "src::mindmap.node.value.set": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.value.set(<string> field , <mixed> value , <mixed> node)",
    "standard": true,
    "importNames": [
      "src::data.equals",
      "src::data.clone",
      "src::mindmap.node.from",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let equals,clone;\n    \n                    let var_init_locked_1613640663311;\n \n                    \n\n                    const var_current_scope_1613640663311 = new Map();\n    \n                    return function(field , value , node){\n    \n                        \n        if(!var_init_locked_1613640663311){\n\n            equals = include('src::data.equals');\nclone = include('src::data.clone');\n\n            var_init_locked_1613640663311 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613640663311.has(this)){\n\n            var_current_scope_1613640663311.set(this , (() => {\n                const from = include('src::mindmap.node.from').bind(this);\nconst data = include('src::mindmap.node.data').bind(this);\n\n                function main(field , value , node){\n\n        /**\n * \n * 设置或获取节点值\n * \n * @import equals from data.equals\n * \n * @import clone from data.clone\n * \n * @import from from ..from scoped\n * \n * @import data from ..data scoped\n * \n * @param {string} field 字段名称\n * \n * @param {mixed} value 字段值\n * \n * @param {mixed} [node] 节点\n * \n */\n\n node = from(node) ;\n\nlet oldValue = node[field],\n    newValue = node[field] = clone(value),\n{\n    id\n} = node ;\n\nif(!equals(newValue , oldValue)){\n\n    node = data(node) ;\n\n    let me = this ;\n\n    me.fireEvent(`node${field.toLowerCase()}change` , node , value , oldValue) ;\n\n    me.fireEvent('nodechange' , node , field , value , oldValue) ;\n\n    return true ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613640663311.get(this) ;\n\n        \n    \n                        return main.call(this , field , value , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.value.set"
  },
  "src::mindmap.node.child.last": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.child.last(<data.Record> node)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node){\n\n        \n/**\n * \n * 获取第一个子节点\n * \n * @param {data.Record} node 节点\n * \n */\n\n let {\n    children\n } = node,\n {\n    length\n } = children;\n\n if(length){\n\n    return children[length - 1] ; \n }\n\n    }\n    \n                    return function(node){\n    \n                        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.child.last"
  },
  "src::mindmap.node.append": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.append(<mixed> node , <mixed> parentNode)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.data",
      "src::mindmap.node.show",
      "src::mindmap.node.child.last",
      "src::mindmap.node.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613704362235 = new Map();\n    \n                    return function(node , parentNode){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613704362235.has(this)){\n\n            var_current_scope_1613704362235.set(this , (() => {\n                const data = include('src::mindmap.node.data').bind(this);\nconst show = include('src::mindmap.node.show').bind(this);\nconst getLastChildNode = include('src::mindmap.node.child.last').bind(this);\nconst from = include('src::mindmap.node.from').bind(this);\n\n                function main(node , parentNode){\n\n        \n/**\n * \n * 添加子节点\n * \n * @import data from .data scoped\n * \n * @import show from .show scoped\n * \n * @import getLastChildNode from .child.last scoped\n * \n * @import from from .from scoped\n * \n * @param {mixed} node 节点配置\n * \n * @param {mixed} parentNode 节点\n * \n * @return {boolean} 添加标识\n * \n */\n\n node = from(node) ;\n\n parentNode = from(parentNode) ;\n\nif((parentNode === node || getLastChildNode(parentNode) === node)){\n\n  return false;\n\n}\n\nif(node.parentNodeId){\n\n  let {\n      children\n  } = getParentNode(node) ;\n\n  node.parentNodeId = null ;\n\n  node.hidden = true ;\n\n  children.splice(children.indexOf(node) , 1) ;\n}\n\nlet {\n    children,\n    hidden,\n    expanded\n} = parentNode;\n\nchildren.push(node) ;\n\nnode.parentNodeId = parentNode.id ;\n\nif(!hidden && expanded){\n\n  show(node) ;\n}\n\nthis.fireEvent('nodeappend' , data(node) , data(parentNode)) ;\n\nreturn true ;\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613704362235.get(this) ;\n\n        \n    \n                        return main.call(this , node , parentNode) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.append"
  },
  "src::mindmap.node.append.new": {
    "meta": "code.meta.script.function",
    "signature": "<boolea> src::mindmap.node.append.new(<mixed> parentNode)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.create",
      "src::mindmap.node.append",
      "src::mindmap.node.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613703183716 = new Map();\n    \n                    return function(parentNode){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613703183716.has(this)){\n\n            var_current_scope_1613703183716.set(this , (() => {\n                const create = include('src::mindmap.node.create').bind(this);\nconst append = include('src::mindmap.node.append').bind(this);\nconst select = include('src::mindmap.node.select').bind(this);\n\n                function main(parentNode){\n\n        \n/**\n * \n * 添加新建节点\n * \n * @import create from ..create scoped\n * \n * @import append from ..append scoped\n * \n * @import select from ..select scoped\n * \n * @param {mixed} [parentNode] 参照节点\n * \n * @return {boolea} 添加状态标识\n * \n */\n\nlet node = create() ;\n\nif(append(node , parentNode)){\n\n   select(node) ;\n\n   return true ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613703183716.get(this) ;\n\n        \n    \n                        return main.call(this , parentNode) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.append.new"
  },
  "src::mindmap.node.insert": {
    "meta": "code.meta.script.function",
    "signature": "<boolea> src::mindmap.node.insert(<mixed> insertNode , <mixed> baseNode , <string> region)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.data",
      "src::mindmap.node.is.root",
      "src::mindmap.node.parent",
      "src::mindmap.node.sibling.previous",
      "src::mindmap.node.sibling.next",
      "src::mindmap.node.show",
      "src::mindmap.node.from"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613700972954 = new Map();\n    \n                    return function(insertNode , baseNode , region){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613700972954.has(this)){\n\n            var_current_scope_1613700972954.set(this , (() => {\n                const data = include('src::mindmap.node.data').bind(this);\nconst isRootNode = include('src::mindmap.node.is.root').bind(this);\nconst getParentNode = include('src::mindmap.node.parent').bind(this);\nconst getPreviousNode = include('src::mindmap.node.sibling.previous').bind(this);\nconst getNextNode = include('src::mindmap.node.sibling.next').bind(this);\nconst show = include('src::mindmap.node.show').bind(this);\nconst from = include('src::mindmap.node.from').bind(this);\n\n                function main(insertNode , baseNode , region){\n\n        \n/**\n * \n * 插入节点\n * \n * @import data from .data scoped\n * \n * @import isRootNode from .is.root scoped\n * \n * @import getParentNode from .parent scoped\n * \n * @import getPreviousNode from .sibling.previous scoped\n * \n * @import getNextNode from .sibling.next scoped\n * \n * @import show from .show scoped\n * \n * @import from from .from scoped\n * \n * @param {mixed} insertNode 需要插入的节点\n * \n * @param {mixed} baseNode 参照节点\n * \n * @param {string} region 插入偏移位置\n * \n * @return {boolea} 插入状态标识\n * \n */\n\n insertNode = from(insertNode) ;\n\n baseNode = from(baseNode) ;\n\nif(!isRootNode(baseNode)){\n\n    if(insertNode){\n\n        if(insertNode === baseNode){\n\n            return false;\n        }\n\n        switch(region){\n\n            case 'before':\n\n                if(getPreviousNode(baseNode) === insertNode){\n\n                    return false;\n                }\n\n                break;\n\n            case 'after':\n\n                if(getNextNode(baseNode) === insertNode){\n\n                    return false;\n                }\n        }\n    }\n\n    if(insertNode.parentNodeId){\n\n        let {\n            children\n        } = getParentNode(insertNode) ;\n\n        insertNode.parentNodeId = null ;\n\n        insertNode.hidden = true ;\n\n        children.splice(children.indexOf(insertNode) , 1) ;\n    }\n\n    let parentNode = getParentNode(baseNode),\n    {\n        children\n    } = parentNode,\n    {\n        length\n    } = children;\n\n    let index = children.indexOf(baseNode) ;\n\n    if(region === 'after'){\n\n        index ++ ;\n    }\n\n    if(index > length - 1){\n\n        index = length ;\n    \n    }\n\n    children.splice(index , 0 , insertNode) ;\n\n    insertNode.parentNodeId = parentNode.id ;\n\n    if(!baseNode.hidden){\n\n        show(insertNode) ;\n    }\n\n    this.fireEvent(`nodeinsert${region}` , data(insertNode) , data(baseNode) , data(parentNode)) ;\n\n    return true ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613700972954.get(this) ;\n\n        \n    \n                        return main.call(this , insertNode , baseNode , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.insert"
  },
  "src::mindmap.node.insert.new": {
    "meta": "code.meta.script.function",
    "signature": "<boolea> src::mindmap.node.insert.new(<mixed> baseNode , <string> region)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.create",
      "src::mindmap.node.insert",
      "src::mindmap.node.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613700972942 = new Map();\n    \n                    return function(baseNode , region){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613700972942.has(this)){\n\n            var_current_scope_1613700972942.set(this , (() => {\n                const create = include('src::mindmap.node.create').bind(this);\nconst insert = include('src::mindmap.node.insert').bind(this);\nconst select = include('src::mindmap.node.select').bind(this);\n\n                function main(baseNode , region){\n\n        \n/**\n * \n * 插入新建节点\n * \n * @import create from ..create scoped\n * \n * @import insert from ..insert scoped\n * \n * @import select from ..select scoped\n * \n * @param {mixed} baseNode 参照节点\n * \n * @param {string} region 位置\n * \n * @return {boolea} 插入状态标识\n * \n */\n\n let insertNode = create() ;\n\n if(insert(insertNode , baseNode , region)){\n\n    select(insertNode) ;\n\n    return true ;\n }\n\n return false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613700972942.get(this) ;\n\n        \n    \n                        return main.call(this , baseNode , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.insert.new"
  },
  "src::mindmap.node.insert.new.before": {
    "meta": "code.meta.script.function",
    "signature": "<boolea> src::mindmap.node.insert.new.before(<data.Record> beforeNode)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.insert.new"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613634000869 = new Map();\n    \n                    return function(beforeNode){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613634000869.has(this)){\n\n            var_current_scope_1613634000869.set(this , (() => {\n                const insert = include('src::mindmap.node.insert.new').bind(this);\n\n                function main(beforeNode){\n\n        \n/**\n * \n * 插入创建节点\n * \n * @import insert from ..new scoped\n * \n * @param {data.Record} beforeNode 参照节点\n * \n * @return {boolea} 插入状态标识\n * \n */\n\nreturn insert(beforeNode , 'before') ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613634000869.get(this) ;\n\n        \n    \n                        return main.call(this , beforeNode) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.insert.new.before"
  },
  "src::mindmap.node.insert.new.after": {
    "meta": "code.meta.script.function",
    "signature": "<boolea> src::mindmap.node.insert.new.after(<data.Record> afterNode)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.insert.new"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613634000877 = new Map();\n    \n                    return function(afterNode){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613634000877.has(this)){\n\n            var_current_scope_1613634000877.set(this , (() => {\n                const insert = include('src::mindmap.node.insert.new').bind(this);\n\n                function main(afterNode){\n\n        \n/**\n * \n * 插入创建节点\n * \n * @import insert from ..new scoped\n * \n * @param {data.Record} afterNode 参照节点\n * \n * @return {boolea} 插入状态标识\n * \n */\n\nreturn insert(afterNode , 'after') ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613634000877.get(this) ;\n\n        \n    \n                        return main.call(this , afterNode) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.insert.new.after"
  },
  "src::mindmap.node.restructure.start": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.restructure.start(<string> id)",
    "standard": true,
    "importNames": [
      "src::mindmap.nodes.relation.descendant",
      "src::mindmap.node.is.root",
      "src::mindmap.fire.draw",
      "src::mindmap.node.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getDescendantNodes;\n    \n                    let var_init_locked_1608956299343;\n \n                    \n\n                    const var_current_scope_1608956299343 = new Map();\n    \n                    return function(id){\n    \n                        \n        if(!var_init_locked_1608956299343){\n\n            getDescendantNodes = include('src::mindmap.nodes.relation.descendant');\n\n            var_init_locked_1608956299343 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299343.has(this)){\n\n            var_current_scope_1608956299343.set(this , (() => {\n                const isRootNode = include('src::mindmap.node.is.root').bind(this);\nconst fireDrawEvent = include('src::mindmap.fire.draw').bind(this);\nconst get = include('src::mindmap.node.get').bind(this);\n\n                function main(id){\n\n        \n/**\n * \n * 开始重组节点\n * \n * @import getDescendantNodes from ....nodes.relation.descendant\n * \n * @import isRootNode from ....node.is.root scoped\n * \n * @import fireDrawEvent from ....fire.draw scoped\n * \n * @import get from ..get scoped\n * \n * @param {string} id 节点编号\n * \n */\n\n let me = this,\n     selectedNode = get(id) ;\n\n if(!selectedNode || isRootNode(selectedNode)){\n\n    return ;\n }\n\n me.restructuring = true ;\n\n selectedNode.restructuring = true ;\n\n me.restructuredNode = selectedNode ;\n\n let nodes = getDescendantNodes(selectedNode) ;\n\n for(let node of nodes){\n\n   node.restructuring = true ;\n }\n\n fireDrawEvent() ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299343.get(this) ;\n\n        \n    \n                        return main.call(this , id) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.restructure.start"
  },
  "src::mindmap.node.is.visibility": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.is.visibility(<data.Record> node)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node){\n\n        \n/**\n * \n * 是否为可见节点\n * \n * @param {data.Record}  node\n * \n * @return {boolean} 如果为可见节点则返回 true , 否则返回 false \n * \n */\n\n return node.hidden === false;\n\n    }\n    \n                    return function(node){\n    \n                        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.is.visibility"
  },
  "src::mindmap.node.insert.before": {
    "meta": "code.meta.script.function",
    "signature": "<boolea> src::mindmap.node.insert.before(<data.Record> insertNode , <data.Record> beforeNode)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.insert"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613566323036 = new Map();\n    \n                    return function(insertNode , beforeNode){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613566323036.has(this)){\n\n            var_current_scope_1613566323036.set(this , (() => {\n                const insert = include('src::mindmap.node.insert').bind(this);\n\n                function main(insertNode , beforeNode){\n\n        \n/**\n * \n * 插入节点\n * \n * @import insert from ..insert scoped\n * \n * @param {data.Record} insertNode 需要插入的节点\n * \n * @param {data.Record} beforeNode 参照节点\n * \n * @return {boolea} 插入状态标识\n * \n */\n\n return insert(insertNode , beforeNode , 'before') ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613566323036.get(this) ;\n\n        \n    \n                        return main.call(this , insertNode , beforeNode) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.insert.before"
  },
  "src::mindmap.node.insert.after": {
    "meta": "code.meta.script.function",
    "signature": "<boolea> src::mindmap.node.insert.after(<data.Record> insertNode , <data.Record> afterNode)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.insert"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613566323055 = new Map();\n    \n                    return function(insertNode , afterNode){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613566323055.has(this)){\n\n            var_current_scope_1613566323055.set(this , (() => {\n                const insert = include('src::mindmap.node.insert').bind(this);\n\n                function main(insertNode , afterNode){\n\n        \n/**\n * \n * 插入节点\n * \n * @import insert from ..insert scoped\n * \n * @param {data.Record} insertNode 需要插入的节点\n * \n * @param {data.Record} afterNode 参照节点\n * \n * @return {boolea} 插入状态标识\n * \n */\n\nreturn insert(insertNode , afterNode , 'after') ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613566323055.get(this) ;\n\n        \n    \n                        return main.call(this , insertNode , afterNode) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.insert.after"
  },
  "src::mindmap.node.restructure.preinsert": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.restructure.preinsert(<data.Record> node , <object> xy)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.is.visibility",
      "src::mindmap.node.parent",
      "src::mindmap.node.insert.before",
      "src::mindmap.node.insert.after",
      "src::math.region.outOfBoundOffset.y",
      "src::math.region.contains",
      "src::math.region.from",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is,getOutOfBoundOffsetY,contains,from;\n    \n                    let var_init_locked_1608956299352;\n \n                    \n\n                    const var_current_scope_1608956299352 = new Map();\n    \n                    return function(node , xy){\n    \n                        \n        if(!var_init_locked_1608956299352){\n\n            is = include('src::mindmap.node.is.visibility');\ngetOutOfBoundOffsetY = include('src::math.region.outOfBoundOffset.y');\ncontains = include('src::math.region.contains');\nfrom = include('src::math.region.from');\n\n            var_init_locked_1608956299352 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299352.has(this)){\n\n            var_current_scope_1608956299352.set(this , (() => {\n                const getParentNode = include('src::mindmap.node.parent').bind(this);\nconst insertBefore = include('src::mindmap.node.insert.before').bind(this);\nconst insertAfter = include('src::mindmap.node.insert.after').bind(this);\nconst data = include('src::mindmap.node.data').bind(this);\n\n                function main(node , xy){\n\n        \n/**\n * \n * 预插入节点\n * \n * @import is from ..is.visibility\n * \n * @import getParentNode from ..parent scoped\n * \n * @import insertBefore from ..insert.before scoped\n * \n * @import insertAfter from ..insert.after scoped\n * \n * @import getOutOfBoundOffsetY from math.region.outOfBoundOffset.y\n * \n * @import contains from math.region.contains\n * \n * @import from from math.region.from\n * \n * @import data from ..data scoped\n * \n * @param {data.Record} node 节点\n * \n * @param {object} xy 坐标信息\n * \n * @return {boolean} 插入如果成功执行则返回 true , 否则返回 false\n * \n */\n\nif(is(node)){\n\n    let region = from(data(node)),\n    {\n        y\n    } = xy,\n    outY = getOutOfBoundOffsetY(region , y),\n    {\n        placeholderNode\n    } = this,\n    result;\n\n    if(outY > 0){\n\n        result = insertBefore(placeholderNode , node) ;\n    \n    }else if(outY < 0){\n\n        result = insertAfter(placeholderNode , node) ;\n    \n    }else{\n\n        let {\n            top:nodeY\n        } = region,\n        {\n            height\n        } = node;\n\n        if(y <= nodeY + height / 2){\n\n            result = insertBefore(placeholderNode , node) ;\n\n        }else{\n\n            result = insertAfter(placeholderNode , node) ;\n        }\n    }\n\n    return !! result ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299352.get(this) ;\n\n        \n    \n                        return main.call(this , node , xy) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.restructure.preinsert"
  },
  "src::mindmap.node.is.normal": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.is.normal(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.is.visibility"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let is;\n    \n                    let var_init_locked_1608956299055;\n    \n                    \n\n                    function main(node){\n\n        \n/**\n * \n * 是否为正常可见节点\n * \n * @import is from .visibility\n * \n * @param {data.Record}  node\n * \n * @return {boolean} 如果为正常节点则返回 true , 否则返回 false \n * \n */\n\n return is(node) && node.placeholder === false && node.restructuring === false;\n\n    }\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1608956299055){\n\n            is = include('src::mindmap.node.is.visibility');\n\n            var_init_locked_1608956299055 = true ;\n        }\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.is.normal"
  },
  "src::mindmap.node.restructure": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.restructure(<object> xy , <string> id)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.expand",
      "src::mindmap.node.restructure.preinsert",
      "src::mindmap.node.append",
      "src::math.region.outOfBoundOffset.y",
      "src::math.region.from",
      "src::mindmap.node.get",
      "src::mindmap.node.is.normal"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getOutOfBoundOffsetY,from,is;\n    \n                    let var_init_locked_1613308340539;\n \n                    \n\n                    const var_current_scope_1613308340539 = new Map();\n    \n                    return function(xy , id){\n    \n                        \n        if(!var_init_locked_1613308340539){\n\n            getOutOfBoundOffsetY = include('src::math.region.outOfBoundOffset.y');\nfrom = include('src::math.region.from');\nis = include('src::mindmap.node.is.normal');\n\n            var_init_locked_1613308340539 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613308340539.has(this)){\n\n            var_current_scope_1613308340539.set(this , (() => {\n                const expand = include('src::mindmap.node.expand').bind(this);\nconst preinsert = include('src::mindmap.node.restructure.preinsert').bind(this);\nconst append = include('src::mindmap.node.append').bind(this);\nconst get = include('src::mindmap.node.get').bind(this);\n\n                function main(xy , id){\n\n        \n/**\n * \n * 重构\n * \n * @import expand from .expand scoped\n * \n * @import preinsert from .restructure.preinsert scoped\n * \n * @import append from .append scoped\n * \n * @import getOutOfBoundOffsetY from math.region.outOfBoundOffset.y\n * \n * @import from from math.region.from\n * \n * @import get from .get scoped\n * \n * @import is from .is.normal\n * \n * @param {object} xy 坐标\n * \n * @param {string} [id] 节点编号\n * \n */\n\nlet me = this,\n{\n    restructureIndicateLocked,\n    restructuring,\n    visibilityNodes,\n    placeholderNode\n} = me;\n\nif(!restructuring || restructureIndicateLocked){\n\n    return ;\n}\n\n if(id){\n\n    let node = get(id) ;\n\n    if(is(node) && preinsert(node , xy)){\n\n        me.layout() ;\n    }\n\n }else{\n\n    let parentNode = visibilityNodes.getNearestParentNode(xy) ;\n\n    if(parentNode){\n\n        parentNode.indicated = true ;\n\n        if(!parentNode.expanded){\n\n            me.restructureIndicateLocked = true ;\n\n            expand(parentNode) ;\n\n            me.layout() ;\n\n            me.restructureIndicateLocked = false ;\n\n            return ;\n        \n        }\n\n        let {\n            children\n        } = parentNode,\n        {\n            y\n        } = xy;\n\n        for(let childNode of children){\n\n            if(!is(childNode)){\n\n                continue ;\n            }\n\n            let offsetY = getOutOfBoundOffsetY(from(childNode) , y) ;\n\n            if(offsetY >= 0){\n\n                if(preinsert(childNode , xy)){\n\n                    me.layout() ;\n                }\n                \n                return ;\n            }\n        }\n\n        if(append(placeholderNode , parentNode)){\n\n            me.layout() ;\n        }\n    }\n }\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340539.get(this) ;\n\n        \n    \n                        return main.call(this , xy , id) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.restructure"
  },
  "src::mindmap.node.restructure.end": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.node.restructure.end(<function> beforeMoveFn)",
    "standard": true,
    "importNames": [
      "src::mindmap.nodes.relation.descendant",
      "src::mindmap.fire.draw",
      "src::mindmap.node.parent",
      "src::mindmap.node.delete",
      "src::mindmap.node.insert.before",
      "src::mindmap.node.show",
      "src::mindmap.node.is.visibility",
      "src::mindmap.node.data",
      "src::mindmap.node.sibling.previous",
      "src::mindmap.node.sibling.next",
      "src::mindmap.order"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getDescendantNodes,is;\n    \n                    let var_init_locked_1613308340534;\n \n                    \n\n                    const var_current_scope_1613308340534 = new Map();\n    \n                    return function(beforeMoveFn = () => true){\n    \n                        \n        if(!var_init_locked_1613308340534){\n\n            getDescendantNodes = include('src::mindmap.nodes.relation.descendant');\nis = include('src::mindmap.node.is.visibility');\n\n            var_init_locked_1613308340534 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613308340534.has(this)){\n\n            var_current_scope_1613308340534.set(this , (() => {\n                const fireDrawEvent = include('src::mindmap.fire.draw').bind(this);\nconst getParentNode = include('src::mindmap.node.parent').bind(this);\nconst remove = include('src::mindmap.node.delete').bind(this);\nconst insertBefore = include('src::mindmap.node.insert.before').bind(this);\nconst show = include('src::mindmap.node.show').bind(this);\nconst data = include('src::mindmap.node.data').bind(this);\nconst getPreviousSibling = include('src::mindmap.node.sibling.previous').bind(this);\nconst getNextSibling = include('src::mindmap.node.sibling.next').bind(this);\nconst doOrder = include('src::mindmap.order').bind(this);\n\n                function main(beforeMoveFn){\n\n        \n/**\n * \n * 结束重组节点\n * \n * @import getDescendantNodes from ....nodes.relation.descendant\n * \n * @import fireDrawEvent from ....fire.draw scoped\n * \n * @import getParentNode from ..parent scoped\n * \n * @import remove from ..delete scoped\n * \n * @import insertBefore from ..insert.before scoped\n * \n * @import show from ..show scoped\n * \n * @import is from ..is.visibility\n * \n * @import data from ..data scoped\n * \n * @import getPreviousSibling from ..sibling.previous scoped\n * \n * @import getNextSibling from ..sibling.next scoped\n * \n * @import doOrder from ....order scoped\n * \n * @param {function} [beforeMoveFn = () => true] 拖曳的拦截函数 \n * \n */\n\nlet me = this,\n{\n   restructuredNode:selectedNode,\n   restructureIndicatedNode,\n   placeholderNode\n} = me;\n\nif(!selectedNode){\n\n   return ;\n}\n\nif(restructureIndicatedNode){\n\n   restructureIndicatedNode.indicated = false ;\n\n   delete me.restructureIndicatedNode ;\n}\n\nlet fireEvent;\n\nif(is(placeholderNode)){\n\n   let oldPreviousSibling = getPreviousSibling(selectedNode),\n       oldParentNode = getParentNode(selectedNode),\n       position,\n       siblingNode;\n\n   if(siblingNode = getPreviousSibling(placeholderNode)){\n\n      position = 'after' ;\n   \n   }else if(siblingNode = getNextSibling(placeholderNode)){\n\n      position = 'before' ;\n   \n   }else{\n\n      position = 'append' ;\n   }\n\n   if(beforeMoveFn(position , data(getParentNode(placeholderNode)) , data(selectedNode) , siblingNode) !== false){\n\n      let {\n         selected\n      } = selectedNode ;\n\n      insertBefore(selectedNode , placeholderNode) ;\n\n      selectedNode.selected = selected ;\n   }\n\n   remove(placeholderNode) ;\n\n   let parentNode = getParentNode(selectedNode);\n\n   if(!(oldParentNode === parentNode && oldPreviousSibling === getPreviousSibling(selectedNode))){\n\n      fireEvent = () => {\n\n         me.fireEvent('nodemove' , data(selectedNode) , data(parentNode) , oldParentNode) ;\n\n         doOrder(parentNode) ;\n\n      } ;\n\n     \n   }\n}\n\ndelete me.restructuring ;\n\ndelete me.restructuredNode ;\n\nselectedNode.restructuring = false ;\n\nlet nodes = getDescendantNodes(selectedNode) ;\n\nfor(let node of nodes){\n\n   node.restructuring = false ;\n}\n\nif(fireEvent){\n\n   fireEvent() ;\n\n}\n\nme.layout() ;\n \n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340534.get(this) ;\n\n        \n    \n                        return main.call(this , beforeMoveFn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.restructure.end"
  },
  "src::mindmap.layout.pattern.logic.right": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.pattern.logic.right(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.x",
      "src::mindmap.layout.node.y",
      "src::mindmap.layout.node.y.offset",
      "src::mindmap.layout.node.is.root",
      "src::mindmap.layout.node.parent",
      "src::mindmap.layout.nodes.child",
      "src::mindmap.layout.nodes.descendant",
      "src::mindmap.layout.node.region.descendant.logic",
      "src::mindmap.layout.node.region.self",
      "src::mindmap.layout.node.region.child.logic",
      "src::mindmap.layout.node.region.logic",
      "src::math.region.height",
      "src::math.region.width",
      "src::math.region.y.anchor",
      "src::math.region.y",
      "src::array.add.sort",
      "src::math.region.intersect",
      "src::math.region.contains.x"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getHeight,getWidth,setAnchorY,getY,add,intersect,contains;\n    \n                    let var_init_locked_1613789851007;\n \n                    \n\n                    const var_current_scope_1613789851007 = new Map();\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1613789851007){\n\n            getHeight = include('src::math.region.height');\ngetWidth = include('src::math.region.width');\nsetAnchorY = include('src::math.region.y.anchor');\ngetY = include('src::math.region.y');\nadd = include('src::array.add.sort');\nintersect = include('src::math.region.intersect');\ncontains = include('src::math.region.contains.x');\n\n            var_init_locked_1613789851007 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613789851007.has(this)){\n\n            var_current_scope_1613789851007.set(this , (() => {\n                const setX = include('src::mindmap.layout.node.x').bind(this);\nconst setY = include('src::mindmap.layout.node.y').bind(this);\nconst setOffsetY = include('src::mindmap.layout.node.y.offset').bind(this);\nconst isRootNode = include('src::mindmap.layout.node.is.root').bind(this);\nconst getParentNode = include('src::mindmap.layout.node.parent').bind(this);\nconst getChildNodes = include('src::mindmap.layout.nodes.child').bind(this);\nconst getDescendantNodes = include('src::mindmap.layout.nodes.descendant').bind(this);\nconst getDescendantRegion = include('src::mindmap.layout.node.region.descendant.logic').bind(this);\nconst getSelfRegion = include('src::mindmap.layout.node.region.self').bind(this);\nconst getChildRegion = include('src::mindmap.layout.node.region.child.logic').bind(this);\nconst getRegion = include('src::mindmap.layout.node.region.logic').bind(this);\n\n                \n/**\n * \n * 向右逻辑图算法实现\n * \n * @import setX from ....node.x scoped\n * \n * @import setY from ....node.y scoped\n * \n * @import setOffsetY from ....node.y.offset scoped\n * \n * @import isRootNode from ....node.is.root scoped\n * \n * @import getParentNode from ....node.parent scoped\n * \n * @import getChildNodes from ....nodes.child scoped\n * \n * @import getDescendantNodes from ....nodes.descendant scoped\n * \n * @import getDescendantRegion from ....node.region.descendant.logic scoped\n * \n * @import getSelfRegion from ....node.region.self scoped\n * \n * @import getChildRegion from ....node.region.child.logic scoped\n * \n * @import getRegion from ....node.region.logic scoped\n * \n * @import getHeight from math.region.height\n * \n * @import getWidth from math.region.width\n * \n * @import setAnchorY from math.region.y.anchor\n * \n * @import getY from math.region.y\n * \n * @import add from array.add.sort\n * \n * @import intersect from math.region.intersect\n * \n * @import contains from math.region.contains.x\n * \n * @param {data.Record} node 布局节点\n * \n */\n\n function main(node){\n\n  let me = this ;\n\n  layout.call(me , node) ;\n\n  let region = getRegion(node),\n  {\n    width,\n    height,\n    padding\n  } = this,\n  {\n    left,\n    right,\n    top,\n    bottom\n  } = padding,\n  mindmapWidth = getWidth(region) + left + right,\n  mindmapHeight = getHeight(region) + top + bottom,\n  offsetX = left,\n  offsetY = 0;\n\n  if(width > mindmapWidth){\n\n    mindmapWidth = width ;\n  \n  }\n\n  if(height > mindmapHeight){\n\n    let region = getSelfRegion(node) ;\n\n    setAnchorY(region , 'center' , height / 2) ;\n\n    setY(node , getY(region)) ;\n\n    mindmapHeight = height ;\n  \n  }else{\n\n    offsetY = top ;\n\n    setOffsetY(node , - getY(region)) ;\n  }\n\n  return {\n    offset:{\n      x:offsetX,\n      y:offsetY\n    },\n    size:{\n      width:mindmapWidth,\n      height:mindmapHeight\n    } \n  } ;\n }\n     \n function layout(node , layoutedNodes = []){\n\n  let me = this,\n  {\n    nodeHorizontalSeparationDistance\n  } = me;\n\n  if(isRootNode(node)){\n\n    setX(node , 0 , false) ;\n\n  }\n\n  let childNodes = getChildNodes(node),\n  {\n    length\n  } = childNodes,\n  {\n    top,\n    right\n  } = getSelfRegion(node),\n  x = right + nodeHorizontalSeparationDistance ;\n\n  for(let i = 0 ; i < length ; i ++){\n\n    let childNode = childNodes[i] ;\n\n    setX(childNode , x) ;\n\n    let previousNode = childNodes[i - 1],\n        bottom;\n\n    if(previousNode){\n\n      bottom = getSelfRegion(previousNode).bottom ;\n\n    }else{\n\n      bottom = top ;\n    }\n\n    setY(childNode , bottom) ;\n\n    layout.call(me , childNode , layoutedNodes) ;\n\n    setY(childNode , bottom) ;\n\n    adjustY.call(me , childNode , layoutedNodes , getDescendantNodes(childNode)) ;\n\n    layoutedNodes.push(childNode) ;\n  \n  }\n\n  let region = getSelfRegion(node),\n      childRegion = getChildRegion(node);\n\n  setAnchorY(region , 'center' , getY(childRegion) + getHeight(childRegion) / 2) ;\n\n  setY(node , getY(region) , false) ;\n\n }\n\n function getAdjustRegions(node) {\n\n    let selfRegion = getSelfRegion(node),\n        descendantRegion = getDescendantRegion(node),\n        regions = [];\n\n    if(getWidth(descendantRegion) !== 0){\n\n      regions.push(descendantRegion) ;\n\n    }\n\n    regions.push(selfRegion) ;\n\n    return regions ;\n }\n\n function adjustY(node , layoutedNodes , ignoreLayoutedNodes){\n\n  let regions = getAdjustRegions(node),\n  {\n    nodeVerticalSeparationDistance\n  } = this,\n  isSetOffsetY = false;\n\n  for(let layoutedNode of layoutedNodes){\n\n    if(ignoreLayoutedNodes.includes(layoutedNode)){\n\n      continue ;\n\n    }\n\n    let layoutedRegions = getAdjustRegions(layoutedNode) ;\n\n    for(let layoutedRegion of layoutedRegions){\n\n      for(let region of regions){\n\n        if(intersect(region , layoutedRegion)){\n\n            setOffsetY(node , layoutedRegion.bottom - region.top + nodeVerticalSeparationDistance) ;\n\n            regions = getAdjustRegions(node) ;\n\n            isSetOffsetY = true ;\n\n            break ;\n\n        }\n      }\n    }\n\n    \n  }\n\n  if(!isSetOffsetY){\n\n    setOffsetY(node , nodeVerticalSeparationDistance) ;\n    \n  }\n}\n\n\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613789851007.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.pattern.logic.right"
  },
  "src::mindmap.layout.nodes.descendant": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.layout.nodes.descendant(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.cache",
      "src::mindmap.layout.nodes.child"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613265759571 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613265759571.has(this)){\n\n            var_current_scope_1613265759571.set(this , (() => {\n                const cache = include('src::mindmap.layout.cache').bind(this);\nconst getChildNodes = include('src::mindmap.layout.nodes.child').bind(this);\n\n                \n/**\n * \n * 获得子孙节点\n * \n * @import cache from mindmap.layout.cache scoped\n * \n * @import getChildNodes from .child scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {array} 子孙节点数组 \n * \n */\n\n function main(node){\n\n    return cache(node , 'getDescendantNodes' , getDescendantNodes) ;\n }\n\n function getDescendantNodes(node){\n\n    let childNodes = getChildNodes(node),\n        result = [];\n\n    for(let childNode of childNodes){\n\n        result.push(childNode) ;\n\n        result.push(...getDescendantNodes(childNode)) ;\n    }\n\n    return result ;\n }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613265759571.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.nodes.descendant"
  },
  "src::mindmap.layout.node.x.offset": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.node.x.offset(<data.Record> node , <number> offsetX , <boolean> recursive)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.nodes.descendant",
      "src::mindmap.layout.node.x.offset"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613393698147 = new Map();\n    \n                    return function(node , offsetX , recursive = true){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613393698147.has(this)){\n\n            var_current_scope_1613393698147.set(this , (() => {\n                const getDescendantNodes = include('src::mindmap.layout.nodes.descendant').bind(this);\nconst setX = include('src::mindmap.layout.node.x.offset').bind(this);\n\n                function main(node , offsetX , recursive){\n\n        \n/**\n * \n * 设置节点的相对横坐标\n * \n * @import getDescendantNodes from ....nodes.descendant scoped\n * \n * @import setX from .offset scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @param {number} offsetX 节点横坐标\n * \n * @param {boolean} [recursive = true] 是否递归设置横坐标\n * \n */\n\nlet {\n   x:oldValue\n} = node;\n\nnode.x = oldValue + offsetX ;\n\nif(recursive){\n\n   let descendantNodes = getDescendantNodes(node) ;\n\n   for(let descendantNode of descendantNodes){\n\n    setX(descendantNode , offsetX , false) ;\n   \n   }\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613393698147.get(this) ;\n\n        \n    \n                        return main.call(this , node , offsetX , recursive) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.x.offset"
  },
  "src::mindmap.layout.node.x": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.node.x(<data.Record> node , <number> x , <boolean> recursive)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.spacing.left",
      "src::mindmap.layout.nodes.child",
      "src::mindmap.layout.node.x.offset"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613393698121 = new Map();\n    \n                    return function(node , x , recursive = true){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613393698121.has(this)){\n\n            var_current_scope_1613393698121.set(this , (() => {\n                const getLeftSpacing = include('src::mindmap.layout.node.spacing.left').bind(this);\nconst getChildNodes = include('src::mindmap.layout.nodes.child').bind(this);\nconst setOffsetX = include('src::mindmap.layout.node.x.offset').bind(this);\n\n                function main(node , x , recursive){\n\n        \n/**\n * \n * 设置节点的横坐标\n * \n * @import getLeftSpacing from .spacing.left scoped\n * \n * @import getChildNodes from ..nodes.child scoped\n * \n * @import setOffsetX from .x.offset scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @param {number} x 节点横坐标\n * \n * @param {boolean} [recursive = true] 是否递归设置横坐标\n * \n */\n\n let value = x + getLeftSpacing(node),\n {\n    x:oldValue\n } = node;\n\nnode.x = value ;\n\nlet offsetValue = value - oldValue ;\n\nif(recursive){\n\n    let childNodes = getChildNodes(node) ;\n\n    for(let childNode of childNodes){\n\n        setOffsetX(childNode , offsetValue) ;\n    }\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613393698121.get(this) ;\n\n        \n    \n                        return main.call(this , node , x , recursive) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.x"
  },
  "src::mindmap.layout.node.y.offset": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.node.y.offset(<data.Record> node , <number> offsetY , <boolean> recursive)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.nodes.descendant",
      "src::mindmap.layout.node.y.offset"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613393698159 = new Map();\n    \n                    return function(node , offsetY , recursive = true){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613393698159.has(this)){\n\n            var_current_scope_1613393698159.set(this , (() => {\n                const getDescendantNodes = include('src::mindmap.layout.nodes.descendant').bind(this);\nconst setY = include('src::mindmap.layout.node.y.offset').bind(this);\n\n                function main(node , offsetY , recursive){\n\n        \n/**\n * \n * 设置节点的相对纵坐标\n * \n * @import getDescendantNodes from ....nodes.descendant scoped\n * \n * @import setY from .offset scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @param {number} offsetY 节点纵坐标\n * \n * @param {boolean} [recursive = true] 是否递归设置横坐标\n * \n */\n\nlet {\n    y:oldValue\n } = node;\n \n node.y = oldValue + offsetY ;\n \n if(recursive){\n \n    let descendantNodes = getDescendantNodes(node) ;\n \n    for(let descendantNode of descendantNodes){\n \n     setY(descendantNode , offsetY , false) ;\n    \n    }\n }\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613393698159.get(this) ;\n\n        \n    \n                        return main.call(this , node , offsetY , recursive) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.y.offset"
  },
  "src::mindmap.layout.node.y": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.node.y(<data.Record> node , <number> y , <boolean> recursive)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.spacing.top",
      "src::mindmap.layout.nodes.child",
      "src::mindmap.layout.node.y.offset"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613393698154 = new Map();\n    \n                    return function(node , y , recursive = true){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613393698154.has(this)){\n\n            var_current_scope_1613393698154.set(this , (() => {\n                const getTopSpacing = include('src::mindmap.layout.node.spacing.top').bind(this);\nconst getChildNodes = include('src::mindmap.layout.nodes.child').bind(this);\nconst setOffsetY = include('src::mindmap.layout.node.y.offset').bind(this);\n\n                function main(node , y , recursive){\n\n        \n/**\n * \n * 设置节点的纵坐标\n * \n * @import getTopSpacing from .spacing.top scoped\n * \n * @import getChildNodes from ..nodes.child scoped\n * \n * @import setOffsetY from .y.offset scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @param {number} y 节点纵坐标\n * \n * @param {boolean} [recursive = true] 是否递归设置纵坐标\n * \n */\n\nlet value = y + getTopSpacing(node),\n{\n   y:oldValue\n} = node;\n\nnode.y = value ;\n\nlet offsetValue = value - oldValue ;\n\nif(recursive){\n\n   let childNodes = getChildNodes(node) ;\n\n   for(let childNode of childNodes){\n\n       setOffsetY(childNode , offsetValue) ;\n   }\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613393698154.get(this) ;\n\n        \n    \n                        return main.call(this , node , y , recursive) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.y"
  },
  "src::mindmap.layout.node.region.child.logic": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.node.region.child.logic(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.nodes.child",
      "src::mindmap.layout.node.region.self"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613788385080 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613788385080.has(this)){\n\n            var_current_scope_1613788385080.set(this , (() => {\n                const getChildNodes = include('src::mindmap.layout.nodes.child').bind(this);\nconst getRegion = include('src::mindmap.layout.node.region.self').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 获得子节点集合的范围值\n * \n * @import getChildNodes from ......nodes.child scoped\n * \n * @import getRegion from ..self scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {object} 范围信息 \n * \n */\n\n let childNodes = getChildNodes(node),\n    {\n        length\n    } = childNodes;\n\nif(length){\n\n    let top,\n        left,\n        bottom,\n        rights = [];\n\n    for(let i = 0 ; i < length ; i ++){\n\n        let region = getRegion(childNodes[i]) ;\n\n        if(i === 0){\n\n            top = region.top,\n            left = region.left;\n        \n        }\n        \n        if(i === length - 1){\n\n            bottom = region.bottom ;\n        }\n\n        rights.push(region.right) ;\n    }\n\n    return {\n        top,\n        left,\n        bottom,\n        right:Math.max(...rights)\n    } ;\n\n}\n\nlet {\n    top,\n    right,\n    bottom\n} = getRegion(node),\n{\n    nodeHorizontalSeparationDistance\n} = this;\n\nright += nodeHorizontalSeparationDistance ;\n\nreturn {\n    top,\n    bottom,\n    left:right,\n    right\n} ;\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613788385080.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.region.child.logic"
  },
  "src::mindmap.layout.node.region.descendant.logic": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.node.region.descendant.logic(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.region.child.logic",
      "src::mindmap.layout.node.region.self",
      "src::mindmap.layout.nodes.child"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613742058080 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613742058080.has(this)){\n\n            var_current_scope_1613742058080.set(this , (() => {\n                const getChildRegion = include('src::mindmap.layout.node.region.child.logic').bind(this);\nconst getSelfRegion = include('src::mindmap.layout.node.region.self').bind(this);\nconst getChildNodes = include('src::mindmap.layout.nodes.child').bind(this);\n\n                \n/**\n * \n * 获得子孙节点集合的范围值\n * \n * @import getChildRegion from ..child.logic scoped\n * \n * @import getSelfRegion from ..self scoped\n * \n * @import getChildNodes from ......nodes.child scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {object} 范围信息 \n * \n */\n\n const {\n    max,\n    min\n } = Math ;\n\n function main(node){\n\n    let regions = getRegions(node),\n        tops = [],\n        bottoms = [],\n        rights = [],\n        lefts = [],\n        region = regions[0];\n\n    regions.pop() ;\n\n    if(regions.length === 0){\n\n        let {\n            top,\n            right,\n            bottom\n        } = region ;\n\n        return {\n            top,\n            bottom,\n            left:right,\n            right\n        } ;\n    }\n\n    for(let region of regions){\n\n        lefts.push(region.left) ;\n\n        tops.push(region.top) ;\n\n        bottoms.push(region.bottom) ;\n\n        rights.push(region.right) ;\n    }\n\n    return {\n        left:min(...lefts),\n        top:min(...tops),\n        bottom:max(...bottoms),\n        right:max(...rights)\n    }\n }\n\n function getRegions(node){\n\n    let region = getChildRegion(node),\n        result = [];\n\n    if(region){\n\n        result.push(region) ;\n\n        let childNodes = getChildNodes(node) ;\n\n        for(let childNode of childNodes){\n\n            result.push(...getRegions(childNode)) ;\n        }\n    }\n\n    return result ;\n }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613742058080.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.region.descendant.logic"
  },
  "src::mindmap.layout.node.region.logic": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.node.region.logic(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.region.self",
      "src::mindmap.layout.node.region.descendant.logic",
      "src::math.region.union"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let union;\n    \n                    let var_init_locked_1613347321155;\n \n                    \n\n                    const var_current_scope_1613347321155 = new Map();\n    \n                    return function(node){\n    \n                        \n        if(!var_init_locked_1613347321155){\n\n            union = include('src::math.region.union');\n\n            var_init_locked_1613347321155 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1613347321155.has(this)){\n\n            var_current_scope_1613347321155.set(this , (() => {\n                const self = include('src::mindmap.layout.node.region.self').bind(this);\nconst descendant = include('src::mindmap.layout.node.region.descendant.logic').bind(this);\n\n                function main(node){\n\n        \n/**\n * \n * 获得脑图节点的范围\n * \n * @import self from .self scoped\n * \n * @import descendant from .descendant.logic scoped\n * \n * @import union from math.region.union\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {object} 范围信息\n * \n */\n\n return union(self(node) , descendant(node)) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613347321155.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.region.logic"
  },
  "src::mindmap.layout.positioner.logic.right": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.positioner.logic.right(<Mindmap> mindmap , <array> nodes)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.positioner.logic.init",
      "src::mindmap.layout.positioner.logic.node",
      "src::mindmap.layout.positioner.logic",
      "src::mindmap.layout.positioner.logic.regions.right.left",
      "src::mindmap.layout.positioner.logic.regions.right.right",
      "src::mindmap.layout.positioner.logic.anchors.right.left",
      "src::mindmap.layout.positioner.logic.anchors.right.right"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let init,getNode,Logic,generateLeftRegions,generateRightRegions,getLeftNodeAnchors,getRightNodeAnchors;\n    \n                    let var_init_locked_1613615189966;\n    \n                    let var_class_1613615189966;\n    \n                    \n\n                    let var_global_main_1613615189966 ;\n    \n                    return function(mindmap , nodes){\n    \n                        \n        if(!var_init_locked_1613615189966){\n\n            init = include('src::mindmap.layout.positioner.logic.init');\ngetNode = include('src::mindmap.layout.positioner.logic.node');\nLogic = include('src::mindmap.layout.positioner.logic')();\ngenerateLeftRegions = include('src::mindmap.layout.positioner.logic.regions.right.left');\ngenerateRightRegions = include('src::mindmap.layout.positioner.logic.regions.right.right');\ngetLeftNodeAnchors = include('src::mindmap.layout.positioner.logic.anchors.right.left');\ngetRightNodeAnchors = include('src::mindmap.layout.positioner.logic.anchors.right.right');\n\n            \n/**\n * \n * 右则逻辑图位置器实现\n * \n * @import init from .init\n * \n * @import getNode from .node\n * \n * @import Logic from ..logic value\n * \n * @import generateLeftRegions from .regions.right.left\n * \n * @import generateRightRegions from .regions.right.right\n * \n * @import getLeftNodeAnchors from .anchors.right.left\n * \n * @import getRightNodeAnchors from .anchors.right.right\n * \n * @param {Mindmap} mindmap 脑图对象\n * \n * @param {array} nodes 布局脑图节点集合\n * \n */\n\n class main extends Logic{\n\n    constructor(mindmap , nodes){\n\n        super(mindmap) ;\n\n        let me = this,\n            regions = init.call(me , nodes);\n\n        me.leftRegions = generateLeftRegions(regions) ;\n\n        me.rightRegions = generateRightRegions(regions) ;\n    }\n\n    applySelectLeftNode(node){\n\n        let me = this,\n        {\n            nodeMap,\n            rightRegions\n        } = me,\n        region = nodeMap.get(node);\n\n        return getNode.call(me , region , rightRegions , rightRegions.indexOf(region) + 1 , ({\n            right\n        } , {\n            left\n        }) => right < left , [\n            getLeftNodeAnchors\n        ]).node ;\n    }\n\n    applySelectRightNode(node){\n\n        let me = this,\n        {\n            nodeMap,\n            leftRegions\n        } = me,\n        region = nodeMap.get(node);\n\n        return getNode.call(me , region , leftRegions , leftRegions.indexOf(region) + 1 , ({\n            left\n        } , {\n            right\n        }) => right < left , [\n            getRightNodeAnchors\n        ]).node ;\n    }\n }\n\n            var_class_1613615189966 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1613615189966 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::mindmap.layout.positioner.logic.right' ;\n                }\n\n            } ;\n\n            main = var_class_1613615189966 ;\n        \nvar_global_main_1613615189966 = main;\n\n            var_init_locked_1613615189966 = true ;\n        }\n        \n    \n                        return new var_global_main_1613615189966(mindmap , nodes) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.right"
  },
  "src::mindmap.layout.positioner.logic.regions.bottom": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.layout.positioner.logic.regions.bottom(<array> regions)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(regions){\n\n        /**\n * \n * 生成以底部逆序排序的范围集合\n * \n * @param {array} regions 范围集合\n * \n * @return {array} 排序后的范围集合\n * \n */\n\nreturn Array.from(regions).sort(({\n    bottom:bottom1\n} , {\n    bottom:bottom2\n}) => bottom2 - bottom1) ;\n\n    }\n    \n                    return function(regions){\n    \n                        \n    \n                        return main.call(this , regions) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.regions.bottom"
  },
  "src::mindmap.layout.positioner.logic.regions.top": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.layout.positioner.logic.regions.top(<array> regions)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(regions){\n\n        /**\n * \n * 生成以顶部顺序排序的范围集合\n * \n * @param {array} regions 范围集合\n * \n * @return {array} 排序后的范围集合\n * \n */\n\nreturn Array.from(regions).sort(({\n    top:top1\n} , {\n    top:top2\n}) => top1 - top2) ;\n\n    }\n    \n                    return function(regions){\n    \n                        \n    \n                        return main.call(this , regions) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.regions.top"
  },
  "src::mindmap.layout.positioner.logic.init": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.layout.positioner.logic.init(<array> nodes)",
    "standard": true,
    "importNames": [
      "src::math.region.from",
      "src::mindmap.layout.positioner.logic.regions.bottom",
      "src::mindmap.layout.positioner.logic.regions.top"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let from,generateBottomRegions,generateTopRegions;\n    \n                    let var_init_locked_1613628470837;\n    \n                    \n\n                    function main(nodes){\n\n        /**\n * \n * 初始化\n * \n * @import from from math.region.from\n * \n * @import generateBottomRegions from .regions.bottom\n * \n * @import generateTopRegions from .regions.top\n * \n * @param {array} nodes 脑图节点集合\n * \n * @return {array} 范围集合\n * \n */\n\nlet me = this,\n    regionMap = me.regionMap = new Map(),\n    nodeMap = me.nodeMap = new Map(),\n    regions = [];\n\nfor(let node of nodes){\n\n    let region = from(node) ;\n\n    regions.push(region) ;\n\n    regionMap.set(region , node) ;\n\n    nodeMap.set(node , region) ;\n}\n\nme.bottomRegions = generateBottomRegions(regions) ;\n\nme.topRegions = generateTopRegions(regions) ;\n\nme.cache = {\n    SelectUpNode:new Map(),\n    SelectDownNode:new Map(),\n    SelectLeftNode:new Map(),\n    SelectRightNode:new Map()\n} ;\n\nreturn regions ;\n\n    }\n    \n                    return function(nodes){\n    \n                        \n        if(!var_init_locked_1613628470837){\n\n            from = include('src::math.region.from');\ngenerateBottomRegions = include('src::mindmap.layout.positioner.logic.regions.bottom');\ngenerateTopRegions = include('src::mindmap.layout.positioner.logic.regions.top');\n\n            var_init_locked_1613628470837 = true ;\n        }\n        \n    \n                        return main.call(this , nodes) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.init"
  },
  "src::mindmap.layout.positioner.logic.node": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.positioner.logic.node(<object> region , <array> originRegions , <number> startIndex , <function> isMatch , <array> getPairAnchors , <function> isIgnoreNode)",
    "standard": true,
    "importNames": [
      "src::math.region.xy.anchor",
      "src::math.point.line.distance"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getAnchorXY,getDistance;\n    \n                    let var_init_locked_1613555531839;\n    \n                    \n\n                    function main(region , originRegions , startIndex , isMatch , getPairAnchors , isIgnoreNode){\n\n        /**\n * \n * 获得节点\n * \n * @import getAnchorXY from math.region.xy.anchor\n * \n * @import getDistance from math.point.line.distance\n * \n * @param {object} region 基准范围\n * \n * @param {array} originRegions 比较范围集合\n * \n * @param {number} startIndex 起始比较位置\n * \n * @param {function} isMatch 判断是否可进行比较 \n * \n * @param {array} getPairAnchors 获得锚定插件\n * \n * @param {function} [isIgnoreNode = () => false] 是否为忽略节点\n * \n * @return {object} 匹配内容\n * \n */\n\nlet me = this,\n{\n    regionMap\n} = this,\n{\n    length\n} = originRegions,\nresult = [];\n\nfor(let i = startIndex ; i < length ; i ++){\n\n    let originRegion = originRegions[i] ;\n\n    if(isMatch(originRegion , region)){\n\n        let node = regionMap.get(originRegion);\n\n        if(isIgnoreNode(node)){\n\n            continue ;\n        }\n\n        let {\n            length\n        } = getPairAnchors ;\n\n        for(let i = 0 ; i < length ; i ++){\n\n            let item = result[i],\n            {\n                start,\n                end,\n                direction\n            } = getPairAnchors[i](originRegion , region),\n            distance = getDistance(getAnchorXY(originRegion , start) , getAnchorXY(region , end)) ;\n\n            if(!item || item.distance > distance){\n\n                result[i] = {\n                    distance,\n                    node,\n                    direction\n                } ;\n            }\n        }\n    }\n}\n\nif(result.length){\n\n    return result.sort(({\n        distance:distance1\n    } , {\n        distance:distance2\n    }) => distance1 - distance2)[0] ;\n}\n\nreturn {} ;\n\n    }\n    \n                    return function(region , originRegions , startIndex , isMatch , getPairAnchors , isIgnoreNode = () => false){\n    \n                        \n        if(!var_init_locked_1613555531839){\n\n            getAnchorXY = include('src::math.region.xy.anchor');\ngetDistance = include('src::math.point.line.distance');\n\n            var_init_locked_1613555531839 = true ;\n        }\n        \n    \n                        return main.call(this , region , originRegions , startIndex , isMatch , getPairAnchors , isIgnoreNode) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.node"
  },
  "src::mindmap.layout.positioner.logic.anchors.up": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.positioner.logic.anchors.up(<object> originRegion , <object> region)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(originRegion , region){\n\n        /**\n * \n * 获得向上的一对锚定值\n * \n * @param {object} originRegion 比较范围\n * \n * @param {object} region 基准范围\n * \n * @return {object} 锚定值\n * \n */\n\n const {\n    abs\n } = Math,{\n    left:regionLeft,\n    right:regionRight\n } = originRegion,\n {\n    left,\n    right\n } = region ;\n\nlet start,\n    end ;\n\nif(regionRight < left){\n\n    start = 'br' ;\n\n    end = 'tl' ;\n\n}else if(regionLeft > right){\n\n    start = 'bl' ;\n\n    end = 'tr' ;\n\n}else{\n\n    let result = [{\n        distance:abs(regionLeft - left),\n        start:'bl',\n        end:'tl'\n    },{\n        distance:abs(regionLeft - right),\n        start:'bl',\n        end:'tr'\n    },{\n        distance:abs(regionRight - left),\n        start:'br',\n        end:'tl'\n    },{\n        distance:abs(regionRight - right),\n        start:'br',\n        end:'tr'\n    }].sort(({\n        distance:distance1\n    } , {\n        distance:distance2\n    }) => distance1 - distance2)[0] ;\n\n    start = result.start ;\n\n    end = result.end ;\n}\n\nreturn {\n    start,\n    end,\n    direction:'up'\n} ;\n\n    }\n    \n                    return function(originRegion , region){\n    \n                        \n    \n                        return main.call(this , originRegion , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.anchors.up"
  },
  "src::mindmap.layout.positioner.logic.anchors.down": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.positioner.logic.anchors.down(<object> originRegion , <object> region)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(originRegion , region){\n\n        /**\n * \n * 获得向下的一对锚定值\n * \n * @param {object} originRegion 比较范围\n * \n * @param {object} region 基准范围\n * \n * @return {object} 锚定值\n * \n */\n\n const {\n    abs\n } = Math,{\n    left:regionLeft,\n    right:regionRight\n } = originRegion,\n {\n    left,\n    right\n } = region ;\n\nlet start,\n    end ;\n\nif(regionRight < left){\n\n    start = 'tr' ;\n\n    end = 'bl' ;\n\n}else if(regionLeft > right){\n\n    start = 'tl' ;\n\n    end = 'br' ;\n\n}else{\n\n    let result = [{\n        distance:abs(regionLeft - left),\n        start:'tl',\n        end:'bl'\n    },{\n        distance:abs(regionLeft - right),\n        start:'tl',\n        end:'br'\n    },{\n        distance:abs(regionRight - left),\n        start:'tr',\n        end:'bl'\n    },{\n        distance:abs(regionRight - right),\n        start:'tr',\n        end:'br'\n    }].sort(({\n        distance:distance1\n    } , {\n        distance:distance2\n    }) => distance1 - distance2)[0] ;\n\n    start = result.start ;\n\n    end = result.end ;\n}\n\nreturn {\n    start,\n    end,\n    direction:'down'\n} ;\n\n    }\n    \n                    return function(originRegion , region){\n    \n                        \n    \n                        return main.call(this , originRegion , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.anchors.down"
  },
  "src::mindmap.layout.positioner.logic.node.cache": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.layout.positioner.logic.node.cache(<data.Record> node , <string> name)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(node , name){\n\n        /**\n * \n * 缓存获得结果\n * \n * @param {data.Record} node 脑图节点\n * \n * @param {string} name 缓存名称\n * \n * @return {data.Record} 返回缓存后的节点\n * \n */\nlet me = this,\n    {\n        cache\n    } = me,\n    map = cache[name];\n\nif(!map.has(node)){\n\n    map.set(node , me[`apply${name}`](node)) ;\n}\n\nreturn map.get(node) ;\n\n    }\n    \n                    return function(node , name){\n    \n                        \n    \n                        return main.call(this , node , name) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.node.cache"
  },
  "src::mindmap.node.is.descendant": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.node.is.descendant(<data.Record> ancestorNode , <data.Record> descendantNode)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.parent"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613308340530 = new Map();\n    \n                    return function(ancestorNode , descendantNode){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613308340530.has(this)){\n\n            var_current_scope_1613308340530.set(this , (() => {\n                const getParentNode = include('src::mindmap.node.parent').bind(this);\n\n                function main(ancestorNode , descendantNode){\n\n        \n/**\n * \n * 判断一个脑图节点是否是另外一个脑图的子孙节点\n * \n * @import getParentNode from ..parent scoped\n * \n * @param {data.Record} ancestorNode 祖先节点\n * \n * @param {data.Record} descendantNode 子孙节点\n * \n * @return {boolean} 如果节点为叶子节点则返回 true , 否则 false\n * \n */\n\n let baseNode = descendantNode,\n     parentNode;\n\nwhile(parentNode = getParentNode(baseNode)){\n\n    if(parentNode === ancestorNode){\n\n        return true ;\n    }\n\n    baseNode = parentNode ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613308340530.get(this) ;\n\n        \n    \n                        return main.call(this , ancestorNode , descendantNode) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.node.is.descendant"
  },
  "src::mindmap.layout.positioner.logic": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.positioner.logic()",
    "standard": true,
    "importNames": [
      "src::math.region.xy.anchor",
      "src::mindmap.layout.positioner.logic.anchors.up",
      "src::mindmap.layout.positioner.logic.anchors.down",
      "src::mindmap.layout.positioner.logic.node.cache",
      "src::mindmap.layout.positioner.logic.node",
      "src::mindmap.node.is.descendant"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getAnchorXY,getUpNodeAnchors,getDownNodeAnchors,getCacheNode,getNode,isDescendantNode;\n    \n                    let var_init_locked_1613628470859;\n    \n                    let var_class_1613628470859;\n    \n                    \n\n                    let var_global_main_1613628470859 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1613628470859){\n\n            getAnchorXY = include('src::math.region.xy.anchor');\ngetUpNodeAnchors = include('src::mindmap.layout.positioner.logic.anchors.up');\ngetDownNodeAnchors = include('src::mindmap.layout.positioner.logic.anchors.down');\ngetCacheNode = include('src::mindmap.layout.positioner.logic.node.cache');\ngetNode = include('src::mindmap.layout.positioner.logic.node');\nisDescendantNode = include('src::mindmap.node.is.descendant');\n\n            \n/**\n * \n * 逻辑图位置器实现\n * \n * @import getAnchorXY from math.region.xy.anchor\n * \n * @import getUpNodeAnchors from .logic.anchors.up\n * \n * @import getDownNodeAnchors from .logic.anchors.down\n * \n * @import getCacheNode from .logic.node.cache\n * \n * @import getNode from .logic.node\n * \n * @import isDescendantNode from mindmap.node.is.descendant\n * \n * @class\n * \n */\n\n function applyUpNode(node , isIgnoreNode){\n\n    let me = this,\n    {\n        nodeMap,\n        bottomRegions\n    } = me,\n    region = nodeMap.get(node);\n\n    return getNode.call(me , region , bottomRegions , bottomRegions.indexOf(region) + 1 , ({\n        bottom\n    } , {\n        top\n    }) => bottom < top , [\n        getUpNodeAnchors\n    ] , isIgnoreNode).node ;\n }\n\n function applyDownNode(node , isIgnoreNode){\n\n    let me = this,\n    {\n        nodeMap,\n        topRegions\n    } = me,\n    region = nodeMap.get(node);\n\n    return getNode.call(me , region , topRegions , topRegions.indexOf(region) + 1 , ({\n        top\n    } , {\n        bottom\n    }) => bottom < top , [\n        getDownNodeAnchors\n    ] , isIgnoreNode).node ;\n }\n\n class main {\n\n    constructor(mindmap){\n\n        this.mindmap = mindmap;\n    }\n\n    getSelectUpNode(node){\n\n        return getCacheNode.call(this , node , 'SelectUpNode') ;\n    }\n\n    applySelectUpNode(node){\n        \n        return applyUpNode.call(this , node) ;\n    }\n\n    getMoveUpNode(node){\n\n        let me = this,\n        {\n            mindmap\n        } = me ;\n\n        return applyUpNode.call(me , node , originNode => isDescendantNode.call(mindmap , node , originNode)) ;\n    }\n\n    getSelectDownNode(node){\n\n        return getCacheNode.call(this , node , 'SelectDownNode') ;\n    }\n\n    applySelectDownNode(node){\n\n        return applyDownNode.call(this , node) ;\n    }\n\n    getMoveDownNode(node){\n\n        let me = this,\n        {\n            mindmap\n        } = me ;\n\n        return applyDownNode.call(me , node , originNode => isDescendantNode.call(mindmap , node , originNode)) ;\n    }\n\n    getSelectLeftNode(node){\n\n        return getCacheNode.call(this , node , 'SelectLeftNode') ;\n    }\n\n    getRightNode(node){\n\n        return getCacheNode.call(this , node , 'SelectRightNode') ;\n    }\n\n }\n\n            var_class_1613628470859 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1613628470859 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::mindmap.layout.positioner.logic' ;\n                }\n\n            } ;\n\n            main = var_class_1613628470859 ;\n        \nvar_global_main_1613628470859 = main;\n\n            var_init_locked_1613628470859 = true ;\n        }\n        \n    \n                        return var_global_main_1613628470859 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic"
  },
  "src::mindmap.layout.positioner.logic.regions.right.left": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.layout.positioner.logic.regions.right.left(<array> regions)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(regions){\n\n        /**\n * \n * 生成以左边顺序排序的范围集合\n * \n * @param {array} regions 范围集合\n * \n * @return {array} 排序后的范围集合\n * \n */\n\nreturn Array.from(regions).sort(({\n    left:left1\n} , {\n    left:left2\n}) => left1 - left2) ;\n\n    }\n    \n                    return function(regions){\n    \n                        \n    \n                        return main.call(this , regions) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.regions.right.left"
  },
  "src::mindmap.layout.positioner.logic.regions.right.right": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::mindmap.layout.positioner.logic.regions.right.right(<array> regions)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(regions){\n\n        /**\n * \n * 生成以右部逆序排序的范围集合\n * \n * @param {array} regions 范围集合\n * \n * @return {array} 排序后的范围集合\n * \n */\n\nreturn Array.from(regions).sort(({\n    right:right1\n} , {\n    right:right2\n}) => right2 - right1) ;\n\n    }\n    \n                    return function(regions){\n    \n                        \n    \n                        return main.call(this , regions) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.regions.right.right"
  },
  "src::mindmap.layout.positioner.logic.anchors.right.left": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.positioner.logic.anchors.right.left(<object> originRegion , <object> region)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(originRegion , region){\n\n        /**\n * \n * 获得向左的一对锚定值\n * \n * @param {object} originRegion 比较范围\n * \n * @param {object} region 基准范围\n * \n * @return {object} 锚定值\n * \n */\n\nconst {\n    abs\n } = Math,{\n    top:regionTop,\n    bottom:regionBottom\n } = originRegion,\n {\n    top,\n    bottom\n } = region ;\n\nlet start,\n    end ;\n\nif(regionBottom < top){\n\n    start = 'br' ;\n\n    end = 'tl' ;\n\n}else if(regionTop > bottom){\n\n    start = 'tr' ;\n\n    end = 'bl' ;\n\n}else{\n\n    let result = [{\n        distance:abs(regionTop - top),\n        start:'tr',\n        end:'tl'\n    },{\n        distance:abs(regionTop - bottom),\n        start:'tr',\n        end:'bl'\n    },{\n        distance:abs(regionBottom - top),\n        start:'br',\n        end:'tl'\n    },{\n        distance:abs(regionBottom - bottom),\n        start:'br',\n        end:'bl'\n    }].sort(({\n        distance:distance1\n    } , {\n        distance:distance2\n    }) => distance1 - distance2)[0] ;\n\n    start = result.start ;\n\n    end = result.end ;\n}\n\nreturn {\n    start,\n    end,\n    direction:'left'\n} ;\n\n    }\n    \n                    return function(originRegion , region){\n    \n                        \n    \n                        return main.call(this , originRegion , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.anchors.right.left"
  },
  "src::mindmap.layout.positioner.logic.anchors.right.right": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::mindmap.layout.positioner.logic.anchors.right.right(<object> originRegion , <object> region)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(originRegion , region){\n\n        /**\n * \n * 获得向右的一对锚定值\n * \n * @param {object} originRegion 比较范围\n * \n * @param {object} region 基准范围\n * \n * @return {object} 锚定值\n * \n */\n\nconst {\n    abs\n } = Math,{\n    top:regionTop,\n    bottom:regionBottom\n } = originRegion,\n {\n    top,\n    bottom\n } = region ;\n\nlet start,\n    end ;\n\nif(regionBottom < top){\n\n    start = 'bl' ;\n\n    end = 'tr' ;\n\n}else if(regionTop > bottom){\n\n    start = 'tl' ;\n\n    end = 'br' ;\n\n}else{\n\n    let result = [{\n        distance:abs(regionTop - top),\n        start:'tl',\n        end:'tr'\n    },{\n        distance:abs(regionTop - bottom),\n        start:'tl',\n        end:'br'\n    },{\n        distance:abs(regionBottom - top),\n        start:'bl',\n        end:'tr'\n    },{\n        distance:abs(regionBottom - bottom),\n        start:'bl',\n        end:'br'\n    }].sort(({\n        distance:distance1\n    } , {\n        distance:distance2\n    }) => distance1 - distance2)[0] ;\n\n    start = result.start ;\n\n    end = result.end ;\n}\n\nreturn {\n    start,\n    end,\n    direction:'right'\n} ;\n\n    }\n    \n                    return function(originRegion , region){\n    \n                        \n    \n                        return main.call(this , originRegion , region) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.positioner.logic.anchors.right.right"
  },
  "src::mindmap.layout.node.is.move.up": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.layout.node.is.move.up(<function> onBeforeNodeInsertAfter)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.sibling.previous",
      "src::mindmap.node.data",
      "src::mindmap.node.parent"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613617522724 = new Map();\n    \n                    return function(onBeforeNodeInsertAfter = () => true){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613617522724.has(this)){\n\n            var_current_scope_1613617522724.set(this , (() => {\n                const previous = include('src::mindmap.layout.node.sibling.previous').bind(this);\nconst data = include('src::mindmap.node.data').bind(this);\nconst getParentNode = include('src::mindmap.node.parent').bind(this);\n\n                function main(onBeforeNodeInsertAfter){\n\n        /**\n * \n * 选中节点向上移动\n * \n * @import previous from ....sibling.previous scoped\n * \n * @import data from mindmap.node.data scoped\n * \n * @import getParentNode from mindmap.node.parent scoped\n * \n * @param {function} [onBeforeNodeInsertAfter = () => true] 拖曳的拦截函数 \n * \n * @return {boolean} 判断是否可以向下移动\n * \n */\nlet me = this,\n{\n   selectedNode,\n   layoutPositioner\n} = me,\nnode = previous(selectedNode) || layoutPositioner.getMoveUpNode(selectedNode) ;\n\nreturn !!(node && onBeforeNodeInsertAfter(data(getParentNode(node)) , data(selectedNode) , data(node))) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613617522724.get(this) ;\n\n        \n    \n                        return main.call(this , onBeforeNodeInsertAfter) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.is.move.up"
  },
  "src::mindmap.layout.node.sibling.previous": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.layout.node.sibling.previous(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.parent",
      "src::mindmap.layout.cache"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613785480198 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613785480198.has(this)){\n\n            var_current_scope_1613785480198.set(this , (() => {\n                const getParentNode = include('src::mindmap.node.parent').bind(this);\nconst cache = include('src::mindmap.layout.cache').bind(this);\n\n                \n/**\n * \n * 获得上兄弟节点\n * \n * @import getParentNode from mindmap.node.parent scoped\n * \n * @import cache from mindmap.layout.cache scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {data.Record} 兄弟节点引用 \n * \n */\n\n function main(node){\n\n    return cache(node , 'getPreviousSiblingNode' , getPreviousSiblingNode) ;\n }\n\n function getPreviousSiblingNode(node){\n\n    let parentNode = getParentNode(node),\n    {\n        layoutNodes\n    } = this;\n\n    if(parentNode){\n\n        let {\n            children\n        } = parentNode,\n        index = children.indexOf(node) - 1;\n\n        for(let i = index ; i >= 0 ; i --){\n\n            let previousNode = children[i] ;\n\n            if(layoutNodes.includes(previousNode)){\n\n                return previousNode ;\n            }\n        }\n    }\n }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613785480198.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.sibling.previous"
  },
  "src::mindmap.layout.node.is.move.down": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.layout.node.is.move.down(<function> onBeforeNodeInsertBefore)",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.sibling.next",
      "src::mindmap.node.parent",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613617522750 = new Map();\n    \n                    return function(onBeforeNodeInsertBefore = () => true){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613617522750.has(this)){\n\n            var_current_scope_1613617522750.set(this , (() => {\n                const next = include('src::mindmap.layout.node.sibling.next').bind(this);\nconst getParentNode = include('src::mindmap.node.parent').bind(this);\nconst data = include('src::mindmap.node.data').bind(this);\n\n                function main(onBeforeNodeInsertBefore){\n\n        /**\n * \n * 选中节点向下移动\n * \n * @import next from ....sibling.next scoped\n * \n * @import getParentNode from mindmap.node.parent scoped\n * \n * @import data from mindmap.node.data scoped\n * \n * @param {function} [onBeforeNodeInsertBefore = () => true] 拖曳的拦截函数 \n * \n * @return {boolean} 判断是否可以向下移动\n * \n */\n\nlet me = this,\n{\n  selectedNode,\n  layoutPositioner\n} = me,\nnode = next(selectedNode) || layoutPositioner.getMoveDownNode(selectedNode) ;\n\nreturn !! (node && onBeforeNodeInsertBefore(data(getParentNode(node)) , data(selectedNode) , data(node))) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613617522750.get(this) ;\n\n        \n    \n                        return main.call(this , onBeforeNodeInsertBefore) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.is.move.down"
  },
  "src::mindmap.layout.node.sibling.next": {
    "meta": "code.meta.script.function",
    "signature": "<data.Record> src::mindmap.layout.node.sibling.next(<data.Record> node)",
    "standard": true,
    "importNames": [
      "src::mindmap.node.parent",
      "src::mindmap.layout.cache"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613785480204 = new Map();\n    \n                    return function(node){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613785480204.has(this)){\n\n            var_current_scope_1613785480204.set(this , (() => {\n                const getParentNode = include('src::mindmap.node.parent').bind(this);\nconst cache = include('src::mindmap.layout.cache').bind(this);\n\n                \n/**\n * \n * 获得上兄弟节点\n * \n * @import getParentNode from mindmap.node.parent scoped\n * \n * @import cache from mindmap.layout.cache scoped\n * \n * @param {data.Record} node 脑图节点\n * \n * @return {data.Record} 兄弟节点引用 \n * \n */\n\n function main(node){\n\n    return cache(node , 'getNextSiblingNode' , getPreviousSiblingNode) ;\n }\n\n function getPreviousSiblingNode(node){\n\n    let parentNode = getParentNode(node),\n    {\n        layoutNodes\n    } = this;\n\n    if(parentNode){\n\n        let {\n            children\n        } = parentNode,\n        {\n            length\n        } = children,\n        index = children.indexOf(node) + 1;\n\n        for(let i = index ; i < length ; i ++){\n\n            let nextNode = children[i] ;\n\n            if(layoutNodes.includes(nextNode)){\n\n                return nextNode ;\n            }\n        }\n    }\n }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613785480204.get(this) ;\n\n        \n    \n                        return main.call(this , node) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.sibling.next"
  },
  "src::mindmap.layout.node.move.up": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.layout.node.move.up()",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.sibling.previous",
      "src::mindmap.node.insert.before",
      "src::mindmap.node.insert.after",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613628470870 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613628470870.has(this)){\n\n            var_current_scope_1613628470870.set(this , (() => {\n                const previous = include('src::mindmap.layout.node.sibling.previous').bind(this);\nconst insertBefore = include('src::mindmap.node.insert.before').bind(this);\nconst insertAfter = include('src::mindmap.node.insert.after').bind(this);\nconst data = include('src::mindmap.node.data').bind(this);\n\n                function main(){\n\n        /**\n * \n * 选中节点向上移动\n * \n * @import previous from ..sibling.previous scoped\n * \n * @import insertBefore from mindmap.node.insert.before scoped\n * \n * @import insertAfter from mindmap.node.insert.after scoped\n * \n * @import data from mindmap.node.data scoped\n * \n * @return {boolean} 移动状态\n * \n */\n\nlet me = this,\n{\n    selectedNode,\n    layoutPositioner\n} = me,\nnode = previous(selectedNode);\n\nif(node){\n\n    return insertBefore(selectedNode , node) ;\n}\n\nnode = layoutPositioner.getMoveUpNode(selectedNode) ;\n\nif(node){\n\n    return insertAfter(selectedNode , node) ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613628470870.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.move.up"
  },
  "src::mindmap.layout.node.move.down": {
    "meta": "code.meta.script.function",
    "signature": "<boolean> src::mindmap.layout.node.move.down()",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.sibling.next",
      "src::mindmap.node.insert.before",
      "src::mindmap.node.insert.after",
      "src::mindmap.node.data"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613628470876 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613628470876.has(this)){\n\n            var_current_scope_1613628470876.set(this , (() => {\n                const next = include('src::mindmap.layout.node.sibling.next').bind(this);\nconst insertBefore = include('src::mindmap.node.insert.before').bind(this);\nconst insertAfter = include('src::mindmap.node.insert.after').bind(this);\nconst data = include('src::mindmap.node.data').bind(this);\n\n                function main(){\n\n        /**\n * \n * 选中节点向下移动\n * \n * @import next from ..sibling.next scoped\n * \n * @import insertBefore from mindmap.node.insert.before scoped\n * \n * @import insertAfter from mindmap.node.insert.after scoped\n * \n * @import data from mindmap.node.data scoped\n * \n * @return {boolean} 移动状态\n * \n */\n\nlet me = this,\n{\n    selectedNode,\n    layoutPositioner\n} = me,\nnode = next(selectedNode);\n\nif(node){\n\n    return insertAfter(selectedNode , node) ;\n}\n\nnode = layoutPositioner.getMoveDownNode(selectedNode) ;\n\nif(node){\n\n    return insertBefore(selectedNode , node) ;\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613628470876.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.move.down"
  },
  "src::mindmap.layout.node.select.logic.down": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.node.select.logic.down()",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.sibling.next",
      "src::mindmap.node.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613556861768 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613556861768.has(this)){\n\n            var_current_scope_1613556861768.set(this , (() => {\n                const next = include('src::mindmap.layout.node.sibling.next').bind(this);\nconst select = include('src::mindmap.node.select').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向下移动选择节点\n * \n * @import next from mindmap.layout.node.sibling.next scoped\n * \n * @import select from mindmap.node.select scoped\n * \n */\n\nlet {\n   selectedNode,\n   layoutPositioner\n } = this ;\n\nlet node = next(selectedNode) || layoutPositioner.getSelectDownNode(selectedNode);\n\nif(node){\n\n   return select(node) ;\n\n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613556861768.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.select.logic.down"
  },
  "src::mindmap.layout.node.select.logic.up": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.node.select.logic.up()",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.sibling.previous",
      "src::mindmap.node.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613556861774 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613556861774.has(this)){\n\n            var_current_scope_1613556861774.set(this , (() => {\n                const previous = include('src::mindmap.layout.node.sibling.previous').bind(this);\nconst select = include('src::mindmap.node.select').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向上移动选择节点\n * \n * @import previous from mindmap.layout.node.sibling.previous scoped\n * \n * @import select from mindmap.node.select scoped\n * \n */\n\n let {\n   selectedNode,\n   layoutPositioner\n } = this ;\n\nlet node = previous(selectedNode) || layoutPositioner.getSelectUpNode(selectedNode);\n\nif(node){\n\n   return select(node) ;\n \n}\n\nreturn false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613556861774.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.select.logic.up"
  },
  "src::mindmap.layout.node.select.logic.right.left": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.node.select.logic.right.left()",
    "standard": true,
    "importNames": [
      "src::mindmap.layout.node.parent",
      "src::mindmap.node.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613462840486 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613462840486.has(this)){\n\n            var_current_scope_1613462840486.set(this , (() => {\n                const getParentNode = include('src::mindmap.layout.node.parent').bind(this);\nconst select = include('src::mindmap.node.select').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向左移动选择节点\n * \n * @import getParentNode from mindmap.layout.node.parent scoped\n * \n * @import select from mindmap.node.select scoped\n * \n */\n\n let {\n    selectedNode\n } = this,\n node = getParentNode(selectedNode) ;\n\n if(node){\n\n   return select(node) ;\n }\n\n return false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613462840486.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.select.logic.right.left"
  },
  "src::mindmap.layout.node.select.logic.right.right": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::mindmap.layout.node.select.logic.right.right()",
    "standard": true,
    "importNames": [
      "src::mindmap.node.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n \n                    \n\n                    const var_current_scope_1613462840491 = new Map();\n    \n                    return function(){\n    \n                        \n    \n                        \n        \n        if(!var_current_scope_1613462840491.has(this)){\n\n            var_current_scope_1613462840491.set(this , (() => {\n                const select = include('src::mindmap.node.select').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向右移动选择节点\n * \n * @import select from mindmap.node.select scoped\n * \n */\n\nlet me = this,\n{\n    children\n} = me.selectedNode;\n\nif(children.length){\n\n    return select(children[0]) ;\n}\n\n return false ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1613462840491.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "mindmap.layout.node.select.logic.right.right"
  },
  "src::function.call": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::function.call(<mixed> target , <array> ...args)",
    "standard": true,
    "importNames": [
      "src::is.function",
      "src::is.object.simple",
      "src::is.array",
      "src::function.get",
      "src::function.call"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction,isObject,isArray,get,call;\n    \n                    let var_init_locked_1608956299363;\n    \n                    \n\n                    function main(target , ...args){\n\n        \n/**\n * \n * 执行函数\n * \n * @import is.function\n * \n * @import isObject from is.object.simple\n * \n * @import is.array\n * \n * @import get from .get\n * \n * @import call from .call\n * \n * @param {mixed} target 函数或者函数描述\n * \n * @param {array} [...args] 函数参数\n * \n * @return {mixed} 函数的返回值\n * \n */\n\n if(isFunction(target)){\n\n    return target(...args) ;\n\n }else if(isObject(target)){\n\n    let {\n        fn,\n        scope\n    } = target ;\n\n    get(fn , scope).apply(scope , args) ;\n\n }else if(isArray(target)){\n\n    let targets = target ;\n\n    for(let target of targets){\n\n        call(target , ...args) ;\n    }\n }\n\n    }\n    \n                    return function(target , ...args){\n    \n                        \n        if(!var_init_locked_1608956299363){\n\n            isFunction = include('src::is.function');\nisObject = include('src::is.object.simple');\nisArray = include('src::is.array');\nget = include('src::function.get');\ncall = include('src::function.call');\n\n            var_init_locked_1608956299363 = true ;\n        }\n        \n    \n                        return main.call(this , target , ...args) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "function.call"
  },
  "src::function.create.after": {
    "meta": "code.meta.script.function",
    "signature": "<function> src::function.create.after(<function> target , <fucntion> afterFn)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(target , afterFn){\n\n        \n/**\n * \n * 基于目标函数生成一个带有后继函数的新函数\n * \n * @param {function} target 目标函数\n * \n * @param {fucntion} afterFn 后继函数\n * \n * @return {function} 生成后的函数\n * \n */\n\nreturn function(){\n\n    let me = this,\n        value = target.apply(me , arguments) ;\n\n    afterFn.apply(me , arguments) ;\n\n    return value ;\n} ;\n\n    }\n    \n                    return function(target , afterFn){\n    \n                        \n    \n                        return main.call(this , target , afterFn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "function.create.after"
  },
  "src::function.create.before": {
    "meta": "code.meta.script.function",
    "signature": "<function> src::function.create.before(<function> target , <fucntion> beforeFn)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(target , beforeFn){\n\n        \n/**\n * \n * 基于目标函数生成一个带有后继函数的新函数\n * \n * @param {function} target 目标函数\n * \n * @param {fucntion} beforeFn 后继函数\n * \n * @return {function} 生成后的函数\n * \n */\n\nreturn function(){\n\n    let me = this ;\n\n    if(beforeFn.apply(me , arguments) !== false){\n\n       return target.apply(me , arguments) ;\n    }\n} ;\n\n    }\n    \n                    return function(target , beforeFn){\n    \n                        \n    \n                        return main.call(this , target , beforeFn) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "function.create.before"
  },
  "src::calendar.month.view": {
    "meta": "code.meta.class",
    "signature": "<void> src::calendar.month.view(<mixed> target , <mixed> config)",
    "standard": true,
    "importNames": [
      "src::class.empty",
      "src::calendar.month.view.constructor",
      "src::calendar.month.view.select",
      "src::calendar.month.view.selectLeft",
      "src::calendar.month.view.selectRight",
      "src::calendar.month.view.selectUp",
      "src::calendar.month.view.selectDown",
      "src::calendar.month.view.selectMonth",
      "src::calendar.month.view.selectNextMonth",
      "src::calendar.month.view.selectPrevMonth",
      "src::calendar.month.view.deselect",
      "src::is.object.simple"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let extend,constructor,method_select,method_selectLeft,method_selectRight,method_selectUp,method_selectDown,method_selectMonth,method_selectNextMonth,method_selectPrevMonth,method_deselect,isObject;\n    \n                    let var_init_locked_1608956299382;\n    \n                    let var_class_1608956299382;\n    \n                    \n\n                    let var_global_main_1608956299382 ;\n    \n                    return function(target , config){\n    \n                        \n        if(!var_init_locked_1608956299382){\n\n            extend = include('src::class.empty')();\nconstructor = include('src::calendar.month.view.constructor');\nmethod_select = include('src::calendar.month.view.select');\nmethod_selectLeft = include('src::calendar.month.view.selectLeft');\nmethod_selectRight = include('src::calendar.month.view.selectRight');\nmethod_selectUp = include('src::calendar.month.view.selectUp');\nmethod_selectDown = include('src::calendar.month.view.selectDown');\nmethod_selectMonth = include('src::calendar.month.view.selectMonth');\nmethod_selectNextMonth = include('src::calendar.month.view.selectNextMonth');\nmethod_selectPrevMonth = include('src::calendar.month.view.selectPrevMonth');\nmethod_deselect = include('src::calendar.month.view.deselect');\nisObject = include('src::is.object.simple');\n\n            class main {\n\n            \n\n            \n\n            constructor(...args){\n\n            \n\n            constructor.apply(this , args) ;\n\n        }\n\n            select(...args){\n\n            return method_select.apply(this , args) ;\n\n        }\nselectLeft(...args){\n\n            return method_selectLeft.apply(this , args) ;\n\n        }\nselectRight(...args){\n\n            return method_selectRight.apply(this , args) ;\n\n        }\nselectUp(...args){\n\n            return method_selectUp.apply(this , args) ;\n\n        }\nselectDown(...args){\n\n            return method_selectDown.apply(this , args) ;\n\n        }\nselectMonth(...args){\n\n            return method_selectMonth.apply(this , args) ;\n\n        }\nselectNextMonth(...args){\n\n            return method_selectNextMonth.apply(this , args) ;\n\n        }\nselectPrevMonth(...args){\n\n            return method_selectPrevMonth.apply(this , args) ;\n\n        }\ndeselect(...args){\n\n            return method_deselect.apply(this , args) ;\n\n        }\n\n            \n\n        }\n\n            var_class_1608956299382 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956299382 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::calendar.month.view' ;\n                }\n\n            } ;\n\n            main = var_class_1608956299382 ;\n        \nvar_global_main_1608956299382 = main;\n\n            var_init_locked_1608956299382 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956299382(target , config) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view"
  },
  "src::month.date.last": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::month.date.last(<number> year , <number> month)",
    "standard": true,
    "importNames": [
      "src::date.get",
      "src::date.prev",
      "src::month.date.last"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,prev,getLastDate;\n    \n                    let var_init_locked_1608956299395;\n    \n                    \n\n                    function main(year , month){\n\n        \n/**\n * \n * 指定月份的最后日期\n * \n * @import get from date.get\n * \n * @import prev from date.prev\n * \n * @import getLastDate from .last\n * \n * @param {number} year 年份\n * \n * @param {number} month 月份\n * \n * @return {Date} 日期对象 \n * \n */\n\n let date = get({\n      year,\n      month,\n      day:31\n   }) ;\n\n if(month < 1 || month > 12){\n\n    return getLastDate(date.getFullYear() , date.getMonth() + 1) ;\n }\n\n while(date.getMonth() + 1 !== month){\n\n    date = prev(date) ;\n }\n\n return date ;\n\n\n    }\n    \n                    return function(year , month){\n    \n                        \n        if(!var_init_locked_1608956299395){\n\n            get = include('src::date.get');\nprev = include('src::date.prev');\ngetLastDate = include('src::month.date.last');\n\n            var_init_locked_1608956299395 = true ;\n        }\n        \n    \n                        return main.call(this , year , month) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "month.date.last"
  },
  "src::calendar.month": {
    "meta": "code.meta.script.function",
    "signature": "<array> src::calendar.month(<number> year , <number> month , {<number> row , <number> weekStartDay , <number> day , <boolean> ignoreNotCurrentMonthLastRow})",
    "standard": true,
    "importNames": [
      "src::date.get",
      "src::week.days",
      "src::date.prev",
      "src::date.next",
      "src::month.date.last"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,getDays,prev,next,getLastDate;\n    \n                    let var_init_locked_1608956299392;\n    \n                    \n\n                    function main(year , month , {row , weekStartDay , day , ignoreNotCurrentMonthLastRow}){\n\n        \n/**\n * \n * 显示以月份显示的日历数据\n * \n * @import get from date.get\n * \n * @import getDays from week.days\n * \n * @import prev from date.prev\n * \n * @import next from date.next\n * \n * @import getLastDate from month.date.last\n * \n * @param {number} year 年份\n * \n * @param {number} month 月份\n * \n * @param {object} [config = {}] 日历构造配置\n * \n * @param {number} [config.row = 6] 日历显示行数\n * \n * @param {number} [config.weekStartDay = 1] 每周从周几进行显示\n * \n * @param {number} [config.day] 指定日期所在周作为日历的第一周\n * \n * @param {boolean} [config.ignoreNotCurrentMonthLastRow = true] 是否忽略不是本月的尾行\n * \n * @return {array} 一组日历数据 \n * \n */\n\n\nif(!day){\n\n    day = 1 ;\n\n}\n\nlet lastDay = getLastDate(year , month).getDate() ;\n\nif(day > lastDay){\n\n    day = lastDay ;\n}\n\nlet date = get({\n    year,\n    month,\n    day\n}) ;\n\nlet days = getDays(weekStartDay),\n    prevCount = days.indexOf(date.getDay()),\n    nextCount = 6 - prevCount,\n    result = [\n        date\n    ];\n\nlet currentDate = date ;\n\nwhile(prevCount -- > 0){\n\n    result.unshift(date = prev(date)) ;\n}\n\ndate = currentDate ;\n\nwhile(nextCount -- > 0){\n\n    result.push(date = next(date)) ;\n}\n\nlet count = (row - 1) ;\n\nwhile(count -- > 0){\n\n    date = next(date) ;\n\n    if(ignoreNotCurrentMonthLastRow && date.getMonth() + 1 !== month){\n\n        break ;\n    }\n\n    result.push(date) ;\n\n    for(let i = 0 ; i < 6 ; i ++){\n\n        result.push(date = next(date)) ;\n    }\n\n    \n}\n\nreturn result ;\n\n\n\n\n\n    }\n    \n                    return function(year , month , {row = 6 , weekStartDay = 1 , day , ignoreNotCurrentMonthLastRow = true} = {}){\n    \n                        \n        if(!var_init_locked_1608956299392){\n\n            get = include('src::date.get');\ngetDays = include('src::week.days');\nprev = include('src::date.prev');\nnext = include('src::date.next');\ngetLastDate = include('src::month.date.last');\n\n            var_init_locked_1608956299392 = true ;\n        }\n        \n    \n                        return main.call(this , year , month , {row , weekStartDay , day , ignoreNotCurrentMonthLastRow}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month"
  },
  "src::calendar.month.view.deselect": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.deselect()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(){\n\n        \n/**\n * \n * 清除当前日历所有选定\n * \n */\n\n let me = this,\n {\n    proxy,\n    dates,\n    selectedDate\n } = me ;\n\n if(selectedDate){\n\n    selectedDate.selected = false ;\n\n    proxy.call('deselect' , dates.indexOf(selectedDate) , selectedDate) ;\n    \n }\n\n delete me.selectedDate ;\n \n\n    }\n    \n                    return function(){\n    \n                        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.deselect"
  },
  "src::calendar.month.view.select": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.select(<number> year , <number> month , <number> day)",
    "standard": true,
    "importNames": [
      "src::calendar.month.view.deselect",
      "src::month.date.last",
      "src::date.get.properties"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getLastDate,get;\n    \n                    let var_init_locked_1608956299399;\n \n                    \n\n                    const var_current_scope_1608956299399 = new Map();\n    \n                    return function(year , month , day){\n    \n                        \n        if(!var_init_locked_1608956299399){\n\n            getLastDate = include('src::month.date.last');\nget = include('src::date.get.properties');\n\n            var_init_locked_1608956299399 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299399.has(this)){\n\n            var_current_scope_1608956299399.set(this , (() => {\n                const deselect = include('src::calendar.month.view.deselect').bind(this);\n\n                function main(year , month , day){\n\n        \n/**\n * \n * 选定\n * \n * @import deselect from .deselect scoped\n * \n * @import getLastDate from month.date.last\n * \n * @import get from date.get.properties\n * \n * @param {number} year 选定年份\n * \n * @param {number} month 选定月份\n * \n * @param {number} day 选定日期\n * \n */\n\n let me = this,\n {\n    proxy,\n    selectedDate,\n    dates\n } = me;\n\n deselect() ;\n\n let {\n    day:lastDay\n } = get(getLastDate(year , month) , [\n    'day'\n ]) ;\n\n if(day > lastDay){\n\n   day = lastDay ;\n }\n\n let count = -1 ;\n\n for(let date of dates){\n\n   let {\n      year:itemYear,\n      month:itemMonth,\n      day:itemDay\n   } = date ;\n\n   count ++ ;\n\n   if(itemYear === year && itemMonth === month && itemDay === day){\n\n      me.selectedDate = date ;\n\n      date.selected = true ;\n\n      proxy.call('select' , count , date) ;\n\n      break ;\n   }\n }\n\n \n\n\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299399.get(this) ;\n\n        \n    \n                        return main.call(this , year , month , day) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.select"
  },
  "src::calendar.month.view.selectMonth": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.selectMonth(<number> year , <number> month)",
    "standard": true,
    "importNames": [
      "src::calendar.month",
      "src::calendar.month.view.deselect",
      "src::calendar.month.view.select",
      "src::date.get.properties"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getDates,getProperty;\n    \n                    let var_init_locked_1608956299388;\n \n                    \n\n                    const var_current_scope_1608956299388 = new Map();\n    \n                    return function(year , month){\n    \n                        \n        if(!var_init_locked_1608956299388){\n\n            getDates = include('src::calendar.month');\ngetProperty = include('src::date.get.properties');\n\n            var_init_locked_1608956299388 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299388.has(this)){\n\n            var_current_scope_1608956299388.set(this , (() => {\n                const deselect = include('src::calendar.month.view.deselect').bind(this);\nconst select = include('src::calendar.month.view.select').bind(this);\n\n                function main(year , month){\n\n        \n/**\n * \n * 选定月份\n * \n * @import getDates from ....month\n * \n * @import deselect from .deselect scoped\n * \n * @import select from .select scoped\n * \n * @import getProperty from date.get.properties\n * \n * @param {number} year 年份\n * \n * @param {number} month 月份\n * \n */\n\n let me = this,\n {\n    selectedDate,\n    weekStartDay,\n    viewConfig\n } = me;\n\n deselect() ;\n\n let fields = [\n        'year',\n        'month',\n        'day'\n     ],\n     dates = me.dates = getDates(year , month , {\n        ...viewConfig,\n        weekStartDay\n     }).map(date =>{\n\n        let {\n            year:itemYear,\n            month:itemMonth,\n            day\n        } = getProperty(date , fields),\n        activate = year === itemYear && month === itemMonth;\n        \n        return {\n            activate,\n            year:itemYear,\n            month:itemMonth,\n            day,\n            selected:false,\n            key:date.getTime()\n        } ;\n\n    }) ;\n\nme.year = year ;\n\nme.month = month ;\n\nme.proxy.call('load' , year , month , dates) ;\n\nif(selectedDate){\n\n    let {\n        day\n    } = selectedDate,\n    {\n        year,\n        month\n    } = me;\n\n    select(year , month , day) ;\n}\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299388.get(this) ;\n\n        \n    \n                        return main.call(this , year , month) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.selectMonth"
  },
  "src::calendar.month.view.constructor": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.constructor(<mixed> target , {<object> selectedDate , <number> weekStartDay , <object> viewConfig})",
    "standard": true,
    "importNames": [
      "src::object.proxy",
      "src::calendar.month.view.selectMonth",
      "src::calendar.month.view.select",
      "src::date.get.properties"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getProxy,getProperty;\n    \n                    let var_init_locked_1608956299385;\n \n                    \n\n                    const var_current_scope_1608956299385 = new Map();\n    \n                    return function(target , {selectedDate , weekStartDay = 0 , viewConfig = {}} = {}){\n    \n                        \n        if(!var_init_locked_1608956299385){\n\n            getProxy = include('src::object.proxy');\ngetProperty = include('src::date.get.properties');\n\n            var_init_locked_1608956299385 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299385.has(this)){\n\n            var_current_scope_1608956299385.set(this , (() => {\n                const selectMonth = include('src::calendar.month.view.selectMonth').bind(this);\nconst select = include('src::calendar.month.view.select').bind(this);\n\n                function main(target , {selectedDate , weekStartDay , viewConfig}){\n\n        \n/**\n * \n * 构建一个月基日历\n * \n * @import getProxy from object.proxy\n * \n * @import selectMonth from .selectMonth scoped\n * \n * @import select from .select scoped\n * \n * @import getProperty from date.get.properties\n * \n * @param {mixed} target 可提供日历显示的套件\n * \n * @param {object} [config = {}] 初始化配置\n * \n * @param {object} [config.selectedDate] 初始化选择日期\n * \n * @param {number} [config.weekStartDay = 0] 默认从星期天进行计算\n * \n * @param {object} [config.viewConfig = {}] 日历视图设置\n * \n */\n\n let me = this ;\n\n me.viewConfig = viewConfig ;\n\n me.weekStartDay = weekStartDay ;\n\n me.proxy = getProxy(target) ;\n\n me.selectedDates = [] ;\n\n me.dates = [] ;\n\n if(!selectedDate){\n\n    selectedDate = getProperty(new Date() , [\n        'year',\n        'month',\n        'day'\n    ]) ;\n }\n\n let {\n     year,\n     month,\n     day\n } = selectedDate ;\n\n selectMonth(year , month) ;\n\n select(year , month , day) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299385.get(this) ;\n\n        \n    \n                        return main.call(this , target , {selectedDate , weekStartDay , viewConfig}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.constructor"
  },
  "src::month.prev": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::month.prev(<Date|object> date)",
    "standard": true,
    "importNames": [
      "src::date.get",
      "src::date.get.properties",
      "src::is.date"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,getProperty,isDate;\n    \n                    let var_init_locked_1608956299409;\n    \n                    \n\n                    function main(date){\n\n        /**\n * \n * 获得指定月份的上一个月份\n * \n * @import get from date.get\n * \n * @import getProperty from date.get.properties\n * \n * @import is.date\n * \n * @param {Date | object} date 包括月份的日期对象 \n * \n * @return {Date} 上一个月份 \n * \n */\n\n if(isDate(date)){\n\n    date = getProperty(date , [\n        'year',\n        'month'\n    ]) ;\n }\n\n let {\n    month,\n    ...other\n } = date ;\n\n month -- ;\n\n console.log(month , get({\n   month,\n  ...other\n}).toJSON()) ;\n\n return get({\n     month,\n    ...other\n }) ;\n\n    }\n    \n                    return function(date){\n    \n                        \n        if(!var_init_locked_1608956299409){\n\n            get = include('src::date.get');\ngetProperty = include('src::date.get.properties');\nisDate = include('src::is.date');\n\n            var_init_locked_1608956299409 = true ;\n        }\n        \n    \n                        return main.call(this , date) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "month.prev"
  },
  "src::calendar.month.view.selectPrevMonth": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.selectPrevMonth()",
    "standard": true,
    "importNames": [
      "src::month.prev",
      "src::date.get.properties",
      "src::calendar.month.view.selectMonth"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let prev,getProperty;\n    \n                    let var_init_locked_1608956299407;\n \n                    \n\n                    const var_current_scope_1608956299407 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956299407){\n\n            prev = include('src::month.prev');\ngetProperty = include('src::date.get.properties');\n\n            var_init_locked_1608956299407 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299407.has(this)){\n\n            var_current_scope_1608956299407.set(this , (() => {\n                const selectMonth = include('src::calendar.month.view.selectMonth').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向上移动月份\n * \n * @import prev from month.prev\n * \n * @import getProperty from date.get.properties\n * \n * @import selectMonth from .selectMonth scoped\n * \n */\n\nlet me = this,\n{\n    year,\n    month\n} = me,\n{\n   year:selectedYear,\n   month:selectedMonth\n} = getProperty(prev({\n    year,\n    month\n}) , [\n    'year',\n    'month'\n]) ;\n\nselectMonth(selectedYear , selectedMonth) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299407.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.selectPrevMonth"
  },
  "src::calendar.month.view.selectLeft": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.selectLeft()",
    "standard": true,
    "importNames": [
      "src::is.week.day.first",
      "src::date.get",
      "src::calendar.month.view.selectPrevMonth",
      "src::date.prev",
      "src::date.get.properties",
      "src::calendar.month.view.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFirst,get,prevDate,getProperty;\n    \n                    let var_init_locked_1608956299402;\n \n                    \n\n                    const var_current_scope_1608956299402 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956299402){\n\n            isFirst = include('src::is.week.day.first');\nget = include('src::date.get');\nprevDate = include('src::date.prev');\ngetProperty = include('src::date.get.properties');\n\n            var_init_locked_1608956299402 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299402.has(this)){\n\n            var_current_scope_1608956299402.set(this , (() => {\n                const prevMonth = include('src::calendar.month.view.selectPrevMonth').bind(this);\nconst select = include('src::calendar.month.view.select').bind(this);\n\n                function main(){\n\n        /**\n * \n * 向左移一个格\n * \n * @import isFirst from is.week.day.first\n * \n * @import get from date.get\n * \n * @import prevMonth from .selectPrevMonth scoped\n * \n * @import prevDate from date.prev\n * \n * @import getProperty from date.get.properties\n * \n * @import select from .select scoped\n * \n */\n\n let {\n    selectedDate,\n    weekStartDay,\n    month\n } = this ;\n\n if(selectedDate){\n\n    let date = get(selectedDate) ;\n\n    if(isFirst(date , weekStartDay)){\n\n        prevMonth() ;\n    \n    }else{\n\n        date = prevDate(date) ;\n\n        let {\n            year:prevYearValue,\n            month:prevMonthValue,\n            day\n        } = getProperty(date , [\n            'year',\n            'month',\n            'day'\n        ]) ;\n\n        if(prevMonthValue !== month){\n\n            prevMonth() ;\n        }\n\n        select(prevYearValue , prevMonthValue , day) ;\n    }\n }\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299402.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.selectLeft"
  },
  "src::month.next": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::month.next(<Date|object> date)",
    "standard": true,
    "importNames": [
      "src::date.get",
      "src::date.get.properties",
      "src::is.date"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get,getProperty,isDate;\n    \n                    let var_init_locked_1608956299417;\n    \n                    \n\n                    function main(date){\n\n        /**\n * \n * 获得指定月份的下一个月份\n * \n * @import get from date.get\n * \n * @import getProperty from date.get.properties\n * \n * @import is.date\n * \n * @param {Date | object} date 包括月份的日期对象 \n * \n * @return {Date} 下一个月份 \n * \n */\n\n if(isDate(date)){\n\n    date = getProperty(date , [\n        'year',\n        'month'\n    ]) ;\n }\n\n let {\n    month,\n    ...other\n } = date ;\n\n month ++ ;\n\n return get({\n     month,\n    ...other\n }) ;\n\n    }\n    \n                    return function(date){\n    \n                        \n        if(!var_init_locked_1608956299417){\n\n            get = include('src::date.get');\ngetProperty = include('src::date.get.properties');\nisDate = include('src::is.date');\n\n            var_init_locked_1608956299417 = true ;\n        }\n        \n    \n                        return main.call(this , date) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "month.next"
  },
  "src::calendar.month.view.selectNextMonth": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.selectNextMonth()",
    "standard": true,
    "importNames": [
      "src::month.next",
      "src::date.get.properties",
      "src::calendar.month.view.selectMonth"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let next,getProperty;\n    \n                    let var_init_locked_1608956299415;\n \n                    \n\n                    const var_current_scope_1608956299415 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956299415){\n\n            next = include('src::month.next');\ngetProperty = include('src::date.get.properties');\n\n            var_init_locked_1608956299415 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299415.has(this)){\n\n            var_current_scope_1608956299415.set(this , (() => {\n                const selectMonth = include('src::calendar.month.view.selectMonth').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向下移动月份\n * \n * @import next from month.next\n * \n * @import getProperty from date.get.properties\n * \n * @import selectMonth from .selectMonth scoped\n * \n */\n\n let me = this,\n {\n     year,\n     month\n } = me,\n {\n    year:selectedYear,\n    month:selectedMonth\n } = getProperty(next({\n     year,\n     month\n }) , [\n     'year',\n     'month'\n ]) ;\n\n\n selectMonth(selectedYear , selectedMonth) ;\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299415.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.selectNextMonth"
  },
  "src::calendar.month.view.selectRight": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.selectRight()",
    "standard": true,
    "importNames": [
      "src::is.week.day.last",
      "src::date.get",
      "src::calendar.month.view.selectNextMonth",
      "src::date.next",
      "src::date.get.properties",
      "src::calendar.month.view.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isLast,get,nextDate,getProperty;\n    \n                    let var_init_locked_1608956299412;\n \n                    \n\n                    const var_current_scope_1608956299412 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956299412){\n\n            isLast = include('src::is.week.day.last');\nget = include('src::date.get');\nnextDate = include('src::date.next');\ngetProperty = include('src::date.get.properties');\n\n            var_init_locked_1608956299412 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299412.has(this)){\n\n            var_current_scope_1608956299412.set(this , (() => {\n                const nextMonth = include('src::calendar.month.view.selectNextMonth').bind(this);\nconst select = include('src::calendar.month.view.select').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向右移一个格日期\n * \n * @import isLast from is.week.day.last\n * \n * @import get from date.get\n * \n * @import nextMonth from .selectNextMonth scoped\n * \n * @import nextDate from date.next\n * \n * @import getProperty from date.get.properties\n * \n * @import select from .select scoped\n * \n */\n\n\nlet {\n    selectedDate,\n    weekStartDay,\n    month\n } = this ;\n\n if(selectedDate){\n\n    let date = get(selectedDate) ;\n\n    if(isLast(date , weekStartDay)){\n\n        nextMonth() ;\n    \n    }else{\n\n        date = nextDate(date) ;\n\n        let {\n            year:nextYearValue,\n            month:nextMonthValue,\n            day\n        } = getProperty(date , [\n            'year',\n            'month',\n            'day'\n        ]) ;\n\n        if(nextMonthValue !== month){\n\n            nextMonth() ;\n        }\n\n        select(nextYearValue , nextMonthValue , day) ;\n    }\n }\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299412.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.selectRight"
  },
  "src::month.date.first": {
    "meta": "code.meta.script.function",
    "signature": "<Date> src::month.date.first(<number> year , <number> month)",
    "standard": true,
    "importNames": [
      "src::date.get"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let get;\n    \n                    let var_init_locked_1608956299426;\n    \n                    \n\n                    function main(year , month){\n\n        \n/**\n * \n * 指定月份的第一个日期\n * \n * @import get from date.get\n * \n * @param {number} year 年份\n * \n * @param {number} month 月份\n * \n * @return {Date} 日期对象 \n * \n */\n\n return get({\n      year,\n      month,\n      day:1\n   }) ;\n\n    }\n    \n                    return function(year , month){\n    \n                        \n        if(!var_init_locked_1608956299426){\n\n            get = include('src::date.get');\n\n            var_init_locked_1608956299426 = true ;\n        }\n        \n    \n                        return main.call(this , year , month) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "month.date.first"
  },
  "src::month.dates.week.first": {
    "meta": "code.meta.script.function",
    "signature": "<Date[]> src::month.dates.week.first(<number> year , <number> month , <number> weekStartDay)",
    "standard": true,
    "importNames": [
      "src::week.days",
      "src::month.date.first",
      "src::date.next"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getDays,getFirstDate,next;\n    \n                    let var_init_locked_1608956299421;\n    \n                    \n\n                    function main(year , month , weekStartDay){\n\n        \n/**\n * \n * 获得指定月份的第一周的所有日期\n * \n * @import getDays from week.days\n * \n * @import getFirstDate from month.date.first\n * \n * @import next from date.next\n * \n * @param {number} year 年份 \n * \n * @param {number} month 月份\n * \n * @param {number} [weekStartDay = 1] 确定一周从周几进行计算\n * \n * @return {Date[]} 一周里所有的日期 \n * \n */\n\nlet days = getDays(weekStartDay),\n    date = getFirstDate(year , month),\n    firstIndex = days.indexOf(date.getDay()),\n    result = [\n        date\n    ];\n\nfor(let i = firstIndex + 1; i < 7 ; i ++){\n\n    result.push(date = next(date)) ;\n}\n\nreturn result ;\n\n\n\n \n\n    }\n    \n                    return function(year , month , weekStartDay = 1){\n    \n                        \n        if(!var_init_locked_1608956299421){\n\n            getDays = include('src::week.days');\ngetFirstDate = include('src::month.date.first');\nnext = include('src::date.next');\n\n            var_init_locked_1608956299421 = true ;\n        }\n        \n    \n                        return main.call(this , year , month , weekStartDay) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "month.dates.week.first"
  },
  "src::calendar.month.view.selectUp": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.selectUp()",
    "standard": true,
    "importNames": [
      "src::month.dates.week.first",
      "src::array.dates.includes",
      "src::date.get",
      "src::calendar.month.view.selectPrevMonth",
      "src::date.prev.week",
      "src::date.get.properties",
      "src::calendar.month.view.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getFirstWeekDates,includes,get,prevDate,getProperty;\n    \n                    let var_init_locked_1608956299419;\n \n                    \n\n                    const var_current_scope_1608956299419 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956299419){\n\n            getFirstWeekDates = include('src::month.dates.week.first');\nincludes = include('src::array.dates.includes');\nget = include('src::date.get');\nprevDate = include('src::date.prev.week');\ngetProperty = include('src::date.get.properties');\n\n            var_init_locked_1608956299419 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299419.has(this)){\n\n            var_current_scope_1608956299419.set(this , (() => {\n                const prevMonth = include('src::calendar.month.view.selectPrevMonth').bind(this);\nconst select = include('src::calendar.month.view.select').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向上移一格日期\n * \n * @import getFirstWeekDates from month.dates.week.first\n * \n * @import includes from array.dates.includes\n * \n * @import get from date.get\n * \n * @import prevMonth from .selectPrevMonth scoped\n * \n * @import prevDate from date.prev.week\n * \n * @import getProperty from date.get.properties\n * \n * @import select from .select scoped\n * \n */\n\nlet {\n    selectedDate,\n    weekStartDay,\n    year,\n    month\n } = this ;\n\n if(selectedDate){\n\n    let dates = getFirstWeekDates(year , month , weekStartDay),\n        date = get(selectedDate) ;\n\n    if(includes(dates , date)){\n\n        prevMonth() ;\n    \n    }else{\n\n        date = prevDate(date) ;\n\n        let {\n            year:prevYearValue,\n            month:prevMonthValue,\n            day\n        } = getProperty(date , [\n            'year',\n            'month',\n            'day'\n        ]) ;\n\n        if(prevMonthValue !== month){\n\n            prevMonth() ;\n        }\n\n        select(prevYearValue , prevMonthValue , day) ;\n    }\n }\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299419.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.selectUp"
  },
  "src::month.dates.week.last": {
    "meta": "code.meta.script.function",
    "signature": "<Date[]> src::month.dates.week.last(<number> year , <number> month , <number> weekStartDay)",
    "standard": true,
    "importNames": [
      "src::week.days",
      "src::month.date.last",
      "src::date.prev"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getDays,getLastDate,prev;\n    \n                    let var_init_locked_1608956299432;\n    \n                    \n\n                    function main(year , month , weekStartDay){\n\n        \n/**\n * \n * 获得指定月份的最后一周的所有日期\n * \n * @import getDays from week.days\n * \n * @import getLastDate from month.date.last\n * \n * @import prev from date.prev\n * \n * @param {number} year 年份 \n * \n * @param {number} month 月份\n * \n * @param {number} [weekStartDay = 1] 确定一周从周几进行计算\n * \n * @return {Date[]} 一周里所有的日期 \n * \n */\n\nlet days = getDays(weekStartDay),\n    date = getLastDate(year , month),\n    lastIndex = days.indexOf(date.getDay()),\n    result = [\n        date\n    ];\n\nfor(let i = lastIndex - 1; i >= 0 ; i --){\n\n    result.push(date = prev(date)) ;\n}\n\nreturn result ;\n\n    }\n    \n                    return function(year , month , weekStartDay = 1){\n    \n                        \n        if(!var_init_locked_1608956299432){\n\n            getDays = include('src::week.days');\ngetLastDate = include('src::month.date.last');\nprev = include('src::date.prev');\n\n            var_init_locked_1608956299432 = true ;\n        }\n        \n    \n                        return main.call(this , year , month , weekStartDay) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "month.dates.week.last"
  },
  "src::calendar.month.view.selectDown": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::calendar.month.view.selectDown()",
    "standard": true,
    "importNames": [
      "src::month.dates.week.last",
      "src::array.dates.includes",
      "src::date.get",
      "src::calendar.month.view.selectNextMonth",
      "src::date.next.week",
      "src::date.get.properties",
      "src::calendar.month.view.select"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let getLastWeekDates,includes,get,nextDate,getProperty;\n    \n                    let var_init_locked_1608956299429;\n \n                    \n\n                    const var_current_scope_1608956299429 = new Map();\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956299429){\n\n            getLastWeekDates = include('src::month.dates.week.last');\nincludes = include('src::array.dates.includes');\nget = include('src::date.get');\nnextDate = include('src::date.next.week');\ngetProperty = include('src::date.get.properties');\n\n            var_init_locked_1608956299429 = true ;\n        }\n        \n    \n                        \n        \n        if(!var_current_scope_1608956299429.has(this)){\n\n            var_current_scope_1608956299429.set(this , (() => {\n                const nextMonth = include('src::calendar.month.view.selectNextMonth').bind(this);\nconst select = include('src::calendar.month.view.select').bind(this);\n\n                function main(){\n\n        \n/**\n * \n * 向下移一格日期\n * \n * @import getLastWeekDates from month.dates.week.last\n * \n * @import includes from array.dates.includes\n * \n * @import get from date.get\n * \n * @import nextMonth from .selectNextMonth scoped\n * \n * @import nextDate from date.next.week\n * \n * @import getProperty from date.get.properties\n * \n * @import select from .select scoped\n * \n */\n\n let {\n    selectedDate,\n    weekStartDay,\n    year,\n    month\n } = this ;\n\n if(selectedDate){\n\n    let dates = getLastWeekDates(year , month , weekStartDay),\n        date = get(selectedDate) ;\n\n    if(includes(dates , date)){\n\n        nextMonth() ;\n    \n    }else{\n\n        date = nextDate(date) ;\n\n        let {\n            year:nextYearValue,\n            month:nextMonthValue,\n            day\n        } = getProperty(date , [\n            'year',\n            'month',\n            'day'\n        ]) ;\n\n        if(nextMonthValue !== month){\n\n            nextMonth() ;\n        }\n\n        select(nextYearValue , nextMonthValue , day) ;\n    }\n }\n\n\n\n    }\n\n                return main ;\n\n            })());\n        }\n\n        const main = var_current_scope_1608956299429.get(this) ;\n\n        \n    \n                        return main.call(this ) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "calendar.month.view.selectDown"
  },
  "src::miniprogram.storage": {
    "meta": "code.meta.script.function",
    "signature": "<mixed> src::miniprogram.storage(<mixed> data)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    let var_class_1608956299435;\n    \n                    let var_once_value_1608956299435;\n\n                    let var_global_main_1608956299435 ;\n    \n                    return function(data){\n    \n                        \n        if(!var_init_locked_1608956299435){\n\n            \n\n            \n/**\n * \n * 存储器\n * \n * @param {mixed} data 参数说明\n * \n * @return {mixed} 返回说明 \n * \n * @once\n * \n */\n\n class main{\n\n    setItem(name , value){\n\n        wx.setStorageSync(name , value) ;\n    }\n\n    getItem(name){\n\n        return wx.getStorageSync(name) ;\n    }\n\n    removeItem(name){\n\n        wx.removeStorageSync(name) ;\n    }\n\n    clear(){\n\n        wx.clearStorageSync() ;\n    }\n }\n\n            var_class_1608956299435 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956299435 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::miniprogram.storage' ;\n                }\n\n            } ;\n\n            main = var_class_1608956299435 ;\n        \nvar_global_main_1608956299435 = main;\n\n            var_init_locked_1608956299435 = true ;\n        }\n        \n    \n                        \n        if(var_once_value_1608956299435){\n\n            return var_once_value_1608956299435 ;\n\n        }\n        return var_once_value_1608956299435 = new var_global_main_1608956299435(data) ;\n        \n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "miniprogram.storage"
  },
  "src::number.format": {
    "meta": "code.meta.script.function",
    "signature": "<number> src::number.format(<mixed> data , <number> count)",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "(() =>{\n\n                    \n    \n                    \n    \n                    \n\n                    function main(data , count){\n\n        \n/**\n * \n * 格式化数字\n * \n * @param {mixed} data 数值\n * \n * @param {number} count 数值\n * \n * @return {number} 格式化后的数字字符串 \n * \n */\n\n return String(data).padStart(count , '0') ;\n\n    }\n    \n                    return function(data , count){\n    \n                        \n    \n                        return main.call(this , data , count) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "number.format"
  },
  "src::log.node": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::log.node(<string> path)",
    "standard": true,
    "importNames": [
      "src::date.format",
      "src::file.stream.write"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let format,createStream;\n    \n                    let var_init_locked_1608956299441;\n    \n                    let var_class_1608956299441;\n    \n                    \n\n                    let var_global_main_1608956299441 ;\n    \n                    return function(path){\n    \n                        \n        if(!var_init_locked_1608956299441){\n\n            format = include('src::date.format');\ncreateStream = include('src::file.stream.write');\n\n            \n/**\n * \n * Node 版 日志\n *\n * @import format from date.format\n * \n * @import createStream from file.stream.write\n * \n * @param {string} path 日志路径\n * \n */\n\n const {\n    Console\n } = require('console'),\n {\n    join\n } = require('path');\n\n class main{\n\n    constructor(path){\n\n        this.console = new Console(createStream(join(path , `${format(new Date() , 'YYYYMMDD')}.log`) , {\n            flags:'a'\n        })) ;\n    }\n\n    log(...args){\n\n        doMethod.call(this , 'log' , ...args) ;\n    }\n }\n\n function doMethod(method , ...args){\n\n    let {\n        console\n    } = this ;\n\n    console[method](format(new Date() , 'YYYY-MM-DD HH:mm:ss') , ...args) ;\n }\n\n            var_class_1608956299441 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956299441 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::log.node' ;\n                }\n\n            } ;\n\n            main = var_class_1608956299441 ;\n        \nvar_global_main_1608956299441 = main;\n\n            var_init_locked_1608956299441 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956299441(path) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "log.node"
  },
  "src::process.spawn": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::process.spawn(<object> options)",
    "standard": true,
    "importNames": [
      "src::process",
      "src::event.listener.add",
      "src::event.listener.remove.all"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Process,add,removeAll;\n    \n                    let var_init_locked_1608956299445;\n    \n                    let var_class_1608956299445;\n    \n                    \n\n                    let var_global_main_1608956299445 ;\n    \n                    return function(options){\n    \n                        \n        if(!var_init_locked_1608956299445){\n\n            Process = include('src::process')();\nadd = include('src::event.listener.add');\nremoveAll = include('src::event.listener.remove.all');\n\n            \n/**\n * \n * 基于 spawn 进程实现\n * \n * @import Process from ..process value\n * \n * @import add from event.listener.add\n * \n * @import removeAll from event.listener.remove.all\n * \n * @param {object} options 配置\n * \n */\n\n const {\n    spawn\n } = require('child_process') ;\n\n class main extends Process{\n\n    doStart(){\n\n        let me = this,\n            {\n                command\n            } = me.options,\n            process = spawn(command),\n            {\n                stdout\n            } = process;\n\n        add(stdout , 'data' , 'onStart' , {\n            scope:me,\n            once:true\n        }) ;\n\n        add(process , {\n            exit:'onEnd',\n            error:'onEnd',\n            scope:me\n        }) ;\n\n        me.process = process ;\n    }\n\n    get started(){\n\n        return this.hasOwnProperty('process') ;\n    }\n\n    onEnd(code , signal){\n\n        let me = this,\n        {\n            process\n        } = me;\n\n        removeAll(process) ;\n\n        removeAll(process.stdout) ;\n\n        delete me.process ;\n\n        super.onEnd(signal === 'NORMAL') ;\n    }\n\n    doEnd(){\n\n        let {\n            process\n        } = this ;\n\n        process.kill('NORMAL') ;\n    }\n }\n\n            var_class_1608956299445 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956299445 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::process.spawn' ;\n                }\n\n            } ;\n\n            main = var_class_1608956299445 ;\n        \nvar_global_main_1608956299445 = main;\n\n            var_init_locked_1608956299445 = true ;\n        }\n        \n    \n                        return new var_global_main_1608956299445(options) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "process.spawn"
  },
  "src::process": {
    "meta": "code.meta.script.function",
    "signature": "<void> src::process()",
    "standard": true,
    "importNames": [
      "src::mixin.observable",
      "src::event.listener.add"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let Observable,add;\n    \n                    let var_init_locked_1608956299448;\n    \n                    let var_class_1608956299448;\n    \n                    \n\n                    let var_global_main_1608956299448 ;\n    \n                    return function(){\n    \n                        \n        if(!var_init_locked_1608956299448){\n\n            Observable = include('src::mixin.observable');\nadd = include('src::event.listener.add');\n\n            \n/**\n * \n * 进程管理器\n * \n * @import Observable from mixin.observable\n * \n * @import add from event.listener.add\n * \n * @class\n * \n */\n\n class main extends mixins({\n    mixins:[\n       Observable\n    ]\n}){\n\n    constructor(options = {}){\n\n        super(options) ;\n\n        let me = this ;\n\n        me.options = options ;\n\n        let {\n            autoStart = true,\n            reStart = true,\n        } = options ;\n\n        if(autoStart){\n\n            me.start() ;\n        }\n\n        if(reStart){\n\n            add(me , 'crash' , () => me.start()) ;\n        }\n    }\n\n    get started(){\n\n        return true ;\n    }\n\n    onStart(){\n\n        this.fireEvent('start') ;\n    }\n\n    onEnd(isNormal){\n\n        let me = this ;\n\n        if(isNormal){\n\n            me.fireEvent('end') ;\n        \n        }else{\n\n            me.fireEvent('crash') ;\n        }\n\n        me.fireEvent('exit') ;\n    }\n\n    start(){\n\n        let me = this,\n        {\n            started\n        } = me ;\n\n        if(!started){\n\n            me.doStart() ;\n        }\n    }\n\n    doStart(){\n\n\n    }\n\n    end(){\n\n        let me = this,\n        {\n            started\n        } = me;\n\n        if(started){\n\n            me.doEnd() ;\n        }        \n    }\n\n    doEnd(){\n\n\n    }\n }\n\n            var_class_1608956299448 = class extends main{\n\n                static get __ZBEE_IS_CLASS__(){\n\n                    return true ;\n                }\n\n\n                get __ZBEE_CLASS__(){\n\n                    return true ;\n                }\n\n                get __ZBEE_CURRENT_CLASS__(){\n\n                    return var_class_1608956299448 ;\n                }\n\n                get __ZBEE_CLASS_NAME__(){\n\n                    return 'src::process' ;\n                }\n\n            } ;\n\n            main = var_class_1608956299448 ;\n        \nvar_global_main_1608956299448 = main;\n\n            var_init_locked_1608956299448 = true ;\n        }\n        \n    \n                        return var_global_main_1608956299448 ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "process"
  },
  "src::vue.component": {
    "meta": "code.meta.script.function",
    "signature": "<object> src::vue.component(<string> name , <object> config , {<object> methods , <function> mounted , <function> destroyed , <object> computed , <function> data})",
    "standard": true,
    "importNames": [
      "src::is.function"
    ],
    "dependentModules": {},
    "data": "(() =>{\n\n                    let isFunction;\n    \n                    let var_init_locked_1608956299453;\n    \n                    \n\n                    function main(name , config , {methods , mounted , destroyed , computed , data}){\n\n        \n/**\n * \n * Vue 组件\n * \n * @import is.function\n * \n * @param {string} name 属性名称\n * \n * @param {object} config 组件原始设置\n * \n * @param {object} extend 组件扩展配置\n * \n * @param {object} [extend.methods = {}] 组件方法配置\n * \n * @param {function} [extend.mounted = () => {}] 组件初始时调用\n * \n * @param {function} [extend.destroyed = () => {}] 组件销毁时调用\n * \n * @param {object} [extend.computed = {}] 组件计算属性\n * \n * @param {function} [extend.data = () => {return {};}] 组件初始化数据结构 \n * \n * @return {object} Vue 组件配置\n * \n */\n\nconst {\n    assign\n } = Object ;\n\n let {\n    mounted:originMounted,\n    destroyed:originDestroyed,\n    computed:originComputed = {},\n    methods:originMethods = {},\n    data:originData,\n    ...options\n } = config,\n componentConfig = options[name];\n\n delete options[name] ;\n\nmethods = assign({} , methods , originMethods),\ncomputed = assign({} , computed , originComputed);\n\n\nif(isFunction(originData)){\n\n   let innerData = data ;\n\n   data = function(){\n\n    let me = this ;\n\n    return Object.assign(originData.call(me) || {} , innerData.call(me)) ;\n\n   } ;\n\n}\n\nlet innerMounted = mounted ;\n\nif(originMounted){\n\n    mounted = function(){\n\n        let me = this ;\n\n        innerMounted.call(me , componentConfig) ;\n\n        originMounted.call(me) ;\n    } ;\n\n}else{\n\n   mounted = function(){\n\n      innerMounted.call(this , componentConfig) ;\n\n   } ;\n}\n\nlet innerDestroyed = destroyed ;\n\nif(originDestroyed){\n\n   destroyed = function(){\n\n      let me = this ;\n\n      innerDestroyed.call(me , componentConfig) ;\n\n      originDestroyed.call(me) ;\n\n   } ;\n\n}else{\n\n   destroyed = function(){\n\n      innerDestroyed.call(this , componentConfig) ;\n   } ;\n}\n\nreturn {\n    ...options,\n    data,\n    computed,\n    mounted,\n    destroyed,\n    methods\n} ;\n\n\n    }\n    \n                    return function(name , config , {methods = {} , mounted = () => {} , destroyed = () => {} , computed = {} , data = () => {return {};}}){\n    \n                        \n        if(!var_init_locked_1608956299453){\n\n            isFunction = include('src::is.function');\n\n            var_init_locked_1608956299453 = true ;\n        }\n        \n    \n                        return main.call(this , name , config , {methods , mounted , destroyed , computed , data}) ;\n                    } ;\n    \n                })()",
    "folder": "src",
    "name": "vue.component"
  },
  "css::reset.viewport": {
    "meta": "code.meta.scss",
    "signature": "<void> css::reset.viewport()",
    "standard": true,
    "importNames": [
      "css::reset"
    ],
    "dependentModules": {},
    "data": "() => `@import \"../css/reset.scss\" ;\n\nhtml,body {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}`",
    "folder": "css",
    "name": "reset.viewport"
  },
  "css::reset": {
    "meta": "code.meta.scss",
    "signature": "<void> css::reset()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "() => `$css-reset-font-family:\"Helvetica Neue\", HelveticaNeue, \"Helvetica-Neue\", Helvetica, \"BBAlpha Sans\", sans-serif !default;\n\nhtml, body {\n    font-family: $css-reset-font-family;\n    font-weight: normal;\n    text-size-adjust: none;\n    margin: 0;\n    cursor: default;\n}\n\nbody, div, dl, dt, dd, ul, ol, li, h1, h2, h3,\nh4, h5, h6, pre, code, form, fieldset, legend,\ninput, textarea, p, blockquote, th, td {\n    margin: 0;\n    padding: 0;\n}\n\ntable {\n    border-collapse: collapse;\n    border-spacing: 0;\n}\n\nfieldset, img {\n    border: 0;\n}\n\naddress, caption, cite, code, dfn, em, strong, th, var {\n    font-style: normal;\n    font-weight: normal;\n}\n\nli {\n    list-style: none;\n}\n\ncaption, th {\n    text-align: left;\n}\n\nh1, h2, h3, h4, h5, h6 {\n    font-size: 100%;\n    font-weight: normal;\n}\n\nq:before,\nq:after {\n    content: '';\n}\n\nabbr, acronym {\n    border: 0;\n    font-variant: normal;\n}\n\nsup {\n    vertical-align: text-top;\n}\n\nsub {\n    vertical-align: text-bottom;\n}\n\ninput, textarea, select {\n    font-family: inherit;\n    font-size: inherit;\n    font-weight: inherit;\n}\n\n*:focus {\n    outline: none;\n}\n\n*, *:after, *:before {\n    box-sizing: border-box;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    -webkit-touch-callout: none;\n    -webkit-user-drag: none;\n    user-select: none;\n    touch-action: none;\n}\n\ninput, textarea {\n    user-select: text;\n}`",
    "folder": "css",
    "name": "reset"
  },
  "css::layout.center": {
    "meta": "code.meta.scss",
    "signature": "<void> css::layout.center()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "prefix => `.${prefix}-layout-center,.css-layout-center{\n    &{\n    display:flex;\n    align-items:center;\n    justify-content: center;\n}\n}`",
    "folder": "css",
    "name": "layout.center"
  },
  "css::layout.fit.sized": {
    "meta": "code.meta.scss",
    "signature": "<void> css::layout.fit.sized()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "() => `.xy-layout-fit-sized,.css-layout-fit-sized{\n    &{\n    position: absolute;\n    top:0;\n    bottom:0;\n    left:0;\n    right:0;\n}\n}`",
    "folder": "css",
    "name": "layout.fit.sized"
  },
  "css::layout.fit.unsized": {
    "meta": "code.meta.scss",
    "signature": "<void> css::layout.fit.unsized()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "prefix => `.${prefix}-layout-fit-unsized,.css-layout-fit-unsized{\n    &{\n    width:100%;\n    height:100%;\n}\n}`",
    "folder": "css",
    "name": "layout.fit.unsized"
  },
  "css::layout.flex": {
    "meta": "code.meta.scss",
    "signature": "<void> css::layout.flex()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "() => `$css-layout-flex-max:3 !default;\n\n@for $flex from 1 through $css-layout-flex-max{\n    .xy-layout-flex-#{$flex}{\n        flex:$flex;\n    }\n}`",
    "folder": "css",
    "name": "layout.flex"
  },
  "css::layout.horizontal": {
    "meta": "code.meta.scss",
    "signature": "<void> css::layout.horizontal()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "prefix => `.${prefix}-layout-horizontal,.css-layout-horizontal{\n    &{\n    display:flex;\n    flex-direction: row;\n    align-items:stretch;\n    justify-content: flex-start;\n}\n}`",
    "folder": "css",
    "name": "layout.horizontal"
  },
  "css::layout.vertical": {
    "meta": "code.meta.scss",
    "signature": "<void> css::layout.vertical()",
    "standard": true,
    "importNames": [],
    "dependentModules": {},
    "data": "prefix => `.${prefix}-layout-vertical,.css-layout-vertical{\n    &{\n    display:flex;\n    flex-direction: column;\n    align-items:stretch;\n    justify-content: flex-start;\n}\n}`",
    "folder": "css",
    "name": "layout.vertical"
  },
  "css::mindmap": {
    "meta": "code.meta.scss",
    "signature": "<void> css::mindmap()",
    "standard": true,
    "importNames": [
      "css::layout.fit.unsized"
    ],
    "dependentModules": {},
    "data": "prefix => `@import \"../css/layout.fit.unsized.scss\" ;\n\n.${prefix}-mindmap,.css-mindmap {\n\n& {\n    @extend .css-layout-fit-unsized ;\n    position: relative;\n    overflow:hidden;\n    touch-action: none;\n    > .nodes , > .lines {\n        position: absolute;\n        top: 0;\n        left: 0;\n    }\n\n    > .nodes{\n        width: 100%;\n        > .node {\n            position: absolute;\n            top: 0;\n            left: 0;\n            transform: translate3d(0, 0, 0);\n        }\n    }\n}\n}`",
    "folder": "css",
    "name": "mindmap"
  }
}