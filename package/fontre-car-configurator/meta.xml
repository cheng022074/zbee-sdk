
<classes>

    <class name="src::browser.event.init">
        <![CDATA[(() =>{
    
    
    
    
    let __once_1534494806870_value__,
        __once_1534494806870_locked__ = false;
    
    let __first_executed_1534494806870__ = false ;
    
    
    

function preventDefault(e){

    switch(e.target.tagName){

        case 'INPUT':

            return ;
    }

    e.preventDefault() ;
}

function main(target){

    target.addEventListener('touchstart' , preventDefault) ;

    target.addEventListener('touchmove' , preventDefault) ;
}
    return function(target = window){
        
        
        if(__once_1534494806870_locked__){

            return __once_1534494806870_value__ ;

        }
        
        __once_1534494806870_locked__ = true ;
        
        return  __once_1534494806870_value__ = main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double.properties.handleEvents">
        <![CDATA[(() =>{
    
    
    
    
    let __once_1534494807350_value__,
        __once_1534494807350_locked__ = false;
    
    let __first_executed_1534494807350__ = false ;
    
    
    function main(){

        

return [
    'touch:singletap',
    'touch:doubletap'
] ;
    }
    return function(){
        
        
        if(__once_1534494807350_locked__){

            return __once_1534494807350_value__ ;

        }

        __once_1534494807350_locked__ = true ;
        
        return __once_1534494807350_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::os.name">
        <![CDATA[(() =>{
    
    
    
    
    let __once_1534494806871_value__,
        __once_1534494806871_locked__ = false;
    
    let __first_executed_1534494806871__ = false ;
    
    
    function main(){

        

const NAMES = {
    iphone: 'iOS',
    android:'Android',
    mac: 'MacOS',
    win: 'Windows',
    linux: 'Linux',
    other: 'Other'
};

let userAgent = navigator.userAgent.toLowerCase(),
    name = NAMES[(userAgent.match(/mac|win|linux/) || ['other'])[0]];

switch(name){

    case 'MacOS':
    case 'Linux':

        {

            let name = NAMES[(userAgent.match(/iphone|android/) || ['other'])[0]] ;

            if(name !== 'Other'){

                return name ;
            }
        }
}

return name ;
    }
    return function(){
        
        
        if(__once_1534494806871_locked__){

            return __once_1534494806871_value__ ;

        }

        __once_1534494806871_locked__ = true ;
        
        return __once_1534494806871_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.embed.name">
        <![CDATA[(() =>{
    
    
    
    
    let __once_1534494806871_value__,
        __once_1534494806871_locked__ = false;
    
    let __first_executed_1534494806871__ = false ;
    
    
    function main(){

        

const NAMES = {
    ue4: 'UE4',
    unity:'U3D',
    other: 'Other'
};

return NAMES[(navigator.userAgent.toLowerCase().match(/ue4|unity/) || ['other'])[0]];
    }
    return function(){
        
        
        if(__once_1534494806871_locked__){

            return __once_1534494806871_value__ ;

        }

        __once_1534494806871_locked__ = true ;
        
        return __once_1534494806871_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.support.touch">
        <![CDATA[(() =>{
    let osName,getName;
    
    
    
    let __once_1534494806871_value__,
        __once_1534494806871_locked__ = false;
    
    let __first_executed_1534494806871__ = false ;
    
    
    function main(){

        

const isTouch = window.hasOwnProperty('ontouchstart');

 if(osName() === 'Windows'){

    let name = getName() ;

    return isTouch && name !== 'U3D' && name !== 'UE4';
 }

 return isTouch ;
    }
    return function(){
        
        if(!__first_executed_1534494806871__){
            osName = include('os.name');
getName = include('browser.embed.name');
            
            __first_executed_1534494806871__ = true ;
        }
        
        
        if(__once_1534494806871_locked__){

            return __once_1534494806871_value__ ;

        }

        __once_1534494806871_locked__ = true ;
        
        return __once_1534494806871_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.pointer">
        <![CDATA[(() =>{
    let isTouch;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(e,valid){

        

if(isTouch()){

    let {
        changedTouches:touches
    } = e ;

    if(valid){

        if(touches.length == 1){

            return touches[0] ;
        }
    
    }else{

        return touches[0] ;
    }
}

return e ;
    }
    return function(e,valid = false){
        
        if(!__first_executed_1534494806872__){
            isTouch = include('browser.support.touch');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e,valid) ;
    }
    

})() ;]]>
    </class>

    <class name="src::array.removeByIndex">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(data,index){

        

if(index >= 0 && index < data.length){

    data.splice(index , 1) ;

    return true ;
}

return false ;
    }
    return function(data,index){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data,index) ;
    }
    

})() ;]]>
    </class>

    <class name="src::map.event.listener">
        <![CDATA[(() =>{
    let remove;
    
    
    
    let __once_1534494806872_value__,
        __once_1534494806872_locked__ = false;
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(){

        

class Map{

    constructor(){

        let me = this ;

        me.functions = [] ;

        me.scopes = [] ;

        me.results = [] ;
    }

    indexOf(fn , scope){

        let {
            functions,
            scopes
        } = this,
        len = functions.length;

        for(let i = 0 ; i < len ; i ++){

            if(functions[i] === fn && scopes[i] === scope){

                return i ;
            }
        }

        return -1 ;
    }

    get(fn , scope){

        let 
        me = this,
        {
            functions,
            scopes,
            results
        } = me,
        index = me.indexOf(fn , scope);

        if(index !== -1){

            return results[index] ;
        }

        functions.push(fn) ;

        fn = fn.bind(scope) ;

        scopes.push(scope) ;

        results.push(fn) ;

        return fn;
    }

    remove(fn , scope){

        let 
        me = this,
        {
            functions,
            scopes,
            results
        } = me,
        index = me.indexOf(fn , scope);

        if(index !== -1){

            remove(functions , index) ;

            remove(scopes , index) ;

            remove(results , index) ;
        }
    }
}

return new Map() ;
    }
    return function(){
        
        if(!__first_executed_1534494806872__){
            remove = include('array.removeByIndex');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        if(__once_1534494806872_locked__){

            return __once_1534494806872_value__ ;

        }

        __once_1534494806872_locked__ = true ;
        
        return __once_1534494806872_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.event.listener.add">
        <![CDATA[(() =>{
    let getMap;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(target,event,fn,scope){

        

target.addEventListener(event , getMap().get(fn , scope)) ;
    }
    return function(target,event,fn,scope){
        
        if(!__first_executed_1534494806872__){
            getMap = include('map.event.listener');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,event,fn,scope) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.addWindowEventListener">
        <![CDATA[(() =>{
    let addEventListener;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(el,event,fn){

        

addEventListener(window , event , fn , el) ;
    }
    return function(el,event,fn){
        
        if(!__first_executed_1534494806872__){
            addEventListener = include('browser.html.event.listener.add');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,event,fn) ;
    }
    

})() ;]]>
    </class>

    <class name="src::math.point.distance">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(point1,point2){

        

const {
    pow,
    sqrt
} = Math ;

return sqrt(pow(point1.x - point2.x , 2) + pow(point1.y - point2.y , 2) , 2);
    }
    return function(point1,point2){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , point1,point2) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.event.listener.remove">
        <![CDATA[(() =>{
    let getMap;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(target,event,fn,scope){

        

let map = getMap() ;

target.removeEventListener(event , map.get(fn , scope)) ;

map.remove(fn , scope) ;
    }
    return function(target,event,fn,scope){
        
        if(!__first_executed_1534494806872__){
            getMap = include('map.event.listener');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,event,fn,scope) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.removeWindowEventListener">
        <![CDATA[(() =>{
    let removeEventListener;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(el,event,fn){

        

removeEventListener(window , event , fn , el) ;
    }
    return function(el,event,fn){
        
        if(!__first_executed_1534494806872__){
            removeEventListener = include('browser.html.event.listener.remove');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,event,fn) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.dispatch">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(target,name,detail){

        

target.dispatchEvent(new CustomEvent(name , {
    bubbles:false,
    detail
})) ;
    }
    return function(target,name,detail){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,name,detail) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.data.name.signature">
        <![CDATA[(() =>{
    
    
    
    
    let __once_1534494806872_value__,
        __once_1534494806872_locked__ = false;
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(){

        

return `zbee-key-${Date.now()}` ;
    }
    return function(){
        
        
        if(__once_1534494806872_locked__){

            return __once_1534494806872_value__ ;

        }

        __once_1534494806872_locked__ = true ;
        
        return __once_1534494806872_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.data.name">
        <![CDATA[(() =>{
    let signature;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(name){

        

return `${signature()}-${name}` ;
    }
    return function(name){
        
        if(!__first_executed_1534494806872__){
            signature = include('object.data.name.signature');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , name) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.data.get">
        <![CDATA[(() =>{
    let getName;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(target,name){

        

return target[getName(name)] ;
    }
    return function(target,name){
        
        if(!__first_executed_1534494806872__){
            getName = include('object.data.name');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,name) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.data.set">
        <![CDATA[(() =>{
    let getName;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(target,name,value){

        

target[getName(name)] = value ;
    }
    return function(target,name,value){
        
        if(!__first_executed_1534494806872__){
            getName = include('object.data.name');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,name,value) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.scale">
        <![CDATA[(() =>{
    let osName;
    
    
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(){

        

switch(osName){

    case 'iOS':
    case 'Android':

        return 1 ;
}

return window.devicePixelRatio ;
    }
    return function(){
        
        if(!__first_executed_1534494806873__){
            osName = include('os.name');
            
            __first_executed_1534494806873__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="config::gesture.doubletap">
        <![CDATA[{
    "moveDistance":8,
    "maxDuration": 300,
    "tapDistance": 24
} ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double.methods.onEnd">
        <![CDATA[(() =>{
    let disabled,dispatch,getEvent,getDistance,get,set,scale,configGestureDoubletap;
    let maxDuration,tapDistance;
    
    
    let __first_executed_1534494807350__ = false ;
    
    
    function main(e){

        

e.preventDefault() ;



let el = this,
    event = getEvent(e),
    time = Date.now(),
    target = event.target,
    lastTapTime = get(el , 'doubletap:lastTapTime');

set(el , 'doubletap:lastTapTime' , time) ;

set(el , 'doubletap:lastTarget' , target) ;

if(lastTapTime){

    let duration = time - lastTapTime ;

    if(duration <= maxDuration){

        let distance = Math.round(Math.abs(getDistance({
            x:event.pageX,
            y:event.pageY
        } , get(el , 'doubletap:startPoint')) * scale())) ;

        if(distance <= tapDistance){

            if(target !== get(el , 'doubletap:lastTarget')){

                disabled(el) ;

                return ;
            }

            dispatch(el , 'touch:doubletap' , {
                browserEvent:e,
                event:getEvent(e)
            }) ;

            disabled(el) ;

            return ;
        }
    }
}

if(time - get(el , 'doubletap:startTime') > maxDuration){

    dispatch(el , 'touch:singletap' , {
        browserEvent:e,
        event:getEvent(e)
    }) ;

    disabled(el) ;

}else{

    set(el , 'doubletap:singleTapTimer' , setTimeout(() =>{

        dispatch(el , 'touch:singletap' , {
            browserEvent:e,
            event:getEvent(e)
        }) ;

        disabled(el) ;

    } , maxDuration)) ;
}
    }
    return function(e){
        
        if(!__first_executed_1534494807350__){
            disabled = include('browser.event.gesture.tap.double.methods.disabled');
dispatch = include('browser.event.dispatch');
getEvent = include('browser.event.pointer');
getDistance = include('math.point.distance');
get = include('object.data.get');
set = include('object.data.set');
scale = include('browser.scale');
configGestureDoubletap = include('config::gesture.doubletap');
configGestureDoubletap = include('config::gesture.doubletap');
            maxDuration = config('gesture.doubletap' , 'maxDuration');
tapDistance = config('gesture.doubletap' , 'tapDistance');
            __first_executed_1534494807350__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.pointer.move">
        <![CDATA[(() =>{
    let isTouch;
    
    
    
    let __once_1534494806872_value__,
        __once_1534494806872_locked__ = false;
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(){

        

return isTouch() ? 'touchmove' : 'pointermove' ;
    }
    return function(){
        
        if(!__first_executed_1534494806872__){
            isTouch = include('browser.support.touch');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        if(__once_1534494806872_locked__){

            return __once_1534494806872_value__ ;

        }

        __once_1534494806872_locked__ = true ;
        
        return __once_1534494806872_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.pointer.up">
        <![CDATA[(() =>{
    let isTouch;
    
    
    
    let __once_1534494806872_value__,
        __once_1534494806872_locked__ = false;
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(){

        

return isTouch() ? 'touchend' : 'pointerup' ;
    }
    return function(){
        
        if(!__first_executed_1534494806872__){
            isTouch = include('browser.support.touch');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        if(__once_1534494806872_locked__){

            return __once_1534494806872_value__ ;

        }

        __once_1534494806872_locked__ = true ;
        
        return __once_1534494806872_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.data.remove">
        <![CDATA[(() =>{
    let getName;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(target,name){

        

delete target[getName(name)] ;
    }
    return function(target,name){
        
        if(!__first_executed_1534494806872__){
            getName = include('object.data.name');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,name) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double.methods.disabled">
        <![CDATA[(() =>{
    let removeEventListener,onMove,onEnd,getMoveEventName,getUpEventName,get,remove;
    
    
    
    let __first_executed_1534494807350__ = false ;
    
    
    function main(el){

        

removeEventListener(el , getMoveEventName() , onMove) ;

removeEventListener(el , getUpEventName() , onEnd) ;

clearTimeout(get(el , 'doubletap:singleTapTimer')) ;

remove(el , 'doubletap:singleTapTimer') ;

remove(el , 'doubletap:startTime') ;

remove(el , 'doubletap:lastTapTime') ;

remove(el , 'doubletap:lastStartPoint') ;

remove(el , 'doubletap:startPoint') ;

remove(el , 'doubletap:singleTapTimer') ;
    }
    return function(el){
        
        if(!__first_executed_1534494807350__){
            removeEventListener = include('browser.html.element.removeWindowEventListener');
onMove = include('browser.event.gesture.tap.double.methods.onMove');
onEnd = include('browser.event.gesture.tap.double.methods.onEnd');
getMoveEventName = include('browser.event.pointer.move');
getUpEventName = include('browser.event.pointer.up');
get = include('object.data.get');
remove = include('object.data.remove');
            
            __first_executed_1534494807350__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double.methods.onMove">
        <![CDATA[(() =>{
    let getEvent,getDistance,disabled,scale,get,configGestureDoubletap;
    let moveDistance;
    
    
    let __first_executed_1534494807350__ = false ;
    
    
    function main(e){

        

e.preventDefault() ;

let el = this,
    event = getEvent(e);

if(Math.round(Math.abs(getDistance({
    x:event.pageX,
    y:event.pageY
} , get(el , 'doubletap:lastStartPoint')) * scale())) >= moveDistance){
    
    disabled(el) ;
}
    }
    return function(e){
        
        if(!__first_executed_1534494807350__){
            getEvent = include('browser.event.pointer');
getDistance = include('math.point.distance');
disabled = include('browser.event.gesture.tap.double.methods.disabled');
scale = include('browser.scale');
get = include('object.data.get');
configGestureDoubletap = include('config::gesture.doubletap');
            moveDistance = config('gesture.doubletap' , 'moveDistance');
            __first_executed_1534494807350__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double.methods.enabled">
        <![CDATA[(() =>{
    let addEventListener,onMove,onEnd,getMoveEventName,getUpEventName;
    
    
    
    let __first_executed_1534494807350__ = false ;
    
    
    function main(el){

        

addEventListener(el , getMoveEventName() , onMove) ;

addEventListener(el , getUpEventName() , onEnd) ;
    }
    return function(el){
        
        if(!__first_executed_1534494807350__){
            addEventListener = include('browser.html.element.addWindowEventListener');
onMove = include('browser.event.gesture.tap.double.methods.onMove');
onEnd = include('browser.event.gesture.tap.double.methods.onEnd');
getMoveEventName = include('browser.event.pointer.move');
getUpEventName = include('browser.event.pointer.up');
            
            __first_executed_1534494807350__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.data.has">
        <![CDATA[(() =>{
    let getName;
    
    
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(target,name){

        

return target.hasOwnProperty(getName(name)) ;
    }
    return function(target,name){
        
        if(!__first_executed_1534494806873__){
            getName = include('object.data.name');
            
            __first_executed_1534494806873__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,name) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double.methods.onStart">
        <![CDATA[(() =>{
    let getEvent,enabled,set,get,has;
    
    
    
    let __first_executed_1534494807350__ = false ;
    
    
    function main(e){

        

e.preventDefault() ;

let event = getEvent(e , true) ;

if(!event){

    return ;
}

let el = this,
    point = {
        x:event.pageX,
        y:event.pageY
    };

set(el , 'doubletap:lastStartPoint' , point) ;

if(!has(el , 'doubletap:startPoint')){

    set(el , 'doubletap:startPoint' , point) ;
}

set(el , 'doubletap:startTime' , Date.now()) ;

clearTimeout(get(el , 'doubletap:singleTapTimer')) ;

enabled(el) ;
    }
    return function(e){
        
        if(!__first_executed_1534494807350__){
            getEvent = include('browser.event.pointer');
enabled = include('browser.event.gesture.tap.double.methods.enabled');
set = include('object.data.set');
get = include('object.data.get');
has = include('object.data.has');
            
            __first_executed_1534494807350__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.pointer.down">
        <![CDATA[(() =>{
    let isTouch;
    
    
    
    let __once_1534494806873_value__,
        __once_1534494806873_locked__ = false;
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(){

        

return isTouch() ? 'touchstart' : 'pointerdown' ;
    }
    return function(){
        
        if(!__first_executed_1534494806873__){
            isTouch = include('browser.support.touch');
            
            __first_executed_1534494806873__ = true ;
        }
        
        
        if(__once_1534494806873_locked__){

            return __once_1534494806873_value__ ;

        }

        __once_1534494806873_locked__ = true ;
        
        return __once_1534494806873_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double.methods.install">
        <![CDATA[(() =>{
    let onStart,getEventName;
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(el){

        

el.addEventListener(getEventName() , onStart) ;
    }
    return function(el){
        
        if(!__first_executed_1534494807351__){
            onStart = include('browser.event.gesture.tap.double.methods.onStart');
getEventName = include('browser.event.pointer.down');
            
            __first_executed_1534494807351__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double.methods.uninstall">
        <![CDATA[(() =>{
    let onStart,getEventName;
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(el){

        

el.removeEventListener(getEventName() , onStart) ;
    }
    return function(el){
        
        if(!__first_executed_1534494807351__){
            onStart = include('browser.event.gesture.tap.double.methods.onStart');
getEventName = include('browser.event.pointer.down');
            
            __first_executed_1534494807351__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.double">
        <![CDATA[(() =>{

    
        class Main{
            static  get handledEvents (){
                    return include('browser.event.gesture.tap.double.properties.handleEvents').call(this) ;
                }
static install(){
                    return include('browser.event.gesture.tap.double.methods.install').apply(this , arguments) ;
                }static uninstall(){
                    return include('browser.event.gesture.tap.double.methods.uninstall').apply(this , arguments) ;
                }
        };
        

    return Main ;

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.properties.handleEvents">
        <![CDATA[(() =>{
    
    
    
    
    let __once_1534494806871_value__,
        __once_1534494806871_locked__ = false;
    
    let __first_executed_1534494806871__ = false ;
    
    
    function main(){

        

return [
    'touch:beforetap',
    'touch:tap',
    'touch:tapcancel'
] ;
    }
    return function(){
        
        
        if(__once_1534494806871_locked__){

            return __once_1534494806871_value__ ;

        }

        __once_1534494806871_locked__ = true ;
        
        return __once_1534494806871_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.methods.onEnd">
        <![CDATA[(() =>{
    let disabled,dispatch,getEvent,get,set;
    
    
    
    let __first_executed_1534494806872__ = false ;
    
    
    function main(e){

        

e.preventDefault() ;

let el = this,
    event = getEvent(e),
    defer = get(el , 'tap:defer');

dispatch(el , 'touch:beforetap' , {
    browserEvent:e,
    event:getEvent(e)
}) ;

if(defer){

    set(el , 'tap:deferTimer' , setTimeout(() =>{

        dispatch(el , 'touch:tap' , {
            browserEvent:e,
            event:getEvent(e)
        }) ;
        
        disabled(el) ;

    } , defer)) ;
    
}else{

    dispatch(el , 'touch:tap' , {
        browserEvent:e,
        event:getEvent(e)
    }) ;
    
    disabled(el) ;
}
    }
    return function(e){
        
        if(!__first_executed_1534494806872__){
            disabled = include('browser.event.gesture.tap.methods.disabled');
dispatch = include('browser.event.dispatch');
getEvent = include('browser.event.pointer');
get = include('object.data.get');
set = include('object.data.set');
            
            __first_executed_1534494806872__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.methods.disabled">
        <![CDATA[(() =>{
    let removeEventListener,onMove,onEnd,getMoveEventName,getUpEventName,get,remove,tap;
    
    
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(el){

        

removeEventListener(el , getMoveEventName() , onMove) ;

removeEventListener(el , getUpEventName() , onEnd) ;

clearTimeout(get(el , 'tap:deferTimer')) ;

remove(el , 'tap:deferTimer') ;

remove(el , 'tap:startPoint') ;

tap.locked = false ;
    }
    return function(el){
        
        if(!__first_executed_1534494806873__){
            removeEventListener = include('browser.html.element.removeWindowEventListener');
onMove = include('browser.event.gesture.tap.methods.onMove');
onEnd = include('browser.event.gesture.tap.methods.onEnd');
getMoveEventName = include('browser.event.pointer.move');
getUpEventName = include('browser.event.pointer.up');
get = include('object.data.get');
remove = include('object.data.remove');
tap = include('browser.event.gesture.tap');
            
            __first_executed_1534494806873__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="config::gesture.tap">
        <![CDATA[{
    "timeout":100,
    "moveDistance":100
} ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.methods.onMove">
        <![CDATA[(() =>{
    let getEvent,getDistance,disabled,scale,get,dispatch,configGestureTap;
    let moveDistance;
    
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(e){

        

e.preventDefault() ;

let el = this,
    event = getEvent(e);

if(Math.round(Math.abs(getDistance({
    x:event.pageX,
    y:event.pageY
} , get(el , 'tap:startPoint')) * scale())) >= moveDistance){

    dispatch(el , 'touch:tapcancel' , {
        browserEvent:e,
        event
    }) ;
    
    disabled(el) ;
}
    }
    return function(e){
        
        if(!__first_executed_1534494806873__){
            getEvent = include('browser.event.pointer');
getDistance = include('math.point.distance');
disabled = include('browser.event.gesture.tap.methods.disabled');
scale = include('browser.scale');
get = include('object.data.get');
dispatch = include('browser.event.dispatch');
configGestureTap = include('config::gesture.tap');
            moveDistance = config('gesture.tap' , 'moveDistance');
            __first_executed_1534494806873__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.methods.enabled">
        <![CDATA[(() =>{
    let addEventListener,onMove,onEnd,getMoveEventName,getUpEventName;
    
    
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(el){

        

addEventListener(el , getMoveEventName() , onMove) ;

addEventListener(el , getUpEventName() , onEnd) ;
    }
    return function(el){
        
        if(!__first_executed_1534494806873__){
            addEventListener = include('browser.html.element.addWindowEventListener');
onMove = include('browser.event.gesture.tap.methods.onMove');
onEnd = include('browser.event.gesture.tap.methods.onEnd');
getMoveEventName = include('browser.event.pointer.move');
getUpEventName = include('browser.event.pointer.up');
            
            __first_executed_1534494806873__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.methods.onStart">
        <![CDATA[(() =>{
    let getEvent,enabled,set,get,has,tap,configGestureTap;
    let timeout;
    
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(e){

        

let {
    locked,
    time
} = tap ;

if(locked === true){

    return ;
}

let currentTime = Date.now() ;

if(time && currentTime - time <= timeout){

    return ;
}

tap.time = currentTime ;

tap.locked = true ;

e.preventDefault() ;

let event = getEvent(e , true);

if(!event){

    return ;
}

let el = this ;

set(el , 'tap:startPoint' , {
    x:event.pageX,
    y:event.pageY
}) ;

if(has(el , 'tap:defer')){

    clearTimeout(get(el , 'tap:deferTimer')) ;
}

enabled(el) ;
    }
    return function(e){
        
        if(!__first_executed_1534494806873__){
            getEvent = include('browser.event.pointer');
enabled = include('browser.event.gesture.tap.methods.enabled');
set = include('object.data.set');
get = include('object.data.get');
has = include('object.data.has');
tap = include('browser.event.gesture.tap');
configGestureTap = include('config::gesture.tap');
            timeout = config('gesture.tap' , 'timeout');
            __first_executed_1534494806873__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.methods.install">
        <![CDATA[(() =>{
    let onStart,getEventName,set;
    
    
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(el,config){

        

if(config){

    let {
        defer
    } = config ;

    if(defer){

        set(el , 'tap:defer' , defer) ;
    }
}

el.addEventListener(getEventName() , onStart) ;
    }
    return function(el,config){
        
        if(!__first_executed_1534494806873__){
            onStart = include('browser.event.gesture.tap.methods.onStart');
getEventName = include('browser.event.pointer.down');
set = include('object.data.set');
            
            __first_executed_1534494806873__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,config) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap.methods.uninstall">
        <![CDATA[(() =>{
    let onStart,getEventName;
    
    
    
    let __first_executed_1534494806873__ = false ;
    
    
    function main(el){

        

el.removeEventListener(getEventName() , onStart) ;
    }
    return function(el){
        
        if(!__first_executed_1534494806873__){
            onStart = include('browser.event.gesture.tap.methods.onStart');
getEventName = include('browser.event.pointer.down');
            
            __first_executed_1534494806873__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.tap">
        <![CDATA[(() =>{

    
        class Main{
            static  get handledEvents (){
                    return include('browser.event.gesture.tap.properties.handleEvents').call(this) ;
                }
static install(){
                    return include('browser.event.gesture.tap.methods.install').apply(this , arguments) ;
                }static uninstall(){
                    return include('browser.event.gesture.tap.methods.uninstall').apply(this , arguments) ;
                }
        };
        

    return Main ;

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.properties.handleEvents">
        <![CDATA[(() =>{
    
    
    
    
    let __once_1534494806875_value__,
        __once_1534494806875_locked__ = false;
    
    let __first_executed_1534494806875__ = false ;
    
    
    function main(){

        

return [
    'touch:dragstart',
    'touch:drag',
    'touch:dragend'
] ;
    }
    return function(){
        
        
        if(__once_1534494806875_locked__){

            return __once_1534494806875_value__ ;

        }

        __once_1534494806875_locked__ = true ;
        
        return __once_1534494806875_value__ =  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) ) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.resetInfo">
        <![CDATA[(() =>{
    let get;
    
    
    
    let __first_executed_1534494806875__ = false ;
    
    
    function main(el,axis){

        

let info = get(el , 'drag:info'),
    value = get(el , 'drag:lastPoint')[axis],
    startPoint = get(el , 'drag:startPoint'),
    startValue = startPoint[axis],
    delta = value - startValue,
    capAxis = axis.toUpperCase(),
    startTime = get(el , 'drag:startTime');

    info.delta[axis] = delta;
    info.absDelta[axis] = Math.abs(delta);

    info.previousTime[axis] = startTime;
    info.previous[axis] = startValue;
    info[axis] = value;
    info.direction[axis] = 0;

    info['start' + capAxis] = startPoint[axis];
    info['previous' + capAxis] = info.previous[axis];
    info['page' + capAxis] = info[axis];
    info['delta' + capAxis] = info.delta[axis];
    info['absDelta' + capAxis] = info.absDelta[axis];
    info['previousDelta' + capAxis] = 0;
    info.startTime = startTime;
    }
    return function(el,axis){
        
        if(!__first_executed_1534494806875__){
            get = include('object.data.get');
            
            __first_executed_1534494806875__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,axis) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.updateInfo">
        <![CDATA[(() =>{
    let get;
    
    
    
    let __first_executed_1534494806875__ = false ;
    
    
    function main(el,axis,updatePrevious){

        

 
let info = get(el , 'drag:info'),
    time = Date.now(),
    value = get(el , 'drag:lastPoint')[axis],
    previousValue = get(el , 'drag:previousPoint')[axis],
    startPoint = get(el , 'drag:startPoint'),
    startValue = startPoint[axis],
    delta = value - startValue,
    direction = info.direction,
    capAxis = axis.toUpperCase(),
    previousFlick = info.previous[axis],
    previousDelta;

    previousDelta = info.delta[axis];
    info.delta[axis] = delta;
    info.absDelta[axis] = Math.abs(delta);

    if (updatePrevious && value !== previousFlick && value !== info[axis] && time - info.previousTime[axis] >= 50) {

        info.previous[axis] = info[axis];
        
        info.previousTime[axis] = info.time;
    }

    info[axis] = value;

    if (value > previousValue) {

        direction[axis] = 1;
    }
    else if (value < previousValue) {

        direction[axis] = -1;
    }

    info['start' + capAxis] = startPoint[axis];
    info['previous' + capAxis] = info.previous[axis];
    info['page' + capAxis] = info[axis];
    info['delta' + capAxis] = info.delta[axis];
    info['absDelta' + capAxis] = info.absDelta[axis];
    info['previousDelta' + capAxis] = previousDelta;
    info.startTime = get(el , 'drag:startTime');
    }
    return function(el,axis,updatePrevious){
        
        if(!__first_executed_1534494806875__){
            get = include('object.data.get');
            
            __first_executed_1534494806875__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,axis,updatePrevious) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.onDragMove">
        <![CDATA[(() =>{
    let get,set,has,updateInfo,getEvent,dispatch;
    
    
    
    let __first_executed_1534494806875__ = false ;
    
    
    function main(e){

        

e.preventDefault() ;

let event = getEvent(e),
    el = this ;

if(has(el , 'drag:lastPoint')){

    set(el , 'drag:previousPoint' , get(el , 'drag:lastPoint')) ;
}

set(el , 'drag:lastPoint' , {
    x:event.pageX,
    y:event.pageY
}) ;

updateInfo(el , 'x' , true);

updateInfo(el , 'y' , true);

let info = get(el , 'drag:info') ;

info.time = Date.now();

dispatch(el , 'touch:drag' , {
    event,
    browserEvent:e,
    info
}) ;
    }
    return function(e){
        
        if(!__first_executed_1534494806875__){
            get = include('object.data.get');
set = include('object.data.set');
has = include('object.data.has');
updateInfo = include('browser.event.gesture.drag.methods.updateInfo');
getEvent = include('browser.event.pointer');
dispatch = include('browser.event.dispatch');
            
            __first_executed_1534494806875__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.onAxisDragEnd">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806875__ = false ;
    
    
    function main(axis,info){

        

let duration = info.time - info.previousTime[axis];

if (duration > 0) {

    info.flick.velocity[axis] = (info[axis] - info.previous[axis]) / duration;
}
    }
    return function(axis,info){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , axis,info) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.onEnd">
        <![CDATA[(() =>{
    let get,set,remove,getEvent,updateInfo,onAxisDragEnd,getMoveEventName,getEndEventName,onDragMove,onEnd,dispatch,removeEventListener;
    
    
    
    let __first_executed_1534494806875__ = false ;
    
    
    function main(e){

        

e.preventDefault() ;

let el = this,
    event = getEvent(e),
    info = get(el , 'drag:info');

set(el , 'drag:lastPoint' , {
    x:event.pageX,
    y:event.pageY
}) ;

updateInfo(el , 'x');

updateInfo(el , 'y');

info.time = Date.now();

onAxisDragEnd('x', info);

onAxisDragEnd('y', info);

dispatch(el , 'touch:dragend', {
    event,
    browserEvent:e,
    info
});

removeEventListener(el , getMoveEventName() , onDragMove),
removeEventListener(el , getEndEventName() , onEnd) ;

remove(el , 'drag:info') ;

remove(el , 'drag:lastPoint') ;

remove(el , 'drag:previousPoint') ;

remove(el , 'drag:startTime') ;

remove(el , 'drag:startPoint') ;
    }
    return function(e){
        
        if(!__first_executed_1534494806875__){
            get = include('object.data.get');
set = include('object.data.set');
remove = include('object.data.remove');
getEvent = include('browser.event.pointer');
updateInfo = include('browser.event.gesture.drag.methods.updateInfo');
onAxisDragEnd = include('browser.event.gesture.drag.methods.onAxisDragEnd');
getMoveEventName = include('browser.event.pointer.move');
getEndEventName = include('browser.event.pointer.up');
onDragMove = include('browser.event.gesture.drag.methods.onDragMove');
onEnd = include('browser.event.gesture.drag.methods.onEnd');
dispatch = include('browser.event.dispatch');
removeEventListener = include('browser.html.element.removeWindowEventListener');
            
            __first_executed_1534494806875__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="config::gesture.drag">
        <![CDATA[{
    "minDistance":8
} ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.onMove">
        <![CDATA[(() =>{
    let set,get,getEvent,scale,resetInfo,getMoveEventName,getEndEventName,addEventListener,removeEventListener,onMove,onDragMove,onEnd,distance,dispatch,configGestureDrag;
    let minDistance;
    
    
    let __first_executed_1534494806875__ = false ;
    
    
    function main(e){

        


e.preventDefault() ;

let event = getEvent(e , true),
    el = this,
    info = get(el , 'drag:info'),
    point = {
        x:event.pageX,
        y:event.pageY
    };

if (Math.round(distance(get(el , 'drag:startPoint') , point) * scale()) >= minDistance) {

    set(el , 'drag:previousPoint' , point) ;

    set(el , 'drag:lastPoint' , point) ;

    resetInfo(el , 'x');
    
    resetInfo(el , 'y');

    info.time = Date.now();

    dispatch(el , 'touch:dragstart', {
        browserEvent:e,
        event,
        info
    });

    let moveEventName = getMoveEventName() ;

    removeEventListener(el , moveEventName , onMove) ;

    addEventListener(el , moveEventName , onDragMove) ;

    addEventListener(el , getEndEventName() , onEnd);
}
    }
    return function(e){
        
        if(!__first_executed_1534494806875__){
            set = include('object.data.set');
get = include('object.data.get');
getEvent = include('browser.event.pointer');
scale = include('browser.scale');
resetInfo = include('browser.event.gesture.drag.methods.resetInfo');
getMoveEventName = include('browser.event.pointer.move');
getEndEventName = include('browser.event.pointer.up');
addEventListener = include('browser.html.element.addWindowEventListener');
removeEventListener = include('browser.html.element.removeWindowEventListener');
onMove = include('browser.event.gesture.drag.methods.onMove');
onDragMove = include('browser.event.gesture.drag.methods.onDragMove');
onEnd = include('browser.event.gesture.drag.methods.onEnd');
distance = include('math.point.distance');
dispatch = include('browser.event.dispatch');
configGestureDrag = include('config::gesture.drag');
            minDistance = config('gesture.drag' , 'minDistance');
            __first_executed_1534494806875__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.onStart">
        <![CDATA[(() =>{
    let set,getEvent,addEventListener,onMove,getEventName;
    
    
    
    let __first_executed_1534494806876__ = false ;
    
    
    function main(e){

        

e.preventDefault() ;

let event = getEvent(e , true);

if(!event){

    return ;
}

let el = this ;

set(el, 'drag:info', {
    previous: {
        x: 0,
        y: 0
    },
    x: 0,
    y: 0,
    delta: {
        x: 0,
        y: 0
    },
    absDelta: {
        x: 0,
        y: 0
    },
    flick: {
        velocity: {
            x: 0,
            y: 0
        }
    },
    direction: {
        x: 0,
        y: 0
    },
    time: 0,
    previousTime: {
        x: 0,
        y: 0
    }
}),
set(el , 'drag:startTime' , Date.now()),
set(el , 'drag:startPoint' , {
    x:event.pageX,
    y:event.pageY
});

addEventListener(el , getEventName() , onMove) ;
    }
    return function(e){
        
        if(!__first_executed_1534494806876__){
            set = include('object.data.set');
getEvent = include('browser.event.pointer');
addEventListener = include('browser.html.element.addWindowEventListener');
onMove = include('browser.event.gesture.drag.methods.onMove');
getEventName = include('browser.event.pointer.move');
            
            __first_executed_1534494806876__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , e) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.install">
        <![CDATA[(() =>{
    let onStart,getEventName;
    
    
    
    let __first_executed_1534494806876__ = false ;
    
    
    function main(el){

        

el.addEventListener(getEventName() , onStart) ;
    }
    return function(el){
        
        if(!__first_executed_1534494806876__){
            onStart = include('browser.event.gesture.drag.methods.onStart');
getEventName = include('browser.event.pointer.down');
            
            __first_executed_1534494806876__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag.methods.uninstall">
        <![CDATA[(() =>{
    let onStart,getEventName;
    
    
    
    let __first_executed_1534494806876__ = false ;
    
    
    function main(el){

        

el.removeEventListener(getEventName() , onStart) ;
    }
    return function(el){
        
        if(!__first_executed_1534494806876__){
            onStart = include('browser.event.gesture.drag.methods.onStart');
getEventName = include('browser.event.pointer.down');
            
            __first_executed_1534494806876__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.event.gesture.drag">
        <![CDATA[(() =>{

    
        class Main{
            static  get handledEvents (){
                    return include('browser.event.gesture.drag.properties.handleEvents').call(this) ;
                }
static install(){
                    return include('browser.event.gesture.drag.methods.install').apply(this , arguments) ;
                }static uninstall(){
                    return include('browser.event.gesture.drag.methods.uninstall').apply(this , arguments) ;
                }
        };
        

    return Main ;

})() ;]]>
    </class>

    <class name="src::is.type">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806870__ = false ;
    
    
    function main(data,type){

        

 return typeof data === type ;
    }
    return function(data,type){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data,type) ;
    }
    

})() ;]]>
    </class>

    <class name="src::is.function">
        <![CDATA[(() =>{
    let isType;
    
    
    
    let __first_executed_1534494806871__ = false ;
    
    
    function main(data){

        

return isType(data , 'function') ;
    }
    return function(data){
        
        if(!__first_executed_1534494806871__){
            isType = include('is.type');
            
            __first_executed_1534494806871__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::is.string">
        <![CDATA[(() =>{
    let isType;
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    function main(data){

        

return isType(data , 'string') ;
    }
    return function(data){
        
        if(!__first_executed_1534494806877__){
            isType = include('is.type');
            
            __first_executed_1534494806877__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::is.object.simple">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806871__ = false ;
    
    
    function main(data){

        

return data instanceof Object && data.constructor === Object;
    }
    return function(data){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.getXY">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(el){

        

const 
{
    round
} = Math ;

let 
x = 0,
y = 0,
{
    body
} = document;

if(el !== document && el !== body){
   
    try{

        let bodyRect = body.getBoundingClientRect(),
            rect = el.getBoundingClientRect();

        x = rect.left - bodyRect.left;
        y = rect.top - bodyRect.top;
    
    }catch(ex){

    }
}

return {
    x:round(x), 
    y:round(y)
};
    }
    return function(el){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::is.array">
        <![CDATA[(() =>{
    let isType;
    
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    function main(data){

        

 return Array.isArray(data) ;
    }
    return function(data){
        
        if(!__first_executed_1534494806878__){
            isType = include('is.type');
            
            __first_executed_1534494806878__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.getStyle">
        <![CDATA[(() =>{
    let isArray,getStyle;
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(el,prop,inline){

        

if(isArray(prop)){

    let values = {},
        props = prop;
    
    for(let prop of props){

        values[prop] = getStyle(el , prop , inline) ;
    }

    return values ;

}

if(inline){

    return el.style.getPropertyValue(prop);

}else{

    style = window.getComputedStyle(el , null);

    if(style){

        return style[prop] ;

    }else{

        return getStyle(el , prop , true) ;
    }
}
    }
    return function(el,prop,inline = false){
        
        if(!__first_executed_1534494807351__){
            isArray = include('is.array');
getStyle = include('browser.html.element.getStyle');
            
            __first_executed_1534494807351__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,prop,inline) ;
    }
    

})() ;]]>
    </class>

    <class name="src::is.number">
        <![CDATA[(() =>{
    let isType;
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(data){

        

return isType(data , 'number') && isFinite(data);
    }
    return function(data){
        
        if(!__first_executed_1534494807351__){
            isType = include('is.type');
            
            __first_executed_1534494807351__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.translateXY">
        <![CDATA[(() =>{
    let getStyle,getXY,isNumber;
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(el,x,y){

        

let 
{
    position,
    left,
    top
} = getStyle(el , [
        'position',
        'top',
        'left'
    ]),
isRelative = position === 'relative',
{
    x:orignX,
    y:orginY
} = getXY(el);

left = parseFloat(left) ;

top = parseFloat(top) ;
 
if(isNaN(left)){
    
    left = isRelative ? 0 : el.offsetLeft;
}

if(isNaN(top)){

    top = isRelative ? 0 : el.offsetTop;
}

return {
    x: x - orignX + left,
    y: y - orginY + top
};
    }
    return function(el,x,y){
        
        if(!__first_executed_1534494807351__){
            getStyle = include('browser.html.element.getStyle');
getXY = include('browser.html.element.getXY');
isNumber = include('is.number');
            
            __first_executed_1534494807351__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,x,y) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.translatePoints">
        <![CDATA[(() =>{
    let translateXY;
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(el,x,y){

        

let {
    x:left,
    y:top
} = translateXY(el , x , y) ;

return {
    left,
    top
} ;
    }
    return function(el,x,y){
        
        if(!__first_executed_1534494807351__){
            translateXY = include('browser.html.element.translateXY');
            
            __first_executed_1534494807351__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,x,y) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.isStyle">
        <![CDATA[(() =>{
    let getStyle;
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(el,prop,value){

        

return getStyle(el , prop) === value ;
    }
    return function(el,prop,value){
        
        if(!__first_executed_1534494807351__){
            getStyle = include('browser.html.element.getStyle');
            
            __first_executed_1534494807351__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,prop,value) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.setStyle">
        <![CDATA[(() =>{
    let isString,setStyle;
    
    
    
    let __first_executed_1534494807351__ = false ;
    
    
    function main(el,prop,value){

        

if(isString(prop)){

    el.style.setProperty(prop , value) ;

}else{

    let names = Object.keys(prop) ;

    for(let name of names){

        setStyle(el , name , prop[name]) ;
    }
}
    }
    return function(el,prop,value){
        
        if(!__first_executed_1534494807351__){
            isString = include('is.string');
setStyle = include('browser.html.element.setStyle');
            
            __first_executed_1534494807351__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,prop,value) ;
    }
    

})() ;]]>
    </class>

    <class name="src::is.defined">
        <![CDATA[(() =>{
    let isType;
    
    
    
    let __first_executed_1534494807139__ = false ;
    
    
    function main(data){

        

return !isType(data , 'undefined') ;
    }
    return function(data){
        
        if(!__first_executed_1534494807139__){
            isType = include('is.type');
            
            __first_executed_1534494807139__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.position">
        <![CDATA[(() =>{
    let isStyle,setStyle,isDefined,setXY;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(el,pos,zIndex,x,y){

        

if(el !== document && el !== document.body){

    if(!pos && isStyle(el , 'position' , 'static')){
    
        setStyle(el , 'position' , 'relative') ;
    
    }else if(pos){

        setStyle(el , 'position' , pos) ;
    }

    if(isDefined(zIndex)){

        setStyle(el , 'zindex' , zIndex) ;
    }

    if(x || y){

        setXY(el , x || false , y || false) ;
    }
}
    }
    return function(el,pos,zIndex,x,y){
        
        if(!__first_executed_1534494807352__){
            isStyle = include('browser.html.element.isStyle');
setStyle = include('browser.html.element.setStyle');
isDefined = include('is.defined');
setXY = include('browser.html.element.setXY');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,pos,zIndex,x,y) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.setXY">
        <![CDATA[(() =>{
    let translatePoints,position;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(el,x,y){

        

let 
{
    top,
    left
} = translatePoints(el , x , y),
{
    style
} = el,
pos;

position(el) ;

style.top = `${top}px` ;

style.left = `${left}px` ;
    }
    return function(el,x,y){
        
        if(!__first_executed_1534494807352__){
            translatePoints = include('browser.html.element.translatePoints');
position = include('browser.html.element.position');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,x,y) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.style.set">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    function main(el,prop,value){

        

el.style.setProperty(prop , value) ;
    }
    return function(el,prop,value){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,prop,value) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.style.get">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(el,prop){

        

let cs = window.getComputedStyle(el , '') ;

if(cs){

   return cs[prop] ;
}
    }
    return function(el,prop){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el,prop) ;
    }
    

})() ;]]>
    </class>

    <class name="src::is.empty">
        <![CDATA[(() =>{
    let isArray;
    
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    function main(data,allowEmptyString){

        

return (data == null) || (!allowEmptyString ? data === '' : false) || (isArray(data) && data.length === 0);
    }
    return function(data,allowEmptyString = false){
        
        if(!__first_executed_1534494806878__){
            isArray = include('is.array');
            
            __first_executed_1534494806878__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data,allowEmptyString) ;
    }
    

})() ;]]>
    </class>

    <class name="src::array.from">
        <![CDATA[(() =>{
    let isEmpty,isString;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(data){

        

if(isEmpty(data)){

    return [];
}

if (data && data.length !== undefined && !isString(data)) {

    return Array.from(data);

}

return [
    data
];
    }
    return function(data){
        
        if(!__first_executed_1534494807352__){
            isEmpty = include('is.empty');
isString = include('is.string');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::vue.slot.children">
        <![CDATA[(() =>{
    let from;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(vue){

        

let children = from(vue.$slots.default),
    result = [];

for(let node of children){

    if(node.tag){

        result.push(node) ;
    }
}

return result ;
    }
    return function(vue){
        
        if(!__first_executed_1534494807352__){
            from = include('array.from');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , vue) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.get">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    

const splitRe = /\./;

function main(data , key){

    if(key){
    
        if(key in data){
    
            return data[key] ;
        }
    
        let names = key.split(splitRe),
            prefix = '';
    
        for(let name of names){
    
            let key = `${prefix}${name}` ;

            if(!data){

                break ;
            }
    
            if(key in data){
    
                data = data[key] ;
    
                prefix = '' ;
            
            }else{
    
                prefix = `${key}.` ;
            }
        }
    
        if(prefix){
    
            return ;
        }
    
        return data ;
    }
    
    return data ;

}
    return function(data,key){
        
        
        return main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data,key) ;
    }
    

})() ;]]>
    </class>

    <class name="src::string.split">
        <![CDATA[(() =>{
    let isEmpty;
    
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    

function main(target , splitRe){

    return target.split(splitRe).filter(filter) ;
 }

 function filter(target){

    return !isEmpty(target) ;
 }
    return function(target,splitRe){
        
        if(!__first_executed_1534494806878__){
            isEmpty = include('is.empty');
            
            __first_executed_1534494806878__ = true ;
        }
        
        
        return main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,splitRe) ;
    }
    

})() ;]]>
    </class>

    <class name="src::vue.createElement.config">
        <![CDATA[(() =>{
    let get,split;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(node,property,isSelf){

        

let attrs = get(node , 'data.attrs') || {};

if(attrs.hasOwnProperty(property)){

   let config = attrs[property],
       keys = Object.keys(config),
       classes = {},
       props = {};

   for(let key of keys){

       switch(key){

           case 'class':

               let values = split(config[key] , /\s/) ;

               for(let value of values){

                   classes[value] = true ;
               }

               break ;

           case 'self':

               isSelf = config[key] ;

               break ;

           default:

               props[key] = config[key] ;
       }
   }

   delete attrs[property] ;

   return {
       isSelf,
       config:{
           'class':classes,
           props
       }
   } ;
}

return {
   isSelf,
   config:{}
} ;
    }
    return function(node,property,isSelf = false){
        
        if(!__first_executed_1534494807352__){
            get = include('object.get');
split = include('string.split');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , node,property,isSelf) ;
    }
    

})() ;]]>
    </class>

    <class name="src::is.object">
        <![CDATA[(() =>{
    let isType;
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    function main(data){

        

return Object.prototype.toString.call(data) === '[object Object]' ;
    }
    return function(data){
        
        if(!__first_executed_1534494806877__){
            isType = include('is.type');
            
            __first_executed_1534494806877__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.set">
        <![CDATA[(() =>{
    let isObject,split;
    
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    

const splitRe = /\./;

function main(target , key , value){

    if(splitRe.test(key)){

        let keys = split(key , splitRe) ;
    
        key = keys.pop();
    
        for(let key of keys){
    
            let data = target[key] ;
    
            if(!isObject(data)){
    
                data = target[key] = {} ;
            }
    
            target = data ;
        }
    
        target[key] = value ;
    
    }else{
    
        target[key] = value ;
    }
}
    return function(target,key,value){
        
        if(!__first_executed_1534494806878__){
            isObject = include('is.object');
split = include('string.split');
            
            __first_executed_1534494806878__ = true ;
        }
        
        
        return main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , target,key,value) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.getWidth">
        <![CDATA[(() =>{
    let isStyle;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(el){

        

if(isStyle(el , 'display' , 'none')){

    return 0 ;
}

try{

    let {
        left,
        right
    } = el.getBoundingClientRect() ;

    return right - left ;

}catch(err){


}

return el.offsetWidth ;
    }
    return function(el){
        
        if(!__first_executed_1534494807352__){
            isStyle = include('browser.html.element.isStyle');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.getHeight">
        <![CDATA[(() =>{
    let isStyle;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(el){

        


if(isStyle(el , 'display' , 'none')){

    return 0 ;
}

if(el === document.body){

    return document.body.clientHeight ;
}

try{

    let {
        top,
        bottom
    } = el.getBoundingClientRect() ;

    return top - bottom ;

}catch(err){


}

return el.offsetHeight ;
    }
    return function(el){
        
        if(!__first_executed_1534494807352__){
            isStyle = include('browser.html.element.isStyle');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.getSize">
        <![CDATA[(() =>{
    let getWidth,getHeight;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(el){

        

return{
    width:getWidth(el),
    height:getHeight(el)
} ;
    }
    return function(el){
        
        if(!__first_executed_1534494807352__){
            getWidth = include('browser.html.element.getWidth');
getHeight = include('browser.html.element.getHeight');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::browser.html.element.box.page">
        <![CDATA[(() =>{
    let getXY,getSize;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(el){

        

let {
    x,
    y
} = getXY(el),
{
    width,
    height
} = getSize(el);


return {
    width,
    height,
    left:x,
    top:y,
    right:x + width,
    bottom:y + height
} ;
    }
    return function(el){
        
        if(!__first_executed_1534494807352__){
            getXY = include('browser.html.element.getXY');
getSize = include('browser.html.element.getSize');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , el) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.keys">
        <![CDATA[(() =>{
    let isObject;
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    

function main(data){

    return get_keys(data) ;
}

function get_keys(data , rootKey = ''){

    let keys = Object.keys(data),
        result = [];

    for(let key of keys){

        let value = data[key] ;

        if(isObject(value)){

            result.push(...get_keys(value , `${rootKey}${key}.`)) ;
        
        }else{

            result.push(`${rootKey}${key}`) ;
        }
    }

    return result ;
}
    return function(data){
        
        if(!__first_executed_1534494806877__){
            isObject = include('is.object');
            
            __first_executed_1534494806877__ = true ;
        }
        
        
        return main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.equals">
        <![CDATA[(() =>{
    let keys,get;
    
    
    
    let __first_executed_1534494807352__ = false ;
    
    
    function main(value1,value2){

        

let keys1 = keys(value1),
    keys2 = keys(value2) ;

if(keys1.length !== keys2.length){

    return false ;
}

for(let key of keys1){

    if(!keys2.includes(key) || get(value1 , key) !== get(value2 , key)){

        return false ;
    }
}

return true ;
    }
    return function(value1,value2){
        
        if(!__first_executed_1534494807352__){
            keys = include('object.keys');
get = include('object.get');
            
            __first_executed_1534494807352__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , value1,value2) ;
    }
    

})() ;]]>
    </class>

    <class name="src::url.template.apply">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    function main(url,data){

        

return url.replace(/\:([a-z]+)/g , (match , name) =>{

    return data[name] || '' ;

}) ;
    }
    return function(url,data){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , url,data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::url.isAbsolute">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    function main(url){

        

return /^https?\:\/{2}/.test(url) ;
    }
    return function(url){
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , url) ;
    }
    

})() ;]]>
    </class>

    <class name="src::url.join">
        <![CDATA[(() =>{
    let isAbsolute;
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    

const urlSuffixRe = /\/$/ ;

function main(...urls){

    let len = urls.length,
        i = 0,
        result = [];

    for(; i < len ; i ++){

        let part = urls[i] || '';

        part = part.replace(urlSuffixRe , '') ;

        if(isAbsolute(part)){

            result.length = 0 ;

            result.push(part) ;
        
        }else if(part){

            result.push(part) ;
        }
    }

    return result.join('/') ;
}
    return function(...urls){
        
        if(!__first_executed_1534494806877__){
            isAbsolute = include('url.isAbsolute');
            
            __first_executed_1534494806877__ = true ;
        }
        
        
        return main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , ...urls) ;
    }
    

})() ;]]>
    </class>

    <class name="src::url.append">
        <![CDATA[(() =>{
    let isString;
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    function main(url,data){

        

let querystring ;

if(isString(data)){

    querystring = data ;

}else{

    const {
        stringify
    } = require('querystring') ;
    
    querystring = stringify(data);

}

if(url.includes('?')){

    return `${url}&${querystring}` ;
}

return `${url}?${querystring}` ;
    }
    return function(url,data){
        
        if(!__first_executed_1534494806877__){
            isString = include('is.string');
            
            __first_executed_1534494806877__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , url,data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::xml.parse">
        <![CDATA[(() =>{
    
    
    
    
    let __first_executed_1534494806877__ = false ;
    
    
    

const {
    DOMParser
} = require('xmldom'),
parser = new DOMParser();

function main(){

    try{

        return parser.parseFromString(data , 'text/xml') ;

    }catch(err){


    }

    return parser.parseFromString('<xml/>' , 'text/xml') ;
}
    return function(data){
        
        
        return main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , data) ;
    }
    

})() ;]]>
    </class>

    <class name="src::object.assign">
        <![CDATA[(() =>{
    let getKeys,set,get;
    
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    function main(dest,source){

        

let keys = getKeys(source) ;

for(let key of keys){

    set(dest , key , get(source , key)) ;
}

return dest ;
    }
    return function(dest,source){
        
        if(!__first_executed_1534494806878__){
            getKeys = include('object.keys');
set = include('object.set');
get = include('object.get');
            
            __first_executed_1534494806878__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , dest,source) ;
    }
    

})() ;]]>
    </class>

    <class name="config::http">
        <![CDATA[{
    "default":{
        "timeout":20000,
        "type":"json"
    }
} ;]]>
    </class>

    <class name="src::http.params.parse">
        <![CDATA[(() =>{
    let apply,isObject,isString,join,append,parse,assign,configHttp;
    let http;
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    

function main(uri , method , params){

    method = method.toUpperCase() ;

    let name ;

    if(isString(params)){

        name = params ;

        params = {} ;
    
    }else if(isObject(params)){

        name = params.name || 'default';

        delete params.name ;
    
    }else{

        name = 'default' ;

        params = {} ;
    }

    let httpConfig = http[name];

    if(httpConfig){

        let {
            root:rootPath,
            type,
            headers,
            timeout
        } = httpConfig,
        {
            request:requestType,
            response:responseType
        } = process_type(type) ;

        let {
            query,
            path,
            body,
            timeout:userTimeout
        } = params;

        return assign({
            uri:append(join(rootPath , apply(uri , path)) , {
                _dc:Date.now()
            }),
            timeout,
            requestTimeout:timeout || 0,
            method,
            headers,
            qs:query,
            transform:transform(responseType)
        } , process_body(body , requestType) , process_timeout(userTimeout));
    }

    throw new Error('') ;
}

function process_timeout(timeout){

    if(timeout){

        return {
            timeout,
            requestTimeout:timeout
        } ;
    }

    return {} ;
}

function process_body(body , type){

    switch(type){

        case 'json':

            return {
                body,
                headers:{
                    'content-type':'application/json'
                },
                json:true
            } ;

        case 'xml':

            return {
                headers:{
                    'content-type':'application/xml'
                },
                body
            } ;

        case 'form':

            return {
                formData:body
            } ;

        case 'html':

            return {
                headers:{
                    'content-type':'text/html'
                },
                body
            } ;
    }

    return {
        body
    } ; ;
}

function process_type(type){

    if(isObject(type)){

        let {
            request,
            response
        } = type ;

        return {
            request,
            response
        } ;
    
    }else if(isString(type)){

        return {
            request:type,
            response:type
        } ;
    }

    return {
    } ;
}

function transform_json(body){

    if(isString(body)){

        return JSON.parse(body) ;
    }

    return body ;
}

function transform_xml(body){

    return parse(body) ;
}

function transform_html(body){


}

function transform_empty(body){

    return body ;
}

function transform(type){

    switch(type){

        case 'json':

            return transform_json ;

        case 'xml':

            return transform_xml ;

        case 'html':

            return transform_html ;
    }

    return transform_empty ;
}
    return function(uri,method,params){
        
        if(!__first_executed_1534494806878__){
            apply = include('url.template.apply');
isObject = include('is.object.simple');
isString = include('is.string');
join = include('url.join');
append = include('url.append');
parse = include('xml.parse');
assign = include('object.assign');
configHttp = include('config::http');
            http = config('http');
            __first_executed_1534494806878__ = true ;
        }
        
        
        return main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , uri,method,params) ;
    }
    

})() ;]]>
    </class>

    <class name="src::http.methods.get">
        <![CDATA[(() =>{
    let parse;
    
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    function main(uri,params){

        

return require('request-promise')(parse(uri , 'get' , params)) ;
    }
    return function(uri,params){
        
        if(!__first_executed_1534494806878__){
            parse = include('http.params.parse');
            
            __first_executed_1534494806878__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , uri,params) ;
    }
    

})() ;]]>
    </class>

    <class name="src::http.methods.post">
        <![CDATA[(() =>{
    let parse;
    
    
    
    let __first_executed_1534494806878__ = false ;
    
    
    function main(uri,params){

        

return require('request-promise')(parse(uri , 'post' , params)) ;
    }
    return function(uri,params){
        
        if(!__first_executed_1534494806878__){
            parse = include('http.params.parse');
            
            __first_executed_1534494806878__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , uri,params) ;
    }
    

})() ;]]>
    </class>

    <class name="src::http.methods.put">
        <![CDATA[(() =>{
    let parse;
    
    
    
    let __first_executed_1534494806879__ = false ;
    
    
    function main(uri,params){

        

return require('request-promise')(parse(uri , 'put' , params)) ;
    }
    return function(uri,params){
        
        if(!__first_executed_1534494806879__){
            parse = include('http.params.parse');
            
            __first_executed_1534494806879__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , uri,params) ;
    }
    

})() ;]]>
    </class>

    <class name="src::http.methods.delete">
        <![CDATA[(() =>{
    let parse;
    
    
    
    let __first_executed_1534494806879__ = false ;
    
    
    function main(uri,params){

        

return require('request-promise')(parse(uri , 'delete' , params)) ;
    }
    return function(uri,params){
        
        if(!__first_executed_1534494806879__){
            parse = include('http.params.parse');
            
            __first_executed_1534494806879__ = true ;
        }
        
        
        return  main.call((function(){

            let me = this,
                target;

            if(typeof global !== 'undefined'){

                target = global ;
            
            }else{

                target = window ;
            }

            return me === target ? main : me ;

        }).call(this) , uri,params) ;
    }
    

})() ;]]>
    </class>

    <class name="src::http">
        <![CDATA[(() =>{

    
        class Main{
            static get(){
                    return include('http.methods.get').apply(this , arguments) ;
                }static post(){
                    return include('http.methods.post').apply(this , arguments) ;
                }static put(){
                    return include('http.methods.put').apply(this , arguments) ;
                }static delete(){
                    return include('http.methods.delete').apply(this , arguments) ;
                }
        };
        

    return Main ;

})() ;]]>
    </class>



</classes>